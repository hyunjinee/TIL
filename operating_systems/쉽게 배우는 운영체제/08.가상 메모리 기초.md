## 가상 메모리

### 가상 메모리 개요

메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존하면 2GB의 메모리에서 동작하는 프로그램이 1GB의 메모리에서는 동작하지 않을 수 있다. 프로그래머 또한 메모리 크기에 맞는 응용 프로그램만 개발해야 하는데, 실제 메모리 크기를 고려해서 프로그래밍하기란 매우 어렵다.

현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것이다. 이러한 메모리 시스템을 가상 메모리라고 부른다. 가상 메모리는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다. 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느정도인지 신경쓰지 않고 메모리를 마음대로 사용할 수 있다.

가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지 상관없이 0번지부터 시작하는 연속된 메모리 공간을 가진다. 이론적으로 가상 메모리는 무한대의 크기를 갖는다. 그러나 실제로 가상 메모리의 최대 크기는 컴퓨터 시스템이 가진 물리 메모리의 최대 크기로 한정되며, CPU의 비트에 따라 결정된다.

32bit CPU의 최대 메모리 크기는 4GB이다. 이 시스템에서 각각 4GB의 주소 공간을 차지하는 10개의 프로세스를 동시에 실행하려면 운영체제를 포함하여 적어도 40GB의 메모리가 필요하다. 이 경우 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간, 즉 스왑 영역으로 옮긴다. 스왑 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역으로서 메모리의 일부이며, 가상 메모리의 구성 요소 중 하나이다.

메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충한다. 즉 물리 메모리가 꽉 찼을 때 일부 프로세서를 스왑 영역으로 보내고(스왑아웃), 몇 개의 프로세스가 작업을 마치면 스압 영역에 있는 프로세스를 메모리로 가져온다.(스왑인)

따라서 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리(실제 메모리)와 스왑영역을 합한 크기이다.

가상 메모리 시스템에서 메모리 관리자는 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는데 이러한 작업을 동적 주소 변환(Dynamic Address Translation, DAT)라고 한다. 동적 주소 변환을 거치면 프로세스가 아무런 제약 없이 사용자의 데이터를 물리 메모리에 배치할 수 있다. 이 과정에서 메모리 관리자는 물리 메모리를 어떤 방법으로 나눌지, 사용자 프로세스를 어디에 배치할지, 부족한 메모리를 어떻게 처리할지 등의 복잡한 문제를 처리한다.

## 페이징 기법

고정 분할 방식으로 메모리를 분할하여 관리하는 페이징 기법에서 가상 주소를 물리 주소로 변환하는 방법과 매핑 테이블 관리 방법을 알아보자.

### 페이징 기법의 구현

페이징 기법은 고정 분할 방식을 사용한 가상 메모리 관리 기법으로, 물리 주소 공간을 같은 크기로 나누어 사용한다.

![image](https://user-images.githubusercontent.com/63354527/174474626-78e9487c-4299-409e-b52b-06212dea8f0e.png)

물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임이라고 부른다. 페이지와 프레임의 크기는 같다. 페이지와 프레임은 크기가 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다. 모든 페이지의 위치 정보, 즉 어떤 페이지가 어떤 프레임에 있는지에 대한 연결(매핑)정보는 페이지 테이블에 담겨 있다.

### 페이징 기법의 주소 변환

페이징 기법에서는 가상 주소를 VA=<P,D>로 표현하는데 여기서 VA는 가상주소(Virtual Address), P는 페이지, D는 페이지의 처음 위치에서 해당 주소까지의 거리(distance)를 의미한다.

페이징 기법에서의 주소 변환은 가상 주소 VA = <P,D>를 물리주소 PA = <F,D>로 변환하는 것이다. PA는 물리 메모리 주소를 가리키는 용어로 물리주소 또는 실제 주소라고 한다. F는 프레임, D는 distance를 의미한다.

```jsx
VA = <P, D> -> PA = <F, D>
```

주소 변환과정에서 D는 변하지 않는데, 이유는 페이지와 프레임의 크기를 똑같이 나눴기 때문이다.

페이지 테이블을 이용하면 가상 주소를 물리 주소로 변환할 수 있다. 페이지 테이블에서 페이지 번호를 찾아 해당 프레임 번호를 쫒아가면 된다. 페이지 테이블은 페이지 번호, 프레임 번호로 구성되며, 각각의 한 줄은 페이지 테이블 엔트리(Page Table Entry, PTE)라고 부른다. 다시 말해 페이지 테이블은 페이지 번호, 프레임 번호로 구성된 페이지 테이블 엔트리의 집합이다.

### 페이지 테이블 관리

페이지 테이블 관리가 복잡한 이유는 시스템에 여러개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문이다. 프로세스는 메모리에 올라와야 실행 가능하므로 모든 프로세스의 일부 페이지가 물리 메모리의 프레임에 올라와 있고, 어떤 페이지가 어떤 프레임에 있는지 관리하기 위해 프로세스마다 페이지 테이블을 운영한다. 메모리 관리자는 특정 프로세스가 실행될 때마다 해당 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환하는 작업을 반복한다.

페이지 테이블은 메모리 관리자가 자주 사용하는 자료구조이므로 필요시 빨리 접근할 수 있어야 한다. 따라서 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아 놓는다.

### 페이지 테이블 매핑 방식

시스템 내에는 여러개의 프로세스가 존재하고, 각 프로세스는 하나의 페이지 테이블을 가지며, 페이지 테이블은 운영체제 영역에 있다. 따라서 페이지 테이블의 크기가 너무 커지면 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.

사용할 수 있는 물리 메모리 영역이 적을 경우 프로세스만 스왑영역으로 옮겨지는 것이 아니라 페이지 테이블의 일부도 스왑영역으로 옮겨진다. 따라서 페이지 테이블 전체를 메모리에서 관리하느냐, 일부를 스왑 영역에서 관리하느냐에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라지므로 페이지 테이블이 위치한 곳에 따른 다양한 페이지 테이블 매핑 방식을 살펴보자.

- 직접 매핑: 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식. 별다른 부가 작업없이 변환이 가능
- 연관 매핑: 페이지 테이블 전체를 스왑 영역에서 관리하는 방식. ㅁ루리 메모리의 영유 공간이 적을 때 사용하는 방식으로 모든 페이지 테이블을 저장장치의 스왑영역에 저장하고 그중 일부만 물리메모리에 가지고 있다.
- 집합-연관 매핑: 연관 매핑의 문제를 개선한 방식. 연관 매핑에서는 물리 메모리에 있는 데이터가 무작위로 올라오기 때문에 원하는 프레임 번호를 얻기 위해 모든 테이블을 검색해야하는 문제가 있었다. 그러나 집합 연관 매핑에서는 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져온다.
- 역매핑: 물리 메모리의 프레임 번호를 기준으로 테이블을 구성한다 .다시 말해 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시한다. 역매핑의 가장 큰 특징은 프로세스의 수와 상관없이 테이블이 하나만 존재한다는 것. 다른 방식에서는 프로세스마다 페이지 테이블을 만들지만 역매핑에서는 물리 메모리를 기준으로 프레임 테이블을 만들기 때문에 전체 시스템에서 테이블의 수가 단 1개이다.

## 세그멘테이션 기법

세그먼테이션 기법에서 가상 주소가 물리 주소로 변환할 때 페이징 기법과 마찬가지로 세그먼테이션 기법도 매핑 테이블을 사용하는데 이를 세그먼테이션 테이블 또는 세그먼테이션 매핑 테이블이라고 한다.

세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit와 물리 메모리 상의 시작 주소를 나타내는 address가 있다. 페이징 기법에서는 메모리를 같은 크기의 페이지 단위로 분할하기 때문에 매핑 테이블에 크기 정보를 유지할 필요가 없다. 하지만 세그먼 테이션 기법에서는 프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함한다.

세그먼테이션 기법은 가변 불할 방식을 기본으로 하므로 가변 분할 방식의 장점과 단점을 모두 가진다. 장점으로는 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순하다는 것을 꼽을 수 있고, 단점은 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡하다는 것이다.

세그먼테이션 기법에서는 가상 주소를 VA=<S,D>로 표현한다. 여기서 S는 세그먼트 번호, D는 세그먼트 시작 시점에서 해당 주소까지의 거리 distance를 의미한다. 가상 메모리 시스템에서 사용자에게 보이는 메모리는 항상 0부터 시작하므로 페이징 기법이든 세그먼테이션 기법이든 D는 사용자가 지정한 주소 그 자체이다.

## 세그먼테이션-페이징 혼용 기법

메모리 접근 권한은 메모리의 특정 번지에 저장된 데이터를 사용할 수 있는 권한으로 읽기, 쓰기, 실행, 추가 권한이 있다. 이 네가지 권한은 복합적으로 사용되는데, 예를 들면 일반적인 데이터에는 읽기 및 쓰기 권한이 적용되고, 상수나 읽기 전용 파일에는 읽기 권한이 적용된다. 또한 일반적인 코드 영역에는 읽기 및 실행 권한이 적용된다.

프로세스는 몸체에 해당하는 코드영역, 프로세스가 사용하는 데이터를 저장하는 데이터영역, 프로세스를 실행하는데 필요한 스택영역과 프로세스 제어블록으로 구성도니다.

코드 영역과 데이터 영역의 접근 권한은 다음과 같다.

- 코드 영역: 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행권한
- 데이터 영역: 데이터는 크게 읽거나 쓸 수 있는 데이터와 읽기만 가능한 데이터로 나눌 수 있다. 일반적인 변수는 읽거나 쓸 수 있으므로 읽기 및 쓰기 권한을 가지고 상수로 선언한 변수는 읽기 권한만 가진다.

메모리 접근 권한 검사는 가상 주소에서 물리 주소로 주소 변호나이 일어날 때마다 시행된다. 읽기만 가능한 메모리 영역에 쓰기를 하려고 하면 메모리 오류인 트랩이 발생한다.

사용자가 특정 주소를 요청했을 때 세그먼테이션 테이블에서 오류가 없는지, 또 접근 권한을 가지고 있는지 확인하고, 이를 통과하면 연결된 페이지 테이블로 가서 원하는 프레임을 찾는다. 만약 원하는 페이지가 물리 메모리에 없으면 스왑 영역에서 해당 페이지를 가져온다.
