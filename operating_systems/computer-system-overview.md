# Ch1. Computer System Overview

## What is an Operating System?

→ Software that operates a computer system.

→ Resource utilization and GUI (Graphical User Interface)

→ There is no one description. The more common definition is that ‘The one program running at all times on the computer.’ (usally called the kernel)

- 컴퓨터 하드웨어를 관리하는 시스템, 하드웨어의 최상단 소프트웨어의 최하단
- 컴퓨터 하드웨어와 사용자 사이의 중개인 역할
- 운영체제는 소프트웨어
- 오직 OS만이 하드웨어와 직접 소통할 수 있다.
- program running at all times on the computer
- to provide system services to application programs

운영체제:software that operates a computer system

computer: a machine that processes the information.

![11](https://user-images.githubusercontent.com/63354527/169681391-1a5e2c41-e88c-4d26-874d-d2fbaf743189.png)

                                             운영체제의 계층적 위치

커널은 운영체제의 핵심이며, 실체이다. 운영체제는 커널과 커널 모듈로 구성된다.

커널은 운영체제의 핵심이기에 운영체제와 동일시 되고, 커널이 같다면 같은 운영체제로 취급한다.

운영체제의 역할은 사용자 시점과 시스템 시점에 따라 달라진다.

## OS View Points

### User View

사용자 시점에서의 목표는 손쉬운 사용이다. Resource Utilization은 사용자가 생각하지 않는다.

### System View

- Resource allocator
- Resource utilization
- Resource : (CPU, Memory, Storage, I/O Devices, network, harddisk, ssd 등)
- Control program : 컴퓨터 자원을 관리하고 에러 방지하며, 컴퓨터의 잘못된 사용을 막는다. (권한관리, 같은 메모리 접근 방지)

## Computer System

A Computer system can be divied roughly into four components

- Computer HW, OS, System/application programs, User
- 오직 OS만이 하드웨어와 직접 소통가능하다.

![Absract view of the components of a computer system](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f7cf9f8b-4116-4c18-837c-08a257593fed/Untitled.png)

Absract view of the components of a computer system

Modern computer system consists of

- one or more CPUs
- a number of device controllers connected through a common **bus**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bec7e524-91ed-444f-8801-02d88d68cc4d/Untitled.png)

### 컴퓨터의 부팅

컴퓨터 부팅은 크게 두가지로 나뉜다.

- POST (Power-On-Self-Test)를 통해 컴퓨터의 각 장치에 대한 점검을 진행하는 과정
- 부트로더를 통해 저장장치 내에 운영체제와 관련된 데이터를 메모리에 적재하는 과정
- bootstrap is the first program to run on coputer power-on and then loads the operating system.

컴퓨터 on → 부트스트랩(컴퓨터의 ROM(Read Only Memory)이나 EEPROM(Electrically Erasable Programmable Read-Only)에 저장되어있음)이라는 초기화 프로그램 실행 → 시스템을 초기화, 부트로더를 실행 → 부트로더는 운영체제를 실행

유닉스의 경우 처음 실행되는 프로세스는 init 이고, 이는 다른 데몬을 실행시킵니다. 데몬은 프로세스로 백그라운드에서 돌면서 시스템 로그등을 남기는 여러 작업을 진행합니다. 이 작업이 끝나면 부팅이 끝나고, 이벤트가 발생하기를 기다립니다.

## Interrupts

- CPU에게 실행을 멈추고 interrupt handler를 실행하라고 보내는 event
- Interrup vector : Interrupt handler 주소들의 배열
- Interrupt 된 instruction의 현재 주소와, register상태를 저장해두어야 한다.
- Interrupt the normal sequencing of the processor
- Classes of Interrupts
  - Program: arithmetic overflow, division by zero, attempt to execute an illegal machine instruction
  - Timer: Generated by a timer within the processor.
  - I/O: Generated by an I/O controller, to signal normal completion of an operation or to signal a variety of error conditions
  - Hardware failure: Generated by a failure, such as power failure or memory parity error.

### 하드웨어 인터럽트

- ISR(Interrup Service Routine)을 통해 하드웨어가 필요한 동작을 운영체제로 요청, 끝나면 다시 대기상태
- Hardware may trigger an interrupt at any time by sending a signal to the CPU, usually by way of the system bus.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dcbcafc5-6b49-4f2e-b021-cdcff631fb1e/Untitled.png)

### 소트트웨어 인터럽트

- 프로그램 실행시 ISR을 통해 운영체제에 필요한 동작을 요청 → ISR이 종료되면 다시 사용자 프로그램의 작업 수행
- system call

### 폰노이만 구조

- first fetches an instruction from memory and stores that instruction in the instruction register.
- The instruction is then decoded and may cause operands to be fetched from memory and stored in some internal register.
- After the instruction on the operands has been executed, the result may be stored back in memory.

### Storage device hierarchy

![1](https://user-images.githubusercontent.com/63354527/169681203-e0e738fa-09f3-499d-b35a-376abe9c1513.png)

- 위로갈수록 빠르고 비싸고 휘발성 (volatile)
- 아래로 갈수록 느리고 싸고 비휘발성 (non - volatile)

## I/O Structure

- A large portion of OS code is dedicated to managing I/O

![2](https://user-images.githubusercontent.com/63354527/169681239-c8549edb-3d0f-4d9d-9f42-10c47828c4e6.png)

```jsx
모든 장치는 Device controller를 가지며, CPU는 이것들을 가지고 장치와 소통한다.
CPU와 Device controller 는 공통된 bus를 통해 연결된다.
OS는 Device controller와 어떻게 상호작용해야 하는지 적힌 Device driver를 갖는다.
장치 제조사에서는 Device Driver를 소프트웨어 형태로 제공해야한다.
Device driver 소프트웨어는 read, write와 같은 기능을 구현하는 함수의 집합이다.
```

![3](https://user-images.githubusercontent.com/63354527/169681257-40812f62-0f11-4377-8897-61cd80f12999.png)

computer components. Top-level view

### CPU

- The hardware that executes instructions.

### Main Memory

- volatile
- contents of the memory is lost when the computer is shut down
- Referred to as real memory or primary memory

### I/O Modules

- Moves data between the computer and external enviroments such as : storage ,communications equipment, terminals

### System Bus

- Provides for communication among processors, main memory, and I/O modules

### Processor

- controls the operation of the computer
- performs the data processing functions
- referred to as the central processing unit (CPU)
- A physical chip that contains one or more CPUs.

CPU는 두가지 상태를 갖는다.

- User process executing
- I/O interrupt processing

CPU가IO 작업을 직접하긴 성능이 아깝다. (옛날에는 CPU가 수행) → IO모듈을 설치해서 어떤 데이터가 필요한지 명령내리고 자기는 다른 일함 IO모듈은 디스크에서 자료를 찾아서 메모리에 적재 DMA(DIRECT MEMORY ACCESS) CPU는 그시간에 다른거 실행하기 때문에 퍼포먼스 증가

실제 CPU가 제어하는건 DMA를 컨트롤하는 DMAC를 컨트롤한다.

DMA controller는 os가 아닌 별도의 장치이다.

```jsx
IO가 작업 중이더라도, CPU는 다른 작업을 할 수 있고,
IO작업이 완료되면, 그제서야 인터럽트가 발생한다.
```

## Computer System Architecture

### Single processor systems

- 하나의 general-purpose processor + 많은 special-purpose processors

### Multi processor systems

- 2개 이상의 프로세서로 구성된 하나의 시스템
- SMP (Symmetric multi processing): most common multiprocessor systems in which each peer CPU processor performs all tasks.
  - 대칭적인 프로세싱: 포지션별로 모두 같은 일을 한다.
  - 각 프로세서는 OS의 모든 작업을 수행
  - 모든 프로세서가 하나의 물리 메모리를 공유
    - UMA (Uniform memory access): 어느 프로세서에서 어느 메모리에 접근하든 동일한 시간이 걸림
- Asymmetric multiprocessing: each processor is assigned a specific task.
  - 하나의 프로세서가 다른 프로세서와 Master-slave 관계
  - Master process 하나는 전체 시스템 (다른 프로세스)를 컨트롤한다.
  - Slave process는 Master process에게 작업을 할당받아서 명령을 수행

### Multicore system

- with several cores on the same processor chip
  - 하나의 칩 내에서 커뮤니케이션 (정보교환)이 효율적
  - CPU 2개의 커뮤니케이션보다 CPU한개 내의 두개의 코어끼리 커뮤니케이션이 더 효율적임
    - 칩 내부 통신(on-chip communication) , 칩 사이의 통신 (between chip communication)
  - 각각 register와 cache를 갖음
  - 비용이 저렴
    - 전력 소비가 낮고 더 낮은 파워 사용가능
    - 하나의 칩에 여러개의 코어를 담으면 전력을 적게사용
  - 각 코어는 자신만의 레지스터와 로컬 캐시를 갖는다. (하나의 캐시를 공유하기도함)

![4](https://user-images.githubusercontent.com/63354527/169681281-7c76e440-8ff8-411b-ba54-d96b966727d3.png)

## Operating System Operations

OS는 Interrupt driven 하다. → 인터럽트가 없다면 OS는 백그라운드에서 아무것도 하지 않는다.

### Multiprogramming

- runs more than one program at a time
- keeps several processes in memory simultaneously.
- to increase CPU utilization
- 우리는 CPU를 바쁘게 움직이게 해야한다. CPU가 idle 인 것을 원하지 않는다.
- Job pool : 작업들이 로드되기를 기다리는 개념적 공간
- 사용자가 수행하고 싶은 프로그램은 많은데, 메모리는 그만큼 충분하지 않다. 모든 프로그램이 한번에 로드될 수 없으니 Job Pool에 대기시키고, Job switching 을 통해서 Memory에 로드된 프로그램중 하나를 Job pool의 프로그램으로 대체

![5](https://user-images.githubusercontent.com/63354527/169681291-e3e64876-2f8d-4d10-ae02-f74ea7613b19.png)

Memory layout for a multiprogramming system.

초기의 컴퓨터는 하나의 프로그램을 처리한 후에 다음 프로그램을 처리해야했습니다. 하지만 하나의 프로그램을 사용할 때 프로세서의 처리속도와 입출력 속도간의 차이가 너무 크기 때문에 입/출력 작업이 완료 될 때까지 프로세서는 대기해야합니다. 이것은 프로세서의 자원을 낭비하는 결과를 가져오게되었고, 따라서 프로세서가 입/출력 작업의 응답을 대기할 동안 다른 프로세스를 수행 시킬 수 있도록 하는 것이 멀티 프로그래밍입니다.

Multiprogramming은 프로세서의 자원 낭비를 최소화하기 위해 낭비되는 시간을 다른 프로세스 수행에 쓰게하여 하나의 프로세스에서 여러 프로세스를 교대로 수행할 수 있게 하는 것입니다.

time-sharing.

### Multitasking(= multiprocessing)

- a logical extension of multiprogramming
- CPU switches jobs so frequently that users can interact with each job while it is running.

task 는 어떤 일을 수행하기 위한 명령어 집합이다. 하나의 프로그램은 프로그램 내에 정의에 따라 하나 또는 그 이상의 프로세스가 될 수 있다. 하나의 task라는 개념은 프로세스의 개념보다 조금 확장된 개념인데 이러한 하나의 task가 프로세서상에서 운영체제의 스케줄링에 따라 조금씩 번갈아 가면서 수행되는것이 Multi-Tasking이다.

멀티 프로그래밍이 낭비되는 자원을 최소화하기 위해 교대로 실행했다면, 멀티태스킹은 좀더 확장하여 정해진 시간동안 교대로 task를 수행하는 것입니다.

### Multi-threading

thread는 프로세스내에서 생성되는 하나의 실행 주체이다. 한 프로세스 내에서 생성되는 것으로 여러개가 동시에 생성이 가능하다. 또한 생성된 여러 쓰레드는 하나의 공유 메모리를 가지게 된다. 그렇기 때문에 서로간에 정보를 주고받는데 최소한의 오버헤드로써 제한이 많이 없는 편 입니다.

Multi-Threading은 서로간의 자원 공유가 가능하며, 프로그래밍을 통해 구현할 수 있다는 점이다.

Multi-tasking은 운영체제에서 지원해주는 기능으로 서로간의 자원 공유가 되지 않기 때문에 자원 전달을 위해서 별도의 IPC(Inter-Prodcess Communication)을 구현해야하며, 멀티쓰레딩에 비해 운영체제에게 부담을 줄 수 있습니다.

멀티 태스킹은 서로간의 독립된 메모리를 가지고 있기 때문에 독립된 수행이 가능하다는 장점도 존재합니다.

### Multi-processing

멀티 프로세싱은 단어 그대로 하나의 프로세서가 아닌 하나이상의 프로세서가 서로 협력하여 일을 처리하는 것을 가르킵니다. 많은 작업을 빠른 시간에 처리하기 위해서는 하나의 프로세서가 처리하는 것은 비효율적입니다.

따라서, 여러개의 프로세서가 하나의 작업을 병렬처리하는 것이 효율적입니다. 여러개의 프로세서가 하나의 컴퓨터에 있을 수 있고, 여러대의 컴퓨터에 있을 수 있습니다. 따라서 멀티 프로세싱의 개념을 컴퓨터로 나누기 보다는 여러개의 프로세서, 즉 하나이상의 프로세서가 작업을 병렬처리하는 것으로 정의하는 것이 좀더 명확한 개념입니다.

++

- 멀티 프로세서 시스템은 일반적인 컴퓨터 시스템. 멀티프로세서 컴퓨터는 2개 이상의 프로세서를 갖는다.
- 프로세서 개수가 증가하면 처리량이 증가한다. 프로세서를 계속 늘린다고 성능이 한없이 좋아지는 것은 아니며 증가비율이 1:1 인것도 아니다.
- 멀티프로세서 시스템은 여러대의 싱글 프로세서 시스템을 구축하는 것보다 돈이 적게든다. 멀티프로세서 시스템은 주변장치를 공유할 수 있기 때문이다.
- 만약 기능이 여러 프로세서에 분산될 수 있다면 하나의 프로세서가 작동을 멈춰도 전체 시스템은 느려질 뿐 멈추지 않는다. 이런식으로 성능은 나빠지지만 작동은 가능하도록 하는 것을 **우아한 성능저하**(Graceful degradation)라고 부른다.
- 멀티 프로세서 컴퓨터는 2개 이상의 프로세서를 가지고 있다. 멀티 프로세서 시스템은 **비대칭 멀티프로세싱**(Asymmetric multiprocessing)과 **대칭 멀티프로세싱**(Symmetric multiprocessing) 두 가지로 나뉜다. 비대칭 멀티프로세싱은 master노드가 죽으면 slave들도 다 멈추게된다. 하지만 부하분산은 효율적으로 할 수 있다. 대칭 멀티프로세싱은 다 수평적이다. 모든 프로세서들은 하나의 메모리를 공유하고 동일한 작업을 병렬적으로 수행하다가 프로세서에 이상이 생겨 작동을 멈춰야 한다면 자신이 수행하던 작업을 다른 프로세서들에게 나눠주고 자신만 재부팅한다. 재부팅후 문제가 해결되면 다시 작업을 나눠받는다.
- 비대칭 멀티프로세싱은 시스템의 단점을 보완할 수 있는 아키텍처이기 때문에 대부분 컴퓨터 시스템은 대칭 멀티프로세싱을 사용.

### Time sharing (Multi-tasking)

- 메모리에 로드된 프로그램들 사이의 교체 (Switching)
- 빠른 교체 → 사용자 시각에서 더 interactive
- 멀티 프로그래밍과 더불어 매우 중요한 기능

### Process

- **메모리에 로드된, 프로그램의 running instance.**
- a program in execution , an instance of a running program
- Program: 단순한 instruction의 집합. 파일 하나
- 프로세스는 프로그램과 더불어 추가적인 정보 (메모리 사용, 권한, 언제 시작되었는지...)까지 저장한다.
- Process = Program + State. 프로그램은 단순한 instruction set이다.

![7](https://user-images.githubusercontent.com/63354527/169681304-858ad3af-13d5-42a7-bb4c-ca198b3fd86a.png)

### Trap

- user process의 exception
  - Div by zero, invalid addr, Ctrl+C, Child process ended,
- Interrupt Service Routine(ISR)
  - 특정 종류의 인터럽트를 핸들링하는, 커널 내부의 함수의 집합
  - 이 인터럽트가 발생하면 → 이렇게 처리해라

### Two seperate mode of operations

- user mode
  - 커널모드 보다 제한적
- kernel mode : Supervisor mode, System mode, Privileged mode

- CPU는 현재 모드를 나타내기 위한 mode bit 제공 (kernel mode = 0 , user mode =1 )
- CPU Register 내에는 많은 특수 목적 레지스터들이 있다.

![1](https://user-images.githubusercontent.com/63354527/169681319-f3775ac6-6633-4051-8113-9ab2f1b8c06c.png)

1. User process 실행중 → System call 호출 (Trap 발생)
2. Mode switch : mode bit → 0 으로 바뀌고 커널모드로 바뀜
3. System call 수행
4. Mode switch : mode bit → 1
5. User process 가 system call로 부터 돌아왔고 계속해서 실행

- **Previleged instructions (특권 명령)**
  - 시스템에 악영향을 끼칠 수 있는 일부 instructions들
  - 오직 커널모드에서만 실행가능
  - 유저모드에서 실행하려고 하면 Trap발생

## 교수님 Talk.

- 코드는 컴파일되서 하드디스크에 있다가 로더라는 프로그램을 통해서 메인메모리에 적재
- 바이너리 코드가 메인메모리에 적재가되면 Executable code -
- 인퍼럽트라는 것은 어떤 이벤트가 발생했음을 알려줌
- instruction은 IR에 저장되고 그 위치는 PC (Program Counter)에 저장
- 버퍼는 하나의 임시 저장소이고 메인메모리에 있는 데이터가 하드디스크의 버퍼에 저장
- 마이크로 프로세서 하나의 싱글칩의 프로세서 마이크로프로세서 없었으면 스마트폰 시대는 없었을 것이다.
- cpu에는 레지스터가 여러개 있고 PC는 메모리를 가르키고 IR이 실행 instruction 실행후 PC증가 -
- IDT Interupt Descriptor tabel - > 오류 발생하면 여기서 그거 핸들링하는 코드 실행후 다시 돌아와서 실행
- system call table
- Programmed I/O 옛날 컴퓨터들은 CPU가 하드에 직접 접근한다. 이렇게하면 매우느리다.
- DMA (DIRECT MEMEORY ACCESS) cpu명령 내리면 seperate module이 해당 데이터를 하드에서 찾아서 메모리에 적재를 시켜놓고 cpu에 인터럽트를 걸어서 원하는 데이터가 메모리에 올라와 있음을 알려준다. CPU가 IO에서 시간을 빼았기지 않고 instruction을 실행하는데 전념할 수 있기 때문에 효율성이 높다. 오늘날 사용하는 기법이 DMA기법이다.
- 운영체제는 하드웨어 관리의 효율성, 편의성, ability to evolve
- serial processing - > simple bacth system → multiprogrammed batch system → time sharing
- uni programming
- process → a program in execution , an instance of a running program ,the entity that can be assigned to, and executeed on a processor
- System on a chip
  - to satisfy the requirements of handheld devices, the microprocessor is giving way to the SoC

![2](https://user-images.githubusercontent.com/63354527/169681335-f4765248-80f3-4c2b-8bbc-4c26ded1d16c.png)

basic instruction cycle (fetch → execute → halt)

- Instruction Register(IR)
  - Processor interperts the instruction and performs required action
  - Fetched instruction is loaded into Instruction Register
