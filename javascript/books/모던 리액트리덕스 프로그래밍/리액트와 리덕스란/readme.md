기능이란 예를 들어서 입력 양식 내부의 문자 수를 세거나 입력한 문자열을 서버사이드에 전달하는 등의 동작을 말한다.

외관과 기능이 조합돼 있는 것을 컴포넌트라고 한다. 리액트를 이용하면 컴포넌트를 쉽게 만들 수 있다.
웹으 ui는 컴포넌트 트리 구조로 볼 수 있다. 트리구조는 부모 자식 관계가 있는 것을 의미하며, 가장 위에는 웹페이지 전체가 있는 구조이다.


리액트의 특징으로는 virtual dom과 jsx가 있다.

dom이란 document object model의 약자로 html, svg, xml같은 문서에 있는 요소에 접근하기 위한 api라고 할 수 있다. dom은 이러한 형식의 문서를 트리 형태로 표현하고 이를 기반으로 각 요소에 접근할 수 있다.


이를 활용하면 문서의 구조 외관 콘텐츠를 변경할 수 이싿.

virtual dom 은 브라우저가 가지고 있는 돔과별도로 리액트가 가상으로 돔을 관리하는 기능이다.


ajax가 널리 퍼지기 시작한 이후서버는 html 을 구축하고 클라이언트 사이드는 이를 출력하기만 하면 된다는말이 없어졌다. 또한 브라우저의 처리 속도가 향상되면서 원래 서버에서 처리하던 처리를 클라이언트 사이드에서 하게 되는 경우도 많아졌다. 자바스크립트는 원래 웹 페이지에 간단한 움직임을 넣기위해 개발된 언어라서복잡한 논리를 만들기에는 굉장히 빈약하다.
그래서 서버 사이드 뿐만 아니라 클라이언트 사이드에서도 프레임워크가 필요하다는 이야기가 나왔다.
이러한 흐름속에서 backbone.js 는 모델 컬렉션 뷰를 분리해서 개발흐름을 간단하게 만들었다. 추가로 클라이언트 사이드에서 라우팅을 위한 라우터와 히스포리를 지원하면서 싱글페이지 애플리케이션에 시작에 굉장히 크게 기여했다. 하지만 뷰가 계층을 이루게 만들어야했고 뷰와 모델사이의 데이터 바인딩을 직접 설정해야 해싿. 이러한 작업은 난이도가 있는 작업이었다.
이후에 양방향 데이터 바인딩을 가진 angular.js가 유행한다. 

## 플럭스란?
클라이언트 사이드가 복잡해지면서 mvc 와 mvvm과 같은개념이 만들어졌다. 이러한 mvc와 mvvm의 기본은 외관과 데이터를 분리하는 것이다.

체크박스의 상태를 json으로 관리하게되었고 체크박스가 json을 보고 체크 상태를 직접 변경하게 만듦으로 외형과 데이터를 분리할 수 있게 된 것이다.

데이터의 흐름을 점점 이해하기 어려워지자 등장한 개념은 플럭스이다. 플럭스는 아키텍처의 일종이며, 굉장히 많은 구현체가 있다. 플럭스는 사용자 입력을 기반으로 액션을 만들고 액션을 디스패치해서 스토어에 저장한 뒤 뷰에 반영하는 흐름으로 애플리케이션을 만드는 아키텍쳐이다.
이렇게 애플리케이션을 구현하면 데이터가 한방향으로만 흐르게 되므로 애플리케이션이 간단해진다.

> 플럭스의 구성요소

뷰는 리액트 컴포넌트로 생각하면 된다. 사용자가 뷰에 어떠한 조작을 하면 해당 조작에 해당하는 액션을 생성한다.

액션은 단순한 객체이다. 단순히 어떤 행동을 할지 나타내는 객체이다. 상품을 카트에 추가한다. 상품을 구입한다라는 사용자 조작등이 액션이다. 대화상자를 출력한다. 캐시하고 있는 데이터를 초기화한다.같은 시스템적인 동작도 액션이다. 액션을 디스패치하면 액션이 스토어로 전달된다.

디스패처는 모든 데이터의 흐름을 관리한다. 하지만 디스패처 자체는 굉장히 단순한 eventemitter이며 디스패치된 데이터는 스토어로 전달된다. 디스패처를 통해 액션이 스토어로 전달된다고 생각하면된다.


스토어는 애플리케이션의 상태와 로직을 저장하는 장소이다. 스토어는 mvc에서 모델과 비슷한 것이라고 생각하면 된다. 애플리케이션 자체 도메인에서 상태를 관리할 수 있다는 것이 특징이다. 디스패처를 사용해서 전달된 액션을 받고, 이를 기반으로 애플리케이션의 상태를 변화시킨다.

스토어의 내용이 변경되면 이러한 변경을 뷰가 감지하고 화면을 다시 렌더링한다.

리덕스는 여러 플럭스 아키텍처 라이브러리중 하나로서 댄아브라모프가 만들었다. 참고로 리덕스는 어디까지나 플럭스 아키텍처 라이브러리이므로 리액트가 아닌 다른 라이브러리와 조합해서 사용할 수 있다.

리덕스에는 3원칙이라고 하는 원칙이있다.

1. 진실은 하나의 소스로부터(single source of truth)
2. 상태는 읽기 전용이다.(state in read-only)
3. 변화는 순수함수로 이루어져야한다.(changes are made with pure functions)

애플리케이션의 모든 상태를 거대한 하나의 객체로 관리한다. 따라서 애플리케이션의 디버깅과 테스트를 쉽게 할 수 있다. 또한 모든곳에서 필요한 상태를 참조할 수 있으므로 애플리케이션 구현도 간단해진다.

컴포넌트에서 애플리케이션의 상태를 참조할 수는 있지만 변경해서는 안된다. 액션동작을 디스패치해야만 애플리케이션의 상태를 변경할 수 있다. 이렇게 해야 데이터의 흐름이 한방향으로만 흐르게 만들수있다.

따라서 애플리케이션이 복잡해지는 부작용등을 막을 수 있다.


상태 변경은 부작용이 없는 순수함수로한다. 순수함수란 뭘까? 순수함수는 같은 입력값을 넣으면 같은 출력값을 내는 함수를 의미한다. 리덕스는 액션을 입력으로 받고 이로인해 변화한 상태를 출력으로본다. 그리고 이를 수행하는 순수함수가 바로 리듀서이다.



리덕스의 구성요소

리듀서

리듀서는 상태를 변화시키기위한 함수이다. 리듀서는 액션을 받고 이 액션의 내용에 따라 상태를 변화시킨다.

이 함수는 첫번째 매개변수로 state가 전달되고, 두번째 매개변수로 action이 전달된다.

state는 문자 그대로 현재 상태를 나타내는 객체이다. 리듀서는 이러한 state에 조작을 가한다.액션을 반드시 타입이라는 속성을 가지고 있어야한다. 이 속성에느 ㄴ액션이 무엇을 하는 것ㄴ지 나타내는 값이 들어있다. 일반적으로 문자열을 만들고, 타입을 애플리케이션 내부에서 유일하게 만들기 위해 symbol요소를 만들기도 한다. 

리듀서는 상태를 변화시킬 때 사용한다. 컴포넌트는 이러한 변수의 변화를 기반으로 뷰를 렌더링한다. 

```js

let x = 10;
let y = x;
y = 5;
console.log(y); // 5
console.log(x); // 10
```

위는 값전달의 예

아래는 참조 전달의 예

```js
let x= [1,2,3];
let y =x;
y[1] = 4
console.log(y); [1,4,3]
console.log(x); [1,4,3]

```
리듀서를 사용할 때 참조 전달 때문에 이런일 이 일어날 수 있을까? 리듀서로 상태를 변화한후 뷰에서 그러한 변화를 비교하고 싶은 경우가 있다. 


스프레드 연산자는 객체 또는 배열에 대해 값 복사를 수행한다. 추가로 참조를 끊는 방법으로 Object.assign이라는 메서드를 사용할 수 있엉^^