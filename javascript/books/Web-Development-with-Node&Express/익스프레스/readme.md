자바스크립트 기술 스택에는 명확한 장점이 있다. 생각하는 방식을 계속 바꾸지 않아도된다.

익스프레스 웹사이트에서는 익스프레스를 단일 다중페이지 하이브리드 웹 애플리케이션을 만드는데 필요한 견고한 기능 집합을 제공하는 최소화되고 유연한 노드 웹 애플리케이션 프레임워크라고 설명한다. 

최소화되었다? 이점은 익스프레스에서 가장 인상적인 측면이다. 프레임워크 개발자들은 적을수록 좋다라는 사실을 잊어버리곤 한다. 익스프레스의 철학은 당신의 두뇌와 서버사이에 최소한의 계층을 제공한다는 것이다. 최소한이란 말이 견고하지 않다거나 유용한 기능이 충분하지 않다는 듯이아니다. 최소한이라는 표현은 익스프레스가 끼어드는 일을 줄여서 당신의 아이디어를 완전히 표현할수 있게 하면서도 동시에 유용한 기능을 제공한다는 뜻이다.


유연한.

익스프레스철학의 다른 핵심은 확장성이다. 

웹 애플리케이션 프레임워크 

웹 사이트도 웹 애플리케이션이고 웹페이지도 웹애플리케이션이다. 애플리케이션이 더 넓은 범주이다.

즉 웹 애플리케이션은 다른 웹 애플리케이션에도 기능을 제공할 수 있다. 


익스프레스를 만든 할로웨이척은 루비에 기반을 둔 프레임워크 시나트라에 영감을 받아 익스프레스를 만들었다고한다. 익스프레스가 루비 기반 프레임워크에서 영향을 받은건 놀랄일이 아니다. 루비는 개발을 빠르고 효율적이며 관리하기 쉽게 만드는데 공헌을 많이했다.

익스프레스는 시나트라에 영향을 받기도 했고 노드의 플러그인 라이브러리인 커넥트와도 깊이 얽혀있다.

웹 요청을 처리하는 노드 플러그인 모듈에 미들웨어라는 이름이 붙은건 커넥트 때문이다.
노드는 다른 유명한 웹서버, 예를 들어 마이크로 소프트의 인터넷 정보 서비스나 아파치와 비슷한 점이 많다. 물론 어떤 점이 다늘가가 더 흥미롭다. 

익스프레스와 마찬가지로 노드역시 최소한의 웹서버로 시작한다.아파치는 몇년정도 걸릴수있다. 노드는 설치하고 설정하기가 매우 쉬운편이다.

노드어플리케이션의 장점은 플랫폼을 가리지 않는다는 것이다. 물론 노드가 최초의 플랫폼 독립서버기술은 아니지만 플랫폼을 가리지 않는다는 말은 정말 잘 새겨 들어야한다. 예를 들어 모노 덕분에 .net애플리케이션을 리눅스 서버에서 실행할 수 있긴 하지만, 그건 정말 고역이다. 마찬가지로 php애플리케이션을 윈도우 서버에서 실행할 수 있긴하지만 리눅스 서버에서 실행하는 것보다 훨씬 어렵다.

반면 노드는 다쉽다. 웹사이트 디자인팀에서는 pc와 맥을 같이 쓰는 일이 매우 흔하다. 

노드 생태계중심에는 물론 노드가있다. 노드는js가 브라우저를 벗어나 서버에서 ㄷ동작하게 해준 소프트웨어이며 익스프레스 처럼 js로 작성된 프레임워크를 쓸 수 있게 해준 주인공이다.


다른 중요 구성 요소는 데이터베이스이며, 13장에서 더 깊이 다룬다. 단순한 웹 애플리케이션을 제외하면 모두 db가 필요하며 노드 생태계에 가장 잘어울리는 db는 따로 이싿.


이들은 데이터 스토리지에 더 단순하게 접근한다. 문서 데이터베이스는 여러 종류가 있지만 이책에서는 그중 선두 주자인 몽고를 사용한다.

> 라이센스들

GNU일반 공중 사용허가서

GPL은 소프트웨어를 무료로 사용한다는 목적으로 만들어진 라이선스며 오픈소스 소프트웨어에서 널리 쓰인다. GPL 라이선스를 쓰는 코드가 프로젝트에 들어 있다면 해당 프로젝트도 반드시GPL 라이선스를 따라야한다. 따라서 소스를 공개할 수 없는 프로젝트에서 쓸 수 없다.

아파치 2.0

이 라이선스는 MIT와 마찬가지로 프로젝트에 다른 라이선스를 쓸 수 있게 허가하며 솟스를 공개하지 않는 라이선스도 상관없다. 





패키지를 직접 작성했다면 선의를 가지고 적합한 라이선스를 선택한 후 이를 정확히 명시한다.
유닉스비슷한 시스템에서 ctrl+s는 특별한 의미가 있다. 이키는 터미널을 멈춘다. 원래 이 키는 출력이 매우 빨리 스크롤 될 때 화면을 멈춰서 살펴보기 위해 만들어진 키이다. 터미널을 사용한다면 ctrl-q를 누르면 된다. 터미널이 갑자기 멈춘것 같다면 ctrl+q를 눌러서 다시 종작하는지 보면된다.

vi모드는 항상 들어있다. 



노드의 철학은 이벤트 기반 프로그래밍이다. 이벤트 기반 프로그래밍에서는 프로그래머가 어떤 이벤트를 사용할 수 있는지, 거기에 어떻게 응답해야하는지 이해해야한다. 대부분은 사용자 인터페이스를 구현하면서 이벤트 기반 프로그래밍에 익숙해진다. 즉 사용자가 뭔가를 클릭하면 당신이 클릭이벤트를 처리하는 식이다. 사용자가 뭔가 클릭하는 시점이 언제인지 아니면 클릭을 하기는 하는지에 대해 프로그래머가 전혀 컨트롤할 수 없다는 점이 이벤트 기반 프로그래밍의 특징을 매우 직관적으로 표현한다. 서버의 이벤트에 응답한다는 발상은 개념적으로 한단계 뛰어넘긴 하지만 원칙은같다.

라우팅이란 요청받은 콘텐츠를 클라이언트에 보내는 메커니즘이다. 웹 기반 클라이언트/서버 애플리케이션에서는 클라이언트가 원하는 콘텐츠를  url에 표시, 즉 경로와 쿼리스트링에 표시한다. 

익스프레스가 제공하는 스캐폴딩 유틸리티도 쓸만하긴하지만 현재 버전에서 생성하는프레임워크는 권장할 만하지 않다. 특히 필자가 선택한 템플릿 언어인 핸들비를 지원하지 않고 필자가 선호하는 명명규칙도 따르지 않는다.




호스트는 서버를 가리킨다. 당신의 컴퓨터에 있는 서버나 로컬 네트워크에 있는 서버 이름은 한 단어일 수 있고, 숫자형 ip주소일 수 있다.  인터넷 호스트이름은 .com이나 .net 같은 최상위 도메인으로 끝난다. 또한 호스트 이르ㅜㅁ 앞에 서브도메인이 붙을 수 있다. 서브도메인 이름에는 무엇이든 쓸 수 있지만 www가 가장 흔하다. 서브도메인은 옵션이다.


서버마다 여러 포트가 있다. 80이나 443 같은 일부 포트 번호는 특별하다. 포트를 생략하면 http는 80 https 는 443이라고 가정한다.

쿼리스트링은 옵션이며 이름 값 쌍을 모은 형태이다. 쿼리스트링은 물음표로 시작하고 각 이름 값 쌍은 엠퍼센드로 구분한다. 이름과 값은 모두 url인코드해야한다.
해시는 프래그먼트라고도 부르며 서버에는 전혀 전달되지 않는다. 해시는 오직 브라우저에서만 사용한다. 단일페이지 애플리케이션이나 ajax를 많이 쓰는 애플리케이션들 이 해시를 이용해 애플리케이션을 컨트롤하는 사례가 점점 늘어나고 있다. 원래 해시는 브라우저에서 앵커 태크로 표시한 문서의 특정 부분을 찾아가도록 하는 것이 유일한 목적이었다.

브라우저가 요청 헤더 형태로 서버에 정보를 보내는 것과 마찬가지로 서버는 응답할 때 브라우저가 화면에 렌더링하거나 표시하지 않는 정보를 보낸다. 응답 헤더에는 일반적으로 메타데이터와 서버 정보가 포함된다.


서버의 정보를 응답으로 보내면 해커가 사이트에 침입할 때 단서로 삼을 수 있다는 단점이있다.
보안에 대단히 민감한 서버에는 종종 이 정보를 생략하며, 가짜 정보를 제공할 때도 있다.

인터넷미디어타입과 서브타입 옵션 매개변수로구성된다(content-type)


콘텐츠 타입 인터넷미디어타입 MIME타입을 특별히 구분하지 않는다. 
multipurpose internet mail extension

요청에는 헤더외에도 본문이 있다. 일반적인 get요청에는 본문이 없지만 post요청에는 보통 본문이있다.




> res.type(type)

content-type 헤더를 설정하는 간편메서드이다. 슬래시 없는 문자열을 매개변수로 넘기면 이를 확장자로 간주하고 대응하는 인터넷 미디어 타입으로 설정하는 추가기능이있다. 

> res.format(object)

Accept 요청 헤더에 따라 다른 콘텐츠를 전송할 수 있는 메서드

> res.sendFile(path, [options], [callback])

이 메서드는 path의 파일을 읽고 그 콘텐츠를 클라이언트에 전송한다. 이메서드를 쓸일은 거의 없다 static 미들웨어를 쓰고 클라이언트에 보낼 파일은  public디렉터리에 넣으면된다.

자바스크립트의 프로토타입 상속 때문에 지금 정확히 뭘 사용하고 있는지 알기 어려울 때가 있다. 노드에서 제공하는 객체를 익스프레스에서 확장하고, 추가한 패키지에서 다시 그 객체를 확장할 수 있다. 따라서 지금 정확히 어떤 기능이 사용 가능한지 알기 어려울 수 있다.

폼 정보는 req.body 에 들어있고 가끔 req.query에 들어있을 때도 있다. req.xhr을 이용해 요청이 ajax요청인지 브라우저 요청인지 판단가능하다.


종단점이라는 용어는 api에서 단 하나의 함수를 가리킬 때 종종 사용

템플릿을 이해하는데 필요한 핵심 개념은 콘텍스트이다. 템플릿을 렌더링할 때는 템플릿엔진에 콘텍스트 객체를 보내고 이 객체를 통해 교체가 일어난다.

서버쪽 템플릿은 HTML을 클라이언트로 보내기 전에 렌더링한다. 클ㄹ라이언트 템플릿을쓰면 html소스를 볼줄아는 사용자는 템플릿까지 볼수 있지만 서버쪽 템플릿은 사용자는 최종 html을 생성하는데 쓰인 템플릿이나 콘텍스트 객체에 대해 전혀 알 수 없다.

서버쪽 템플릿을 쓰면 템플릿 캐싱이 가능한데 이는 성능에 중요한 요소이다.

템플릿 엔진은 컴파일된 템플릿을 캐시하고 템플릿 자체가 바뀌었을 때만 다시 컴파일하고 캐시한다.


템플릿을 많이 사용할수록 관리해야할 html레이아웃이 간결해진다. 



