## 클라이언트 사이드 라우팅

spa는 하나 이상의 화면 상태로 구성된다. 그러나 일반적인 웹 애플리케이션과 달리 URL 단위로 서버에서 HTML 응답을 받아오지 않기 때문에 생각없이 개발하다 보면 URL하나에서 화면이 변화하는 애플리케이션이 된다.

이 경우 브라우저의 이전 버튼이나 북마크를 사용할 수 없게되고 중간 상태를 공유할 수 없기 때문에 사용자가 곤란을 겪는다. 

이 때문에 클라이언트 측에서도 URL마다 화면을 만들어두거나 HTML5의 히스토리 API로 이전 버튼을 사용 할 수 있게끔 해야한다. 이런 것들을 서버 사이드 라우팅과 구분하기 위해 클라이언트 사이드 라우팅이라고 한다.


## 컴포넌트 지향

컴포넌트와 컴포넌트 간의 상호작용 형태로 프로그램을 작성한다.

컴포넌트 개념으 ㄹ도입한 UI프레임워크 중  Bootstrap 이있다. 부트스트랩의 컴포넌트는 html,css 그리고 약간의 자바스크립트로 구성된다.

컴포넌트가 주체가 되어 컴포넌트 사이의 관계로 애플리케이션 전체를 구성하는 것을 컴포넌트 지향이라고한다. 컴포넌트 지향에서는 애플리케이셔느이 기본 정보를 포함하는 페이지를 통째로 하나의 컴포넌트로 정의한다. 이 루트 컴포넌트 안에 다른 컴포넌트를 포함시키는 형태로 컴포넌트 간의 부모관계 및 형제관계를 형성하고 컴포넌트 사이의 상호작용을 정의하여 애플리케이션을 만든다.

컴포넌트 지향 애플리케이션을 구현할 때는 컴포넌트 각각이 단독으로 필요한 기능을 수행할 수 있는 스타일과 스크립트를 포함하는 독립된 존재여야 하는 것이 중요하다. 이런 조건을 관철해내기 위해 외양과 행동을 컴포넌트 내부에 감추어 두는 캡슐화가 필요하게 되었다. 

## SSR과 프리렌더링
SSR은 서버사이드렌더링의 약자이다 SSR을 이해하려면 일반적인 HTTP를 알아야한다. 크롤러 대응에 관련해서두가지 문제가있다. 첫번째는 SEO 문제이다. 즉 페이지가 검색결과에 잘 포함되는지 여부이다. 또한가지 문제는 SNS문제로, 정상적으로 웹페이지가 공유되는지 여부이다. SEO와 관련된 문제는 주로 구글과관련된 것이다. 그러나 구글을 자바스크립트로 렌더링된 페이지도 정상적으로 수집해주므로 SPA콘텐츠도 검색 대상이 된다.

그러나 SNS와 관련된 문제는 쉽게 해결되지 않는다. 대부분의 SNS크롤러는 URL에 접근하여 얻은 응답 결과를 바로 인덱싱하기 때문이다. 다시말해 wget이나 curl같은 명령행 도구로 URL에 접근했을 때나 마찬가지가 도니다. 이런 경우에 별도 대책을 세워놓지 않은 SPA는 자바스크립트가 실행되기 전에 페이지가 수집된다. 첫번째 해결방법은 SSR이다. SSR을 적용하면 서버에서 클라이언트로 전달되는 응답 결과에 이미 렌더링으 ㄹ마친 상태를 전달한다. 이를 구현하려면 어떤 방법으로든 서버에서 SPA에서 만들 렌더링 결과를 완성해야한다.

프리렌더링은 미리렌더링해놓는다는 뜻이다. 서버사이드렌더링과는 달리 서버에 렌더링 로직이 존재하지 않는다. 요청이 들어왔을 때 대상이 크롤러인지 아닌지 판단하여 크롤러인경우 가상 브라우저로 접근하는 방식으로 생성한 다음 저장해둔 렌더링 결과를 제공하는 방식이다. 프리 렌더링을 제공하는 서비스로 prerender을 들 수 있다.


### MVC와 MVP,MVVM

모델 뷰 컨트롤러의약자. 모델이란 데이터와 데이터에 접근하기 위한 기능, 여기에 다양한 로직을 보탠 것을 가리킨다. 쉽게말하면 사용자 인터페이스가 빠진 애플리케이션이라고 할 수 있다.

뷰는 콘텐츠를 어떻게 외부에 출력하는지 정의하는 부분이다. 컨트롤러는 url요청을 받았을 때 필요에 따라 컨트롤러가 모델과 정보를 주고 받은 다음 적절한 뷰를 골라 사용자에게 반환한다.

웹 애플리케이션은 본래 콘텐츠가 HTML에 포함된 채로 사용자에게 응답으로 전달되기 때문에 뷰안에 MV와 같은 구성을 할 필요가없었다. 그러나 SPA에서는 뷰안에서도 Ajax등을 통한 데이터 접근 계층이 추가되거나 필요에 따라 URL을 교체하는 처리 등이 끼어들기 때문에 MV구조가 필요하게 되었다.

MVVM 은 모델 뷰 뷰-모델 로 구성되는 패턴이다. 뷰-모델은 모델과 뷰사이에 위치한다는 점에서 프리젠터와 비슷하지만 그 역할이 뷰와 모델간의 인터페이스대신 양방향 데이터 바인딩을 담당한다는 점이 다르다.

여기서 말하는 양방향은 뷰를 통해 변경하려는 모델의 값이 뷰-모델을 거쳐 변경 내용을 탐지하고 모델에 변경 내용이 반영되기 때문에 붙여진 말이다. 

> FLUX

액션 크리에이터는 액션을 생성하는 함수이다. 액션이란 이벤트 이름과 데이터를 함께 모아 놓은 것이라고 생각하면 된다. 애플리케이션 안에서 일어나는 다양한 사건들이 액션의 형태로 전달된다. 예를 들어 Ajax로 서버에 데이터를 요청하거나 사용자가 버튼을 누르는 행위 등이 이러한 사건에 해당한다. 액션 크리에이터의 역할은 액션을 생성하여 디스패처에 넘겨주는 것이다.

그럼 액션을 넘겨받은 디스패처는 어떤 일을 할까? 디스패처의 역할은 스토어와 함께 설명하는 것이 이해하기 쉽다. 스토어는 애플리케이션의 상태를 나타내는 정보를 말한다. 애플리케이션 페이지 제목, ajax통신으로 받은 정보 사용자를 발생시킨 상호작용에 대한 정보등도 여기에 해당한다.

뷰는 스토어의 상태에 따라 바뀐다. 예를 들어 화면에 로딩마크가 표시되면 스토어에 있는 어떤 프로퍼티의 상태가 로딩중으로 바뀐것을 뷰가 반영하는 것이다.

### PWA

프로그레시브 웹 애플리케이션의 약자. 구글이 주장하였으며 전용 소개 웹사이트도있다. 이름에 프로그레시브라는 말이 붙은 연유는 단계적으로 적용이 가능하며 최신 브라우저에서는 최신 기술을 적용하고 그렇지 못한 환경에서도 콘텐츠를 열람할 수 있도록 하는 프로그레시브 인핸스먼트의 사상을 따르고 있기 때문이다. pwa에서 기술적으로 새로운 기능은 아래 목록과 같다.

- 서비스 워커를 통한 컨텐츠 제어
- 애플리케이션 쉘을 이용한 애플리케이션화
- 웹 노티피케이션과 웹푸시를 이용한 푸시 노티피케이션

서비스 워커는 pwa의 핵심기술로 백그라운드에서 동작하는 스크립트이다. 사용자가 웹애플리케이션을 사용할 때 그 뒷편에서 다양한 처리를 담당한다. pwa의 특징중 하나는 네트워크접속에 의존하지 않는다는 점이다. 네트워크가 오프라인일 때도 서비스 워커가 콘텐츠를 캐싱해 두어서 사용이 가능.

또 재참여 가능이라는 특징도있다. 이 특징은 웹사이트에도 도입가능한 푸시 기능이 브라우저에 탑재되면서 구현가능해진 것인데 여기서도 역시 서비스 워커가 필요하다.

앱 쉘 모델이란 애플리케이션을 구성하는 최소한의 html css js를 로컬에 캐시해둬서 애플리케이션 본체와 그 밖의 부분을 따로 읽어 들일 수 있도록 한 구현기법이다. 여기다 웹 애플리케이션 매니페스트를 추가해주면 브라우저에서 주소바를 제거하거나 홈화면에 단축 아이콘을 추가하는 등 마치 애플리케이션과 같은 외양을 갖도록 할 수 있다.
애플리케이션의 스플래시 화면도 구현이 가능하다.

매니페스트 파일의 이름은 manifiest.manifest이며 이파일에 애플리케이션에 대한 정보를 담은뒤 html에 이 파일의 링크를 추가한다. 이 파일에 json포맷으로 애플리케이션 이름 아이콘 주소바 유무등을 정의할 수 있다. 