# 예외와 예외처리

예외 처리는 에러를 컨트롤하는 메커니즘이다. 에러 처리라고 하지 않고 예외 처리라고 하는 이유는 예상치 못한 상황에 대처하는 방식이기 때문이다.
예상한 에러와 예상치 못한 에러(예외)를 구분하는 기준은 불명확하고 상황에 따라 크게 달라진다. 일반 대중이 사용할 애플리케이션을 설계할 때는 익숙한 사용자를 위한 어플리케이션을 설계할 때보다 예상하지 못한 상황이 훨씬 많이 일어날 것으로 생각해야 한다.
예상 할 수 있는 에러의 예는, 누군가 폼에 잘못된 이메일 주소를 입력하는 경우가있다. 예상치 못한 에러라면 디스크에 남은 공간이 없어진다거나 믿을 만한 서비스가 갑자기 정지된다거나 하는 경우가 있다.

## 11.1 Error 객체

자바스크립트에는 내장된 Error 객체가 있고 이 객체는 에러 처리에 간편하게 이용할 수 있다.
Error 인스턴스를 만들어서 에러 메시지를 지정할 수 있다.

```javascript
const err = new Error("invalid email");
```

에러 인스턴스를 만드는 것만으로는 아무 일도 일어나지 않는다. 이 인스턴스는 에러와 통신하는 수단이다. 이메일 주소의 유효성을 검사하는 함수가 있다고 하자. 이 함수는 검사한 이메일 주소가 올바르면 이메일 주소를 문자열로 반환하고 바르지 않다면 Error 인스턴스를 반환한다.

```javascript
function validateEmail(email) {
    return email.match(/@/) ? email : new Error(`invalid email : ${email})
}
```

이 함수를 사용할 때는 instanceof 연산자를 써서 Error 인스턴스가 반환됐는지확인한다.

```javascript
const email = "jane@doe.com";
const validatedEmail = validateEmail(email);
if (validatedEmail instance of Error) {
    console.error(`Error: ${validatedEmail.message}`)
}else {
    console.log(`Valid email: ${validatedEmail}`)
}
```

이 방법도 Error 인스턴스를 활용하는 유효하고 유용한 방법이긴 하지만 Error 인스턴스는 예외 처리에서 더 자주 사용된다.

## 11.2 try/catch 예외 처리

예외 처리는 try..catch 문을 사용한다. 뭔가를 시도하고, 예외가 있으면 그것을 캐치한다는 뜻이 잘 드러난다. 이전 예제의 validateEmail은 사용자가 이메일 주소에서 @ 를 빼먹은 예상할 수 있는 에러는 처리 할 수 있다. 하지만 예상치 못한 에러가 일어날 가능성은 여전한데, 예를 들어 부주의한 프로그래머가 email에 문자열이 아닌 어떤 것을 할당한다고 하자. 지금대로라면, 이전 예제의 함수는 email에 null, 숫자, 객체등 문자열이 아닌 무언가 들어온다면 에러를 일으킨다. 프로그램은 앞뒤 설명 없이 멈춰버린다. 이러한 예상치 못한 에러에 대처하려면 try...catch 문으로 코드 전체를 감쌀 수 있다.

```javascript
const email = null;
try {
    const validatedEmail = validateEmail(email);
    if (validatedEmail instance of Error) {
    console.error(`Error: ${validatedEmail.message}`)
    }else {
    console.log(`Valid email: ${validatedEmail}`)
    }
}catch(err) {
    console.error(`Error:${err.message})
}
```

에러를 캐치 했으므로 프로그램은 멈추지 않는다. 에러를 기록하고 계속 진행 할 수 있다. 물론 문제가 해결된 것은 아니다. 유효한 이메일 주소가 필수라면 프로그램이 계속 진행할 수 없기는 마찬가지이다. 하지만, 최소한 앞뒤 사정도 모르고 그냥 멈추는 일은 막을 수 있다. 실행 흐름은 에러가 일어나는 즉시 catch 블록으로 이동한다. 즉,validateEmail 을 호출한 다음에 있는 if 문은 실행되지 않는다. try 블록안에 쓸수 있는 문의 숫자에 제한은 없다. 그중 에러가 일어나는 문에서 실행흐름을 catch블록으로 넘긴다. 에러가 일어나지 않으면 catch블록은 실행되지 않는다.

## 11.3 에러 일으키기

직접 에러를 일으킬 수도 있다.
예외 처리 기능이 있는 다른 언어와는 달리, 자바스크립트는 에러를 일으킬 때 꼭 객체만이 아니라 숫자나 문자열 등 어떤 값이든 catch 절에 넘길 수 있다. 하지만 Error 인스턴스를 넘기는 것이 가장 편리하다. 대부분 catch 블록은 Error 인스턴스를 받을 것이라고 간주하고 만든다.
은행 애플리케이션에 사용할 현금 인출 기능을 만든다고 생각해보자. 계좌의 잔고가 요청받은 금액보다 적다면 예외를 일으켜야한다.

```javascript
function billPay(amount, payee, account) {
  if (amount > account.balance) {
    throw new Error("insufficiend funds");
  }
  account.transfer(payee, amount);
}
```

throw를 호출하면 현재 함수는 즉시 실행을 멈춘다. 따라서 위예제는 account.transfer을 호출하지 않으므로 잔고가 부족한데도 현금을 찾아가는 사고는 발생하지 않는다.

## 11.4 예외 처리와 호출 스택

프로그램이 함수를 호출하고 그 함수는 다른 함수를 호출하고, 호출된 함수는 또다른 함수를 호출하는 일이 반복된다. 자바스크립트 인터프리터는 이런 과정을 모두 추적하고 있어야 한다. 함수 a가 함수 b를 호출하고 함수 b는 함수 c를 호출한다면, 함수 c가 실행을 마칠 때 실행 흐름은 함수 b로 돌아간다. 그리고 b가 실행을 마칠때 실행흐름은 함수 a로 돌아간다. 바꿔말해서, c가 실행 중일 때에는 a와 b가 완료될 수는 없다. 이렇게 완료되지 않은 함수가 쌓이는 것을 호출 스택이라고 한다.
만약 c에서 에러가 일어난다면? b는 c가 반환하는 값을 사용해야 할 수도 있으므로 b에서도 에러가 일어난다. 따라서 a에서도 에러가 일어난다. 요약하자면, 에러는 캐치될 때까지 호출 스택을 따라서 올라간다.
에러는 호출 스택어디에서든 캐치할 수 있다. 어디에서 이 에러를 캐치하지 않으면 자바스크립트 인터프리터는 프로그램을 멈춘다. 이런 것을 처리하지 않은 예외, 캐지하지 않은 예외라고 부르며 프로그램이 충돌하는 원인이 된다.에러가 일어날 수 있는 곳은 정말 다양하므로 가능한 에러를 모두 캐치하는 것은 정말 어렵다.
에러를 캐치하면 호출 스택에서 문제 해결에 유용한 정보를 얻을 수 있다. 예를 들어서 함수 a가 함수 b를 호출하고 b가 호출한c에서 에러가 일어났다면, 호출 스택은 c에서 일어난 에러를 보고하는데 그치지 않고 b가 c를 호출했으며 b는 a에서 호출했다는 것도 함께 알려준다.프로그램 여기저기에서 c를 호출 할수 있으므로 이런 정보는 디버그에 유용하다.
대부분의 자바스크립트 환경에서 Error 인스턴스에는 스택을 문자열로 표현한 stack 프로퍼티가 있다. 이 기능은 자바스크립트 표준은 아니지만 대부분의 환경에서 지원한다.
stack 을보면 가장 깊은 함수에서 시작하고 함수가 남지 않았을 때 (브라우저 자체)에서 끝난다.

## 11.5 try..catch..finally

try 블록의 코드가 HTTP연결이나 파일 같은 일종의 자원을 처리할 때가 있다. 프로그램에서 이 자원을 계속 가지고 있을 수는 없으므로 에러가 있든 없든 어느 시점에서는 이 자원을 해제해야한다. try 블록에는 문을 원하는 만큼 쓸 수 있고, 그중 어디서든 에러가 일어나서 자원을 해체할 기회가 아예 사라질 수도 있으므로 try 블록에서 자원을 해제하는것은 안전하지 않다. 에러가 일어나지 않으면 실행되지 않는 catch블록역시 안전하지 않고, 이런 상황에서finally 가 필요하다.

## 11.6 요약

에러를 대비할 때 예상할 수 있는 에러나 예상 할 수 없는 예외 어느 쪽이든 예외 처리를 사용하고 싶을 겁니다. 예외를 일으키는 건 대단히 쉽다.하지만 예외 처리에는 비용이 필요하다. 예외를 캐치하지 못하는 위험도 있고 (프로그램이 정지한다.) 예외 처리 자체도 대가를 지불해야 하는 연산이다. 예외는 catch블록을 만날 때까지 스택을 거슬러 올라가야 하므로 자바스크립트 인터프리터가 예외를 계속 추적하고 있어야 한다. 컴퓨터는 점점 빨라지고 있으니 이런 비용은 큰 문제가 되지 않을 수도 있지만, 자주 실행되는 코드에서 예외를 발생시키면 성능 문제가 발생할 가능성이 있다.
프로그램을 일부러 멈추려고 하는게 아니라면, 예외를 일으켰으면 반드시 캐치해야 한다. 원인 없는 결과는 없는 법이다. 예외 처리는 예상 할 수 없는 상황에 대비한 마지노선으로 생각하고, 예상할 수 있는 에러는 조건문으로 처리하는 것이 최선이다.
