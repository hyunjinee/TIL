# 비동기적 프로그래밍

사용자의 행동은 전적으로 비동기적이다. 사용자가 언제 클릭할지, 터치할지, 타이핑할지 당신은 전혀 알수 없다. 하지만 비동기적 실행이 사용자 입력 하나 때문에 필요한 것은 아니다. 사실 자바스크립트의 본성 때문에 비동기적 프로그래밍이 필요하다.
자바스크립트 어플리케이션은 단일 스레드에서 동작한다. 즉 자바스크립트는 한번에 한 가지 일만 할 수 있다. 멀티 코어를 장착한 대부분의 최신 컴퓨터는 한번에 여러가지 일을 할 수 있고, 싱글코어 컴퓨터도 매우 빨라서 작업 A를 잠시 하고, 작업 B를 잠시하고, 작업C를 잠시하는 식으로 멀티태스킹을 흉내 낼 수 있다. 사용자가 보기에는 세가지 작업이 동시에 일어나는 것처럼 보인다. 실제로 멀티코어에서 동시에 수행하지 않더라도 말이다.
자바스크립트가 싱글 스레드라는 얘기를 듣고 할 수 있는 일이 제한된다고 느낄지도 모르지만, 사실 멀티스레드 프로그래밍에서 겪어야 하는 정말 골치아픈 문제를 신경 쓰지 않아도 된다는 장점도 있다. 물론 대가가 있다. 부드럽게 동작하는 소프트웨어를 만들기 위해서는 사용자의 입력 뿐만아니라, 여러 문제를 비동기적 관점에서 생각해야 한다. 비동기적 관점에서 생각하는건 처음에는 어려울 수 있다. 특히, 일반적으로 동기적 실행을 하는 언어를 사용 했었다면 더 어렵게 느껴질 수 있다.
자바스크립트에는 매우 일찍부터 비동기적 실행 메커니즘이 존재했지만, 자바스크립트의 인기가 높아지고 , 자바스크립트로 만드는 소프트웨어가 점점 복잡해짐에 따라 비동기적 프로그래밍에 대한 장치들이 추가되었다. 자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 세가지 패러다임이 있다. 처음에는 콜백이 있었고, 프라미스가 뒤를 이었으며 마지막은 제너레이터이다. 제너레이터 자체는 비동기적 프로그래밍을 전혀 지원하지 않는다. 제너레이터를 비동기적으로 사용하려면 프라미스나 특수한 콜백과 함께 사용해야 한다. 프라미스 역시 콜백에 의존한다. 콜백은 제너레이터나 프라미스 외에도 이벤트 처리 등에 유용하게 쓸 수 있다. 사용자 입력 외에 비동기적 테크닉을 사용해야 하는 경우는 크게 세가지아 있다.

- Ajax호출을 비롯한 네트워크 요청
- 파일을 읽고 쓰는 등의 파일 시스템 작업
- 의도적으로 시간 지연을 사용하는 기능(알람등)

## 14.2 콜백

콜백은 자바스크립트에서 가장 오래된 비동기적 메커니즘이다. 우리는 사용자 입력과 타임아웃을 처리하면서 이미 콜백을 사용했다. 콜백은 간단히 말해서 나중에 호출할 함수이다. 콜백함수는 다른 함수에 넘기거나 객체의 프로퍼티로 사용한다. 콜백은 보통 익명함수로 사용한다.

### 14.2.2 스코프와 비동기적 실행

비동기적 실행에서 혼란스럽고 에러도 자주 일어나는 부분은 스코프와 클로저가 비동기적 실행에 영향을 미치는 부분이다. 함수를 호출하면 항상 클로저가 만들어진다. 매개변수를 포함해 함수안에서 만든 변수는 모두 무언가가 자신에 접근 할 수 있는 한 계속 존재한다.

```javascript
function countdown() {
  let i;
  console.log("Countdown");
  for (i = 5; i >= 0; i--) {
    setTimeout(function () {
      console.log(i === 0 ? "GO!" : i);
    }, (5 - i) * 1000);
  }
}
```

let 을 사용하긴 했지만 변수를 for 루프 밖에서 선언했으므로 for 루프가 실행을 마치고 i 값이 -1이 된후에야 콜백이 실행된다.
countdown을 호출하면 변수i 가 들어있는 클로저가 만들어진다. for 루프 안에서 만드는 콜백은 모두 i 에 접근 할 수 있고, 그들이 접근하는 i 는 똑같은 i이다.
setTimeout을 호출하는 것은 동기적이다. 동기적으로 호출해야만 콜백을 언제 호출할지 계산할 수 있다. 비동기적인 부분은 콜백함수이고 문제는 여기서부터 복잡해진다.
i 를 for 루프 선언부에서 선언하면 해결할 수 있는데, 여기서 주의할 부분은 콜백이 어느 스코프에서 선언되었느냐 이다. 콜백은 자신을 선언한 스코프(클로저)에 있는 것에 접근할 수 있다. 따라서 i값은 콜백이 실제 실행되는 순간마다 다를수 있다. 이 원칙은 콜백뿐아니라 모든 비동기적 테크닉에 적용된다.

### 14.2.3 오류 우선 콜백

노드가 점점 인기를 얻어가던 시기에 오류우선 콜백이라는 패턴이 생겼다. 콜백을 사용하면 예외 처리가 어려워지므로, 콜백과 관련된 에러를 처리할 방법의 표준이 필요했다. 이에 따라 나타난 콜백의 첫번째 매개변수에 에러 객체를 쓰자는 것이었다. 에러가null이나 undefined이면 에러가 없는 것이다.
콜백에서 가장 먼저 하는 일은 err가 참같은 값인지 확인하는 것이다. err가 참같은 값이라면 어떤 일을 하는데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나온다. 오류 우선 콜백을 사용할 때 가장 많이 벌어지는 실수는 이것이다. 에러 객체를 체크해야 한다는 사실을 기억하고 , 로그를 남기기도 하겠지만, 빠져나와야 한다는 사실을 잊는 사람이 많다. 콜백을 사용하는 함수는 대개 콜백이 성공적이라고 가정하고 만들어진다. 그런데 콜백이 실패했으니, 빠져나가지 않으면 오류를 예약하는 것이나 다름없다. 물론, 콜백을 만들때 실패하는 경우도 염두해 두고 만들었다면 에러를 기록하기만하고 계속 진행해도 된다.
프라미스를 사용하지 않는다면 오류 우선 콜백은 노드 개발의 표준이나 다름없다. 콜백을 사용하는 인터페이스를 만들 때는 오류 우선 콜백을 사용하길 강력히 권한다.

## 14.3 프라미스

프라미스는 콜백의 단점을 해결하려는 시도 속에서 만들어졌다. 프라미스는 간혹 번거롭게 느껴질 수 있지만, 일반적으로 안전하고 관리하기 쉬운 코드를 만들 수 있게 된다.
프라미스가 콜백을 대체하는 것은 아니다. 사실 프라미스에서도 콜백을 사용한다. 프라미스는 콜백을 예측 가능한 패턴으로 사용할 수 있게하며, 프라미스 없이 콜백만 사용했을 때 나타날 수 있는 엉뚱한 현상이나 찾기 힘든 버그를 상당수 해결한다.
프라미스 기반 비동기적 함수를 호출하면 그 함수는 Promise 인스턴스를 반환한다. 프라미스는 성공하거나 실패하거나 단 두가지 뿐이다. 프라미스 성공한 프라미스가 나중에 실패하는 일 같은건 없다. 또한 성공이든 실패든 단 한번만 일어난다. 프라미스가 성공하거나 실패하면 그 프라미스를 결정됐다고 한다.
프라미스는 객체이므로 어디든 전달할수있다는 점도 콜백에 비해 간편한 장점이다. 비동기적 처리를 여기서 하지 않고 다른 함수에서 처리하게 하고 싶다면 프로미스를 넘기기만 하면된다. 마치 음식점에서 받은 예약 호출기를 친구에게 맡기는 것과 비슷하다. 예약한 인원이 때맞춰 오기만 한다면 음식점에서는 누가 호출기를 들고 있든 상관없다.
