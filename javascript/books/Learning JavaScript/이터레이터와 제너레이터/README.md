# 이터레이터와 제너레이터

ES6에서는 매우 중요한 개념인 이터레이터와 제너레이더, 제너레이터는 이터레이터에 의존하는 개념이므로 이터레이터부터 알아보자.

이터레이터는 '지금 어디 있는지' 파악할 수 있도록 돕는다는 면에서 일종의 책갈피와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러페이지가 있는 것처럼 배열에는 여러 요소가 들어있으므로, 책에 책갈피를 끼울 수 있듯 배열에는 이터레이터를 사용 할 수 있다. 책과 책갈피의 비유를 계속 사용해보자. book이란 배열이 있고, 이 배열의 각 요소는 책의 한페이지를 나타내는 문자열 이라고 하자. 한페이지에 문장 하니씩 들어있는 어린이용 동화책이다.

```javascript
const book = [
  "Twinkle, twinke, little bat!",
  "How I wonder what you're at!",
  "Up above the world you fly",
  "Like a tea tray in the sky",
];
```

이제 book배열에 values 메서드를 써서 이터레이터를 만들수 있다.

```javascript
const it = book.values();
```

이터레이터(보통 it 이라고 줄인다.) 는 책갈피지만, 이책에만 사용할 수 있다. 그리고 아직은 책갈피를 꽂을 수 없다. 읽지 않았기 때문이다. 읽기 시작하려면 이터레이터의 next 메서드를 호출한다. 이 메서드가 만환하는 객체에는 value 프로퍼티와 done 프로퍼티 가있다.

```javascript
it.next(); // {value: "Twinkle, twinkle, little bat! , done:false}
// 쭉 진행해서
it.next(); // {value: "Like a tea tray in the sky", done: false }
it.next(); // {value: undefined, done:true}
```

책의 마지막 페이지를 읽으면 다 읽은 거지만, 이터레이터는 마지막 페이지를 반환했다해서 끝난게 아니고 한번더 해야 끝이다.
더 진행할 것이 없으면 value 는 undefined 가 되고 next는 계속 호출 할 수 있다. 물론 그렇다고 결과가 바뀌는 것은 아니다. 일단 이터레이터가 끝까지 진행하면 뒤로 돌아가서 다른 데이터를 제공 할 수 없다.
it.next()를 호출하는 중간에 다른 일도 가능하다.
이 배열의 요소를 나열하는 것이 목적이라면 for 루프나 for of 루프를 쓸 수 있다.
for of 루프는 이터레이터를 사용해서 루프를 실행한다. 이터레이터만 제공 할 수 있다면 무엇이든 for ..of 루프와 함께 쓸 수 있다.

```javascript
const it = book.values();
let current = it.next();
while (!current.done) {
  console.log(current.value);
  current = it.next();
}
```

이터레이터는 모두 독립적이다. 즉, 새 이터레이터를 만들 때마다 처음부터 시작한다. 그리고 각각 다른 요소를 가르키는 이터레이터 여러개를 동시에 사용할 수 있다.
객체마다 이터레이션 메커니즘을 따로 정할수 있으므로 역행하는 이터레이터를 만드는 것도 가능하긴하다. 하지만 특별한 경우가 아니라면 권장하지 않는다.

## 12.1 이터레이션 프로토콜

이터레이터는 그 자체로 쓸모가 있다기보다는, 더 쓸모있는 동작이 가능해지도록 한다는 의미가 있다. 이터레이터 프로토콜은 모든 객체를 이터러블 객체로 바꿀수 있다.
이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator 가 있고 이 메서드가 이터레이터처럼 동작하는 객체, 즉 value 와 done 프로퍼티가 있는 객체를 반환하는 next 메서드를 가진 객체를 반환한다면 그 클래스의 인스턴스는 이터러블 객체라는 뜻이다.

## 12.2 제너레이터

제너레이터란 이터레이터를 사용해 자신의 실행을 제어하는 함수이다. 일반적인 함수는 매개변수를 받고 값을 반환하지만, 호출자는 매개변수 외에는 함수의 실행을 제어할 방법이 없다. 함수를 호출하면 그 함수가 종료될 때까지 제어권을 완전히 넘기게 된다.하지만 제너레이터에서는 그렇지 않다.
제너레이터는 두가지 새로운 개념을 도입한다. 하나는 함수의 실행을 개별적 단계로 나눔으로써 함수의 실행을 제어한다는 것이다. 다른 하나는 실행중인 함수와 통신한다는 것이다.

- 제너레이터는 언제든 호출자에게 제어권을 넘길 수 있다(yield)
- 제너레이터는 호출한 즉시 실행되지는 않는다. 대신 이터레이터를 바노한하고 이터레이터의 next메서드를 호출함에 따라 실행된다.
  제너레이터를 만들 때는 function 키워드 뒤에 애스터리스크(\*)를 붙인다. 이것을 제외하면 문법은 일반적인 함수와 같다. 제너레이터에서는 return 외에 yield 키워드를 쓸 수 있다. 제너레이터를 호출하면 이터레이터를 얻는다.

### 12.2.1 yield 표현식과 양방향 통신

제너레이터와 호출자 사이에는 양방향 통신이 가능하다. 통신은 yield 표현식을 통해서 이루어진다. 표현식은 값으로 평가되고 yield는 표현식이므로 반드시 어떤 값으로 평가된다. yield 표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수이다.
대화를 이어가는 제너레이터를 만들어보자.

```javascript
function* interrogate() {
  const name = yield "what is your name?";
  const color = yield "What is your favorite color?";
  return `${name}'s favorite color is ${color}`;
}
```

이 제너레이터를 호출하면 이터레이터를 얻는다. 그리고 제너레이터의 어떤 부분도 아직 실행하지 않은 상태이다. next를 호출하면 제너레이터는 첫 번째 행을 실행하려고 한다. 하지만 그 행에는 yield 표현식이 들어있으므로 제너레이터는 반드시 제어권을 호출자에게 넘겨야 한다. 제너레이터의 첫번쨰 행이 완료되려면 호출자가 next를 호출해야 한다. 그러면 name은 next에서 전달하는 값을 받는다. 다음은 제너레이터를 끝까지 실행한후의 모습이다.

```javascript
const it = interrogate();
it.next(); // {value: "What is your name?", done:false}
it.next("Ethan"); // {value: "What is your favorite color?",done:false}
it.next("orange"); // {value: "Ethan's favorite color is oragne.", done:true}
```

1. 제너레이터는 이터레이터를 반환하고 일시 정지한 상태로 시작한다.
2. undefined 를 제너레이터에 넘긴다.(이값은 사용되지 않는다.) 제너레이터는 "What is your name?" 을 넘기고(yield) 일시정지한다.
3. "Ethan"을 제너레이터에 넘긴다. 제너레이터는 "What is your favorite color?" 를 넘기고 일시정지한다.
4. "orange"를 제너레이터에 넘긴다. 제너레이터는 풀 문장을 반환하고 멈춘다.

이 예제를 보면 제너레이터를 활용하면 호출자가 함수의 실행을 제어 할 수 있어서 아주 유용하게 쓸 수 있다는 것을 알 수 있다. 호출자가 제너레이터에 정보를 전달하므로, 제너레이터는 그 정보에 따라 자신의 동작 자체를 바꿀 수 있다. 추가로 제너레이터는 화살표기법으로 만들수 없으며, 반드시 function\* 를 사용해서 만들어야한다.

### 12.2.2 제너레이터와 return

yield문은 설령 제너레이터의 마지막 문이더라도 제너레이터를 끝내지 않는다. 제너레이터에서 return 문을 사용하면 그 위치와 관계없이 done 은 true 가 되고, value 프로퍼티는 return 이 반환하는 값이 된다.
제너레이터에서 중요한 값을 return 으로 반환하려 하면안된다. 제너레이터가 반환하는 값을 사용하려 할때는 yield를 써야하고 return 은 제너레이터를 중간에 종료하는 목적으로만 사용해야 한다. 따라서 제너레이터에 return 을 쓸 때는 반환값을 쓰지 않는 습관을 들여야한다.

## 12.3 요약

이터레이터는 배열이나 객체처럼 여러가지 값을 제공할 수 있는 컬렉션의 동작 방식을 표준화했다. 이터레이터로 할 수 있는 일은 ES6이전에도 모두 할 수 있었으므로, 어떤 기능이 추가된 것은 아니다. 중요하면서도 자주 사용하는 패턴을 표준화 했다는데 의미가 있다.
제너레이터를 사용하면 함수를 훨씬 더 유연하고 효율적으로 사용할 수 있다. 이제 함수를 호출하는 부분에서 데이터를 제공하고, 함수가 완료되길 기다렸다가 반환값을 받는다는 사고방식에 얽매일 필요가 없다. 제너레이터는 모든 연산을 지연시켰다가 필요할 때만 수행하게 만들 수 있다. 이건 기능 진짜 좋은듯!!
