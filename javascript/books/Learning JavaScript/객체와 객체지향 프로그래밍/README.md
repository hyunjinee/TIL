# 객체와 객체지향 프로그래밍

배열과 마찬가지로 자바스크립트 객체 역시 컨테이너이지만, 크게 다음 두 측면에서 배열과 다르다.

- 배열은 값을 가지며 각 값에는 숫자형 인덱스가 있다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있다.
- 배열에는 순서가 있다. 즉 arr[0]은 arr[1]보다 앞에 있다. 반면 객체에는 그런 순서가 보장되지 않는다.obj.a가 obj.b보다 앞에 있다고 말할 수 없다.

프로퍼티는 키(문자열 또는 심볼)과 값으로 구성된다. 객체의 진짜 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점이다.

## 9.1 프로퍼티 나열

프로퍼티 나열에서 기억해야 할 것은 순서가 보장되지 않는다는 점이다. 여러 번 테스트를 해 봤는데도 프로퍼티가 입력한 순서대로 나열될 수도 있다. 하지만 자바스크립트가 그런 순서를 명시적으로 보장하는 것도 아니고, 브라우저나 노드 등의 프로그램에서 속도나 효율 향상을 목적으로 언제든 바꿀 수도 있다. 따라서 입증 할 수 없는 테스트를 근거로 확실하다는 착각에 빠지면 안된다. 객체 프로퍼티에는 순서가 없다.

### 9.1.1 for in

for in 루프에는 키가 심볼인 프로퍼티는 포함되지 않는다.

### 9.1.2 Object.keys

Object.keys 는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환한다.

## 9.2 객체지향 프로그래밍

객체지향 프로그래밍은 컴퓨터 과학에서 전통적인 패러다임이다. OOP의 기본 아이디어는 단순하고 직관적이다. 객체는 데이터와 기능을 논리적으로 묶어 놓은 것이다. OOP는 우리가 사물을 이해하는 자연스러운 방식을 반영하도록 설계되었다.
클래스는 어떤 자동차처럼 추상적이고 범용적인것이다. 인스턴스는 특정 자동차처럼 구체적이고 한정적인 것이다. 기능을 메서드라고 부른다. 클래스에 속하지만 특정 인스턴스에 묶이지는 않는 기능을 클래스 메서드라고 한다. 예를 들어 시동을 거는 기능은 클래스 메서드라고 할 수 있다. 인스턴스를 처음 만들때는 생성자가 실행된다. 생성자는 객체 인스턴스를 초기화 한다.

### 9.2.2 클래스는 함수다

ES6에서 class 키워드를 도입하기 전까지, 클래스를 만든다는 것은 곧 클래스 생성자로 사용할 함수를 만든다는 의미였다. class 문법이 훨씬 더 직관적이고 단순하긴 하지만, 사실 class는 단축 문법일 뿐이며 자바스크립트의 클래스 자체가 바뀐 것은 아니다.
클래스는 함수일 뿐이다.

```javascript
function Car(make, model) {
  this.make = make;
  this.model = model;
  this._userGears = ["P", "N", "R", "D"];
}
```

위 코드는 ES5 문법이다.

### 9.2.3 prototype

클래스의 인스턴스에서 사용할 수 있는 메서드라고 하면 그건 프로토타입메서드를 말한다. Car.prototype.shift 처럼 표기할 때가 많다. 그렇다면 프로토타입은 무엇인지, 자바스크립트가 프로토타입 체인을 통해 어떻게 동적 디스패치를 구현하는지 알아보자.
모든 함수에는 prototype이라는 특별한 프로퍼티가 있다. 일반적인 함수에서는 프로토타입을 사용할 일이 없지만, 객체 생성자로 동작하는 함수에서는 프로토타입이 대단히 중요하다.함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때이다. new 키워드로 만든 새 객체는 생성자의 prototype 프로퍼티에 접근할 수 있다. 객체 인스턴스는 생성자의 prototype 프로퍼티를 \_\_proto\_\_ 프로퍼티에 저장한다.
프로토타입에서 중요한 것은 동적 디스패치라는 메커니즘이다. 여기서 디스패치는 메서드 호출과 같은 의미이다.객체의 프로퍼티나 메서드에 접근하려고 할때, 그런 프로퍼티나 메서드가 존재하지 않으면 자바스크립트는 객체의 프로토타입에서 해당 프로퍼티나 메서드를 찾는다. 클래스의 인스턴스는 모두 같은 프로토타입을 공유하므로 프로토타입에 프로퍼티나 메서드가 있으면 해당 클래스의 인스턴스는 모두 그 프로퍼티나 메서드에 접근할 수 있다.
인스턴스에서 메서드나 프로퍼티를 정의하면 프로토타입에 있는 것을 가리는 효과가 있다. 자바스크립트는 가장먼저 인스턴스를 체크하고 거기에 없으면 프로토타입을 체크하기 때문이다. 예로, 만약 인스턴스에 어떤 메서드가 없다면, 생성자가 생성해주지않았고, 자신이 가지고 있을 수 있다. 따라서 인스턴스는 자기자신을 체크하고 자기를 만든 클래스로가서 체크를 한번 더 한후 만약 존재하면 그 메서드를 실행한다. 이때 만약 인스턴스에 같은 이름의 메서드를 생성하버린다고 생각해보자 그렇다면 프로토타입과 자신에 같은이름의 메서드가 존재한다. 이제 인스턴스는 자기 자신의 메서드를 사용하고, 프로토타입의 메서드는 호출하지 않는다.

### 9.2.4 정적 메서드

메서드에는 인스턴스 메서드 외에도 정적 메서드(클래스 메서드)가 있다. 이 메서드는 특정 인스턴스에 적용되지 않는다. 정적 메서드에서 this는 인스턴스가 아니라 클래스 자체에 묶인다. 하지만 일반적으로 정적 메서드에는 this 대신 클래스 이름을 사용하는 것이 좋은 습관이다.
정적 메서드는 클래스에 관련되지만 인스턴스와는 관련이 없는 범용적인 작업에 사용된다. 예제로 자동차 식별 번호 (VIN)을 붙이는 메서드를 생각해보자. 개별 자동차가 자신만의 VIN을 생성한다는 것은 불가능하다. 다른 자동차에 같은 VIN이 이미 부여됐는지 자동차는 모른다. VIN을 할당한다는 것은 자동차 전체를 대상으로 하는 추상적인 개념이므로 정적 메서드로 사용하는게 어울린다. 정적 메서드는 여러 인스턴스를 대상으로 하는 작업에도 종종 쓰인다. 예를 들어서 두자동차의 제조사와 모델이 모두 같으면 true를 반환하는 areSimilar 메서드 , 두 자동차의 VIN이 같으면 true 를 반환하는 areSame 메서드 를 예로 들 수 있다.

```javascript
class Car {
  static getNextVin() {
    return Car.nextVin++;
    //this.nextVin++ 라고 써도 되지만, Car를 앞에 쓰면 정적 메서드라는 점을 상기하기 쉽다.
  }
  constructor(make, model) {
    this.model = model;
    this.make = make;
    this.vin = Car.getNextVin();
  }
  static areSimilar(car1, car2) {
    return car1.make === car2.make && car1.model === car2.model;
  }
  static areSame(car1, car2) {
    return car1.vin === car2.vin;
  }
}
Car.nextVin = 0;
const car1 = new Car("Tesla", "S");
const car2 = new Car("Mazda", "3");
const car3 = new Car("Mazda", "3");
car1.vin; //0
car2.vin; //1
car3.vin; //2
Car.areSimilar(car1, car2); //false
Car.areSimilar(car1, car3); //true
Car.areSame(car2, car3); // false
Car.areSame(car2, car2); //true
```

### 9.2.5 상속

클래스의 인스턴스는 클래스의 기능을 모두 상속한다. 상속은 한단계로 끝나지 않는다. 객체의 프로토타입에서 메서드를 찾지 못하면 자바스크립트는 프로토 타입의 프로토타입 메서드를 검색한다. 프로토타입 체인은 이런식으로 만들어진다. 자바스크립트는 조건에 맞는 프로토타입을 찾을 때까지 프로토타입 체인을 계속 거슬러 올라간다. 조건에 맞는 프로토타입을 찾지 못하면 에러를 발생시킨다. 클래스의 계층 구조를 만들때 프로토 타입 체인을 염두해 두면 효율적인 구조를 만들 수 있다. 즉, 프로토타입 체인에서 가장 적절한 위치에 메서드를 정의하는 것이다.
상속에서 super()은 슈퍼클래스의 생성자를 호출하는 특별한 함수이다. 서브클래스에서는 이 함수를 반드시 호출해야 한다. 호출하지 않으면 에러가 발생한다.

### 9.2.6 다형성

polymorphism 이란 단어는 객체지향언어에서 여러 슈퍼클래스의 멤버인 인스턴스를 가르키는 말이다. 대부분의 객체지향 언어에서 다형성은 특별한 경우에 속한다. js는 느슨한 타입을 사용하고 어디서든 객체를 쓸 수 있으므로(정확한 결과가 보장되진 않지만), 어떤 면에서는 자바스크립트의 객체는 모두 다형성을 갖고 있다고 할 수 있다.
자바스크립트에는 객체가 클래스의 인스턴스인지 확인하는 instanceof 연산자가 있다.
자바스크립트 모든 객체는 루트 클래스인 Object의 인스턴스이다. 즉 객체 o 에서 o instaceof Object 는 항상 참이다. (언더바언더바프로토로 프로퍼티를 수정한다면 다른 결과가 나올 수 있지만 그렇게 하면 안된다.)모든 객체가 Object의 인스턴스인 것은 toString 같은 중요한 메서드를 상속하기 위해서이다.

### 9.2.7 객체 프로퍼티 나열

for in 문으로 객체의 프로퍼티를 나열 할 수 있다.
객체 obj 와 프로퍼티 x 에서, obj.hasOwnProperty(x)는 obj에 프로퍼티 x 가 있다면 true 를 반환하며, 프로퍼티 x 가 obj에 정의되지 않았거나 프로토타입 체인에만 정의되어 있으면 false를 반환한다.
ES6 클래스를 설계 의도대로 사용한다면 데이터 프로퍼티는 항상 프로토타입 체인이 아니라 인스턴스에 정의해야한다. 하지만 프로퍼티를 프로토타입에 정의하지 못하도록 강제하는 장치는 없으므로 확실히 확인하려면 항상 hasOwnProperty 를 사용한다.
Object.keys 를 사용하면 프로토타입 체인에 정의된 프로퍼티를 나열하는 문제를 피할 수 있다.
for in 은 프로토타입체인에 정의된 프로퍼티를 모두 가져온다. 하지만 Object.keys 는 for in 과는 다르게 자기 본연의 (프로토타입체인 프로퍼티를 제외하고) 프로퍼티를 가져온다는 점에서 for in 과 다르다.
이점은 매우중요한거같다.(현진피셜)

### 9.2.8 문자열 표현

모든 객체는 Object 를 상속하므로 Object의 메서든느 기본적으로 모든 객체에서 사용할 수 있다. 객체의 기본적인 문자열 표현을 제공하는 toString 도 그런 메서드 중 하나이다. toString 의 기본 동작은 "[object Object]"를 반환하는 것인데, 이건 거의 쓸모가 없다. toString 메서드에서 객체에 관한 중요한 정보를 제공한다면 디버깅에도 유용하고, 객체를 한눈에 파악할 수 있다.

## 9.3 다중 상속, 믹스인, 인터페이스

일부 객체지향 언어에서는 다중 상속이란 기능을 지원한다. 이 기능은 클래스가 슈퍼클래스를 두개를 가지는 기능이며, 슈퍼클래스의 슈퍼클래스가 존재하는 일반적인 상속과는 다르다. 다중 상속에는 충돌의 위험이 존재한다.
다중 상속을 지원하지 않는 언어 중에는 인터페이스 개념을 도입헤서 이런 상황에 대처하는 언어가 많다.
js 는 흥미로운 방식으로 이들을 절충한다. 자바스크립트는 프로토타입 체인에서 여러 부모를 검색하지는 않으므로 단일 상속 언어라고 해야하지만, 어떤 면에서는 다중 상속이나 인터페이스보다 더 나은 방법을 제공한다.(물론 더못할때도 존재)
js가 다중 상속이 필요한 문제에 대한 해답으로 내놓은 개념은 믹스인이다. 믹스인이란 가능을 필요한 만큼 섞어 놓은 것이다. 자바스크립트는 느슨한 타입을 사용하고 대단히 관대한 언어이므로 그 어떤 기능이라도 언제든, 어떤 객체에 추가할 수 있다.
