# 함수와 추상적 사고

## 13.1 서브 루틴으로서의 함수

서브루틴은 아주오래된 개념이며 복잡한 코드를 간단하게 만드는 기초적인 수단이다. 서브루틴이 없었다면 프로그래밍은 아주 지루한 반복의 연속이었을 것이다. 서브루틴은 반복되는 작업의 일부를 떼어내서 이름을 붙이고, 언제든 그 이름을 부르기만 하면 실행한다.
함수의 이름을 정하는 것은 아주 중요한 일이다. 함수의 이름은 자바스크립트를 위한 것이아니다. 자바스크립트는 당신이 함수 이름에 한글자든 천글자를
쓰던 상관하지 않는다. 함수의 이름은 다른사람, 또는 나중에 이 코드를 다시 볼 당신을 위해 정하는 것이다. 함수의 이름을 정할때는 다른사람이 함수 이름만 봐도 함수에 대해 이해할 수 있도록 주의 깊게 생각해야한다.
함수가 상황에 따라 다른 값을 반환하거나 부작용이 있다면 그 함수는 컨텍스트에 좌우되는 함수이다. 어떤 함수가 정말 유용하더라도 부수효과가 있다면, 그리고 그 함수가 쓰이던 프로그램이 아닌 프로그램에서 사용하려 한다면 문제를 일으킬 수 있다.

### 13.4.1 함수도 객체다

자바스크립트 함수는 Function 객체의 인스턴스이다. 현실적으로 이 사실은 함수를 사용하는데 아무 영향이 없다. typeof v 라 하고 v가 함수일때 "function" 이 반환된다.

## 13.5 IIFE와 비동기적 코드

다음은 카운트 다운 함수이다.

```javascript
var i;
for (i = 5; i >= 0; i--) {
  setTimeout(function () {
    console.log(i === 0 ? "go!" : i);
  }, (5 - i) * 1000);
}
```

여기서 let 대신 var 를 쓴 이유는 IIFE가 중요하던 시점으로 돌아가서 왜 중요했는지 이해하기 위해서이다. 위함수는 -1이 6번 출력된다. setTimeout에 전달된 함수가 루프안에서 실행되지 않고 루프가 종료된 뒤에 실행되기 때문이다.i가 -1이 되기 전에 콜백함수는 전혀 호출되지 않는다. 따라서 콜백 함수가 호출되는 시점에서의 i 값은 -1이다.
let 을 사용해서 블록 수준 스코프를 만들면 이 문제는 해결된다.
블록 스코프 변수가 도입되기 전에는 이런 문제를 해결하기 위해 함수를 하나 더 썼다. 함수를 하나 더 쓰면 스코프가 새로 만들어지고 각 단계에서 i의 값이 클로저에 캡처된다.

```javascript
function loopBody(i) {
  setTimeout(function () {
    console.log(i === 0 ? "go" : i);
  }, (5 - i) * 1000);
}
var i;
for (i = 5; i >= 0; i--) {
  loopBody(i);
}
```

루프의 각 단계에서 loopBody 함수가 호출된다. 자바스크립트는 매개변수를 값으로 넘긴다. 따라서 루프의 각 단꼐에서 함수에 전달되는 것은 변수i 가 아닌, i 의 값이다.
중요한 것은 스코프 일곱개가 만들어졌고, 변수도 일곱개가 만들어졌다는 것이다.(하나는 외부스코프, 나머지 여섯개는 loopBody를 호출 할 때 마다.)
하지만 루프에 한번 쓰고 말 함수에 일일이 이름을 붙이는건 성가신 일이다.
익명함수를 만들어 즉시호출하는 IIFE를 사용하는게 낫다.

```javascript
var i;
for (i = 5; i >= 0; i--) {
  (function (i) {
    setTimeout(function () {
      console.log(i === 0 ? "go" : i);
    }, (5 - i) * 1000);
  })(i);
}
```

블록 스코프 변수를 사용하면 스코프 하나 때문에 함수를 새로 만드는 번거로운 일을 하지 않아도 된다. 블록스코프 변수를 사용해보자

```javascript
for (let i = 5; i >= 0; i--) {
  setTimeout(function () {
    console.log(i === 0 ? "go!" : i);
  }, (5 - i) * 1000);
}
```

let 키워드를 for 루프 바깥에 썼다면, 똑같은 문제가 발생 했을 것이다. let 키워드를 이런 식으로 사용하면 자바스크립트는 루프의 단계마다 변수 i의 복사본을 새로 만든다. 따라서setTimeout에 전달한 함수가 실행될 때는 독립스코프에서 변수를 받는다.

## 변수로서의 함수

- 함수를 가리키는 변수를 만들어 별명을 정할 수 있다.
- 배열에 함수를 넣을 수 있다. 물론 다른 타입의 데이터와 섞일 수 있다.
- 함수를 객체의 프로퍼티로 사용할 수 있다.
- 함수를 함수에 전달할 수 있다.
- 함수가 함술르 반환할 수 있다.
- 함수를 매개변수로 받는 함수를 반환하는 것도 물론 가능하다.

### 13.6.2 함수에 함수를 전달

함수에 함수를 전달하는 용도는 비동기적 프로그래밍이다. 이런 용도로 전달하는 함수를 보통 콜백이라고 부른다. 콜백 함수는 자신을 감싼 함수가 실행을 마쳤을 때 호출된다.
함수에 함수를 전달하는 대표적인 사례가 콜백이긴하나 그게 전부는 아니다. 함수는 동작이고, 함수를 받는 함수는 그 동작을 활용 할 수 있다. 배열에 들어있는 숫자를 모두 더하는 단순한 sum 함수가 필요하다고 하자. 만약 제곱을 반환하는 함수가 필요하다면, 새함수를 만들어도 된다. 하지만, 세제곱을 반환하는 함수도 필요하다면?
임의의 함수를 sum에 전달하면 원하는 일으 ㄹ모두 할 수 있다.
