# 타입

자바스크립트 같은 동적 타입 언어는 타입 개념이 없다고 생각하는 개발자가 많다. ECMA표준 명세서를 보자.

- 이 명서에 수록된 알고리즘에서 사용되는 모든 값은 이 절에서 정의한 타입 목록중 하나에 해당한다. 타입은 ECMAScript언어 타입과 명세 타입으로 하위 분류된다.
- ECMAScript 개발자가 ECMAScript 언어를 이용하여 직접 조작하는 값들의 타입이 바로 ECMAScript 언어 타입이다. undefined, null, boolean,string,number,object가 있다.

엄격 타입형 언어의 광팬들은 타입이란 말의 이러한 용도를 반대할지도 모른다. 그런 언어에서 타입이란 말은 자바스크립트의 타입보다 훨씬 더 많은 의미를 내포하고 있기 때문이다. 
명세의 대략적인 정의를 따르자면 타입이란 자바스크립트 엔진 개발자 모두에게 어떤 값을 다른값과 분별할 수 있는 고유한 내부 특성의 집합이다.

타입별로 내재된 특성을 제대로 알고 있어야 값을 다른 타입으로 변환하는 방법을 정확히 이해할 수 있다. 어떤 형태로든 거의 모든 자바스크립트 프로그램에서 강제변환이 일어나므로 타입을 확실하게 인지하고 사용하는 것이 중요하다.

## 1.2 내장 타입 

자바스크립트에는 다음 7가지 내장 타입이 있다.

- null
- undefined
- boolean
- number
- string
- object
- symbol

object를 제외하면 이들을 원시타입이라고 한다.

값 타입은 typeof 연산자로 알 수 있다. typeof 반환값은 항상 7가지 내장 타입중 하나일까? 놀랍게도 목록의 7가지내장타입과 1:1로 정확히 매치되지는 않는다.

```js
typeof undefined === 'undefined' // true
typeof true === 'boolean'
typeof 42 === 'number'
typeof "42" === 'string'
typeof {life:42} === 'object'
typeof Symbol() === 'symbol'


```

예제의 6개의 타입은 자신의 명칭과 동일한 문자열을 반환한다. 심벌은 ES6에서 새로 추가된 데이터 타입이다.

```js

typeof null === 'object' // true

```
null에 대한 typeof 연산 결과는 꼭 버그처럼 보인다. null을 반환했으면 좋겠지만 거의 20년동안 이버그는 끈덕지게 버텨왔고 이제와서 손을 대자니 다른 버그가 생겨 잘돌아가던 웹소프트웨어가 멈춰버릴 경우가 너무 많아서 앞으로도 해결될 가능성은 없어보인다. 

```js

var a = null;
(!a && typeof a === 'object') //true

```

null은 falsy한 유일한 원시값이지만 타입은 object인 특별한 존재이다. typeof 가 반환하는 문자열은 하나 더있다.

```js

typeof function a() {} === "function" // true

```

typeof 반환값을 보면 마치 function이 최상위 레벨의 내장 타입처럼 보이지만 명세를 읽어보면 실제로는 object의 하위 타입이다. 구체적으로 설명하면 함수는 호출가능한 객체라고 명시되어있다. callable object.

함수는 객체라서 유용하다. 무엇보다함수에프로퍼티를 둘 수 있다.

```js

funciton a(b,c,) {

}
```

함수에 선언된 인자 개수는 함수 객체의 length프로퍼티로 알 수 있다.

```js
a.length; //2

```

함수 a는 인자두개 b,c를 가지므로 함수의 길이는 2이다.

이게진짜 맞냐..??ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 함수에다가  length 속성을 하면 인자의 개수가 튀어나온다. 진짜 몰랐다. 책제목의 이유인듯하다.

배열은 어떨까?

```js
typeof [1,2,3] === 'object' //true
```

그냥 객체다 배열은 숫자인덱스를 가지며 length 프로퍼티가 자동으로 관리되는 등의 추가 특성을 지닌 객체의 하위타입이라 할수 있다.

## 1.3 값은 타입을 가진다.

값에는 타입이 있지만 변수엔 따로 타입이란 없다. 변수는 언제라도 어떤 형태의값이라도 가질수 있다. 

자바스크립트는 타입 강제를 하지 않는다. 변수값이 처음에 할당된 값과 동일한 타입일 필요는 없다. 문자열을 넣었다가 나중에 숫자를 넣어도 상관없다.

42는 내장된 숫자 타입의 값이고, 이 타입은 절대로 바꿀 수 없다. 변수에 typeof 연산자를 대어보는건 이변수의 타입은 무엇이니라는 질문과 같지만 실은 타입이란 개념은 변수에 없으므로 저오학히는 이변수에 들어있는 값의 타입은 무엇이니라고 묻는 것이다.

typeof연산자의 반환값은 언제나 문자열이다.


### 1.3.1 값이 없는 vs 선언되지 않은 

값이 없는 변수의 값은 undefined 이며 typeof 의 결과는undefined 이다.

undefined 는 접근 가능한 스코프에 변수가 선언 되었으나 현재 아무런 값도 할당되지 않은 상태를 가리키는 반면 undeclared 는 접근 가능한 스코프에 변수 자체가 선언조차 안된 상태를 의미한다.
선언되지 않은 변수도 typeof 하면 undefined 로나온다. b는 분명 선언조차 하지 않은 변수인데 typeof b를 해도 브라우저는 오류 처리를 하지 않는다. 이것이 typeof 만의 독특한 안전 가드이다.

### 1.3.2 선언되지 않은 변수 

여러개의 스크립트 파일의 변수들이 전역 네임스페이스를 공유할 때 typeof의 안전가드는의외로 쓸모가 있다.

자신이 작성한 코드의 모든 변수는 전역 네임스페이스에는 없고 오직 전용 또는 별도의 네임스페이스에만 있다고 자신있게말하는 개발자들이있다 이론적으로는 그럴듯하지만 실제로는 거의 불가능한 소리이다. 물론 그런 방향으로 코딩하려는 자세는 좋다. 다행히 ES6부터는 모듈을 일급 개념으로 지원하기 때문에 현실적으로 가능하다.


typeof안전가드 없이 전역변수를 체크하는 방법은 전역변수가 모두 전역객체의 프로퍼티라는 점을 이용하는 것이다. 호이스팅 => 선언문은 최상위로 끌어올려진다.

window 객체를 통한 전역 변수 참조는 가급적 삼가는 것이 좋다. 전역변수를 꼭 window 객체로만 호출하지 않는 다중 자바스크립트 환경이라면 더욱 그렇다. 엄밀히 말해서 typeof안전가든느 전역변수를 사용하지 않을 때에도 유용한데 일부 개발자들은 이런 설계 방식이 그다지 바람직하지 않다고 말한다. 이를테면 다른 개발자가 여러분이 작성한 유틸리티함수를 자신의 모듈/프로그램에 카피앤페이스트하여 ㅅ용하는데 가져다쓰는 프로그램에 유틸리티의 특정 변숫값이 정의되어 있는지 체크해야하는 상황을 가정해보자.

