# 하드웨어와 소프트웨어 개념

## 2.1 소개

컴퓨터 네트워크는 1초에도 수많은 계산과 트랜잭션을 수행한다. 휴대폰은 전화번호를 저장하고 문자 메시지를 주고바등며 심지어 사진과 비디오를 캡처하기도 한다. 이러한 컴퓨터 기기는 다양한 하드웨어와 소프트웨어를 포함하는데, 이 모든것을 운영체제에서 관리한다.

운영체제는 주로 자원 관리 임무를 맡고 있으므로, 운영체제를 설계할 때는 관리할 하드웨어와 소프트웨어 자원들과 밀접하게 연계해야한다. 이러한 자원으로 프로세서, 메모리, 하드디스크와 같은 2차 저장소등을 들 수 있다. 컴퓨터가 발전함에 따라 운영체제는 새로운 하드웨어와 소프투웨어 기술에 적응하고 이미 설치된 하드웨어나 소프트웨어 기반과도 양립할 수 있어야한다.



## 2.2 하드웨어 장치의 발전

응용 프로그램들의 요구가 증가해 컴퓨팅 기술이 진화하는 것인가, 아니면 기술이 발달해 더 혁신적이고 새로운 응용프로그램이 나오는 것인가?

원래 시스템 프로그래밍은 하드웨어을 관리하고 프로그램에 서비스를 제공하도록 코딩하는 것으로, 비교적 간단하고 분명한 일이었다. 운영체제에서 소수의 프로그램과 하드웨어 자원을 관리했기 때문이다. 운영체제는 응용 프로그래밍을 가능하게 해준다. 개발자들은 장치를 다루는 코딩을 직접하지 않고 운영체제에 서비스를 요청애 문서를 편집하거나 웹페이지를 로드하는등 목표하는 일을 수행하는 응용 프로그램을 작성할 수 있게 해준다. 운영체제에서 특정 장치를 대상으로 입출력할 때에는 보통 해당 하드웨어 제조사가 제공한 디바이스 드라이버를 사용한다. 이처럼 운영체제가 새로운 장치를 지원할 때는 이에 맞는 적절한 디바이스 드라이버를 사용한다. 

> 고든 무어와 무어의 법칙

프로세서의 트랜지스터 수는 해마다 약 두배 정도로 증가한다. 트랜지스터는 전기의 흐름을 제어하는 작은 스위치이다. 스위치가 빨리 꺼졌다 켜질수록 프로세서는 그만큼 빨리 동작할 수 있다. 트랜지스터가 많아질수록 프로세서가 한번에 더 많은 작업을 처리할 수 있다. 무어는 약 10년동안 트랜지스터 수가 증가할 것이라고 예견했다. 현재는 프로세서 성능이 대략 18개월마다 배가되고, 트랜지스터 수는 24개월마다 배가되고있다. 이를 가능하게 하는 것은 프로세서에 사용하는 트랜지스터 가격이 기하급수적으로 감소한다는 점이다. 최근 나노 기술의 발달 덕분에 반도체 제조업체는 원자 몇개로 이루어진 트랜지스터를 만들게 되었다. 그러나 머지않아 연구자들은 트랜지스터를 설계할 때 원자의 크기 때문에 제한을 받게 될 것이다. 




많은 하드웨어 구성요소가 운영체제의 확장성을 지원하는 방식으로 운영체제와 상호작용하도록 설계되었다. 예를들어 플러그 앤 플래이 장치는 컴퓨터에 연결할 때 자신이 어떤장치인지 운영체제에 알리게 되어있다. 따라서 운영체제는 사용자 입력 없이도 적합한 장치를 선택해 사용할 수 있고 새로운 장치를 설치하는 과정도 간편해졌다. 
사용자 관점에서 볼 때 시스템에 추가하는 장치들은 대부분 사용 준비가 되어있다. 

## 2.3 하드웨어 구성요소

컴퓨터 하드웨어는 프로세서 메인메모리 입출력 장치 같은 물리적인 장치로 구성된다. 

### 2.3.1 메인보드

컴퓨터 시스템의 요구를 충족하기 위해 많은 하드웨어 장치와 상호작용한다. 독립된 컴퓨터는 장치들과 통신하기 위해서 여러 인쇄 회로 기판을 갖추고 있다. PCB는 보드 여기저기에 위치한 장치들을 전기적으로 연결해주는 하드웨어 구성 요소이다. (printed circuit board)

메인보드는 시스템 중심 PCB로 컴퓨터에서 중추적인 역할을 한다. 메인보드는 프로세서나 메인 메모리를 포함한 여러 하드웨어 구성요소를 꽂을 수 있는 슬롯을 내장한다. 슬롯은 다양한 하드웨어 구성 요소를 전기적으로 연결하고, 사용자가 슬롯에 장치를 추가하거나 제거해 컴퓨터 하드웨어의 구성을 필요에 따라 변경할 수 있게 해준다. 메인보드는 범용 컴퓨터에서 요청받은 명령어를 실행하는데 필요한 네가지 하드웨어 구성 요소중 하나다. 남은 세가지는 프로세서와 메인메모리, 2차저장소이다. 

전통적인 금속선은 오늘날의 시스템에서처럼 여러 구성요소를 연결하기에는 너무 크다. 따라서 메인보드를 아주 가는 실리콘층으로 구성하는 것이 보통이다. 실리콘에는 트레이스라는 아주 작은 전기적 연결선이 들어있어서 통신 채널 역할을 하고 보드에 연결된다. 이 트레이스의 집합체로 버스라는 고속 통신 채널을 만든다.

대부분의 메인보드는 저수준 기능을 담당하는 컴퓨터 칩을 몇개 포함한다. 예를 들어 메인보드는 바이오스 칩을 포함해 기본적인 하드웨어 초기화와 관리를 위한 명령어를 저장하는 것이 보통이다. 바이오스는 또한 운영체제의 초기부분을 메모리에 로드하는 역할을 하는데 이를 부트 스트랩핑이라고한다. 운영체제를 메모리에 로드하고 나면 바이오스를 사용해 시스템 하드웨어와 통신하여 저수준 입출력을 수행할 수 있다. 메인보드는 또한 컨트롤러라는 칩을 포함한다. 컨트롤러는 보드의 버스를 통해 데이터이동을 관리한다. 메인보드의 칩셋은 컨트롤러, 보조프로세서, 버스같은 하드웨어의 집합으로 메인보드에 통합되어 시스템의 하드웨어 능력을 결정한다. 

최근에는 메인보드를 설계할때 , PCB에 강력한 하드웨어 구성요소를 통합하는 경향이있다. 전통적으로는 이들 요소를 애드온 카드 형태로 슬롯에 삽입했다. 오늘날 많은 메인보드가 그래픽 프로세싱과 네트워킹, RAID기능을 수행하는 칩을 포함한다. 이러한 온보드 장치는 전체적인 시스템 비용을 줄이고 컴퓨터 가격을 큰포긍로 낮춘다. 

### 2.3.2 프로세서

프로세서는 일련의 기계어 명령어를 실행하는 하드웨어 구성요소다. 프로세서는 컴퓨터에서 중앙처리장치, 그래픽 보조 프로세서 또는 디지털 신호처리기 등 여러 형태를 띨 수 있다. CPU는 프로그램의 명령어를 실행하는 프로세서다. 그래픽이나 디지털 신호 처리기 등의 보조 프로세서는 3D변환 같은 특수 목적 명령어들을 효율적으로 실행할 목적으로 설계되었다. 임베디드 시스템에서는 DSP와 같이 프로세서가 디지털 신호를 아날로그 오디오 신호로 변환하는등의 특정한 임무를 수행하기도 한다. CPU는 시스템의 주요 프로세서로 많은 명령어를 실행할 수도 있지만, 계산 강도가 높은 특정 업무들은 해당 부분만 전문적으로 다루는 보조 프로세서에 넘겨서 효율성을 높일수 있다.

프로세서가 실행할 수 있는 명령어는 해당 명령어 집합이 어떤지에 따라 정의된다. 각 명령어의 크기는 아키텍처에 따라 다를 수 있다. 때로는 한 아키텍처의 프로세서가 다양한크기의 명령어를 지원하기도 한다. 프로세서 아키텍처는 또한 한번에 실행할 수 있는 데이터의 단위를 결정한다. 예를 들어, 32비트 프로세서는 32비트 단위로 데이터를 조작한다.

현재 사용하는 프로세서는 하드웨어에서 많은 시스템의 자원 관리 연산을 수행해 성능을 향상시킨다. 이러한 기능으로 가상메모리 하드웨어 인터럽트 지원이 있다. 

다양한 프로세서 아키텍처에도 불구하고 몇가지 구성요소는 현태의 프로세서에 공통적이다. 이러한 구성요소로는 명령어 페치기, 분기 예측기, 실행처리기, 레지스터, 캐시, 버스 인터페이스 등이 있다. 명령어 페치기능 명령어 레지스터라는 고속의 메모리에 명령어를 로드해 프로세서가 명령어를 빨리 실행할수 있게해준다. 명령어 해석기는 명령어를 해석하고 이에 해당하는 입력 정보를 실행 처리기에 전달한다. 실행처리기의 주요 부분은 산술 논리 장치다. ALU는 덧셈, 곱셈과 같은 기본적인 산술 연산과 대소비교같은 논리연산을 수행한다. 

버스 인터페이스는 프로세서가 메모리나 다른 장치들과 상호작용 할 수 있게 해준다. 프로세서는 보통 메인 메모리보다 훨씬 빠른 속도로 작동하므로, 시스템은 캐시라는 고속메모리를 포함한다. 캐시는 메인메모리에 있는 데이터의 복사본을 저장하는 메모리로, 프로세서의 데이터와 명령어에 빠르게 접근할 수 있게해서 효율을 높여주다.

고속 캐시는 메인 메모리보다 훨씬 비싸기 때문에 보통은 용량이 제한되기 마련이다. 캐시는 여러 수준으로 분류된다. 
L1캐시는 가장 빠르고 비싸며 프로세서에 위치한다. L2캐시는 L1캐시에 비해 비용이 저렴하고 용량이 크며, 흔히 메인보드에 위치한다. 하지만 성능 향상을 위해 점점 프로세서에 통합되고있다.

레지스터는 프로세서에 위치한 고속메모리로, 프로세서가 바로 사용할 수 있는 데이터를 담는다. 프로세서가 데이터를 조작하려면 해당 데이터가 레지스터에 위치해야한다. 프로세서 명령어를 다른 저속 메모리에 로드하는 일은 비효율적이다. 프로세서가 데이터에 접근하는 것을 기다리는 동안 쉬고 있어야하기 때문이다. 레지스터는 프로세서 회로에 프로그램이 아닌 물리적인 방시긍로 배선 처리가 되어있고 , 처리기 가까이에 위치해 L1 캐시에 접근하는 것보다도 빠르다. 레지스터의 크기는 프로세서가 한번에 처리할 수 있는 비트수에 따라 결정된다. 예를 들어 32비트 프로세서는 각 레지스터에 32비트 데이터를 로드한다. 오늘날 개인용 컴퓨터는 대부분 32비트 프로세서를 사용한다. 64비트 프로세서도 점점 많아지고 있다.

각 프로세서 아키텍처마다 제공하는 레지스터수가 다르고 각 레지스터는 특정 목적을 위해서 서비스를 제공한다. 예를 들어 인텔 펜티엄 4프로세서는 16개의 프로그램을 실행하는 레지스터를 제공한다.  이 레지스터의 절반은 응용 프로그램이 데이터 값이나 실행중 포인터 값을 빠르게 읽어야할 때 사용하려고 별도로 예비해두는 경우가 많다. 이런 레지스터를 범용 레지스터라고한다. 애플의 G5컴퓨터에 사용된 IBM의 PowerPC970 프로세서는 범용 레지스터 32개를 포함한다. 다른 레지스터는 보통 컨트롤 레지스터라고 하며, 다음 실행할 명령어가 무엇인지 알려주는 프로그램 카운터등 시스템에 관한 정보를 저장한다.

### 2.3.3 클록

컴퓨터 시간은 흔히 사이클을 통해 측정한다. 사이클은 시스템 클록 생성기가 보낸 전기 신호의 한 진폭을 말한다. 클록 생성기는 마치 오케스트라의 지휘자와 같이 컴퓨터 시스템의 리듬을 형성한다. 특히 클록 생성기는 버스가 데이터를 나루는 주기를 결정한다. 이는 대체로 초당 사이클수 , 즉 헤르츠로 측정한다. 예를 들어 프론트사이드버스는 프로세서들을 메모리 모듈에 연결하는데, 흔히 몇백 메가헤르츠 정도로 작동한다.
프로세서와 다른 장치는 프론트사이드버스의 속도를 나누거나 곱해 도출속도를 생선한다. 예를 들어 200MHz프론트사이드 버스를 사용하는 2GHz프로세서는 사이클을 생성하기위해 10배수를 곱하고 66MHz사운드 카드인 경우 사이클을 생성을 위해 2.5로 나눈다.

### 2.3.4 메모리 계층

메모리의 속도나 크기는 물리적, 경제적 여건 때문에 제한된다. 대부분의 전자장치는 PCB 의 트레이스를 통해 전자를 보내는 방식으로 데이터를 이동한다. 전자가 이동할 수 있는 속도에도 제한이있다. 두 단말 사이으이 선이 길수로 데이터 이동시간이 길다. 게다가 프로세서에 근접한 속도로 데이터 요청에 응할 만큼 빠른 메모리를 넉넉하게 구비하는 것은 비용이 너무 많이 들어 거의 불가능한 일이다. 

비용과 성능의 상충성 때문에 메모리 계층이 생긴다.  가장 빠르고 비싼 메모리는 최상위 계층에있고, 대개 용량이 작다. 최하위에있는 것은 가장 저렴하고 속도가 느린 메모리로, 대체로 크 ㄴ용량을 갖는다. 아래쪽에 있는 느린 메모리 계층으로 갈수록 블록의 크기가 점점 증가한다. 그러나 일정한 규모가 아닌 피라미드 형태로 증가한다.

레지스터는 시스템에서 가장빠르고 비싼 메모리이다. 레지스터는 프로세서와 같은 속도로 작동한다. 캐시메모리의 속도는 지연시간, 즉 데이터를 이동하는데 소요되는 시간으로 측정한다. 지연시간은 대체로 나노초또는 프로세스 사이클로 측정한다. 

계층에서 다음단계는 메인메모리로 실제메모리라고도한다. 레지스터 캐시, 메인메모리는 대체로 휘발성 매체로 전원을 끄면 데이터가 사라진다.

하드 디스크와 cd, dvd,테이프 같은 다른 저장장치들은 가장 느리고 값이 저렴한 데이터 저장 매체다. 디스크 저장장치의 지연시간은 대개 밀리초단위며, 보통 프로세서 캐시지연시간보다 백만배 저도 느리다. 운영체제는 프로세스가 2차 저장소로 부터 데이터가 오기를 기다리는 동안 쉬게하기 보다는 대개 다른 프로세서를 실행하게해서 프로세서 활용도를 높인다. 하드 디스크와 같은 2차 저장소의 주요 장점은 용량이 크다는 점이다. 

또한 2차 저장소는 데이터를 영구적으로 저장할 수 있다. 따라서 전원이 나가도 2차 저장소의 데이터는 사라지지 않는다. 시스템 설계자는 사용자의 요구를 충족하도록 다양한 저장장치의 비용과 성능 사이의 균형을 맞춰야한다.

> 캐싱 Caching

캐싱은 일상생활에서 늘 사용하는 것이다. 일반적으로 말하면 캐리란 재빨리 접근할 수 있는 예비 물품 저장소이다. 다람쥐가 겨우살이를 준비하려고 도토리를 저장하는 것도 일종의 캐싱이다. 운영체제는 프로그램이 실행할 때 빠르게 접근할 수 있게 프로세서의 데이터와 명령어를 고속 캐시 메모리에 캐시하거나, 디스크에 있는 데이터를 메인 메모리에 캐시하는 등 다양한 캐싱 기술을 이용한다.

운영체제 설계자들은 캐싱 기술을 사용할 때 주의해야한다. 컴퓨터 시스템에서 캐시된 데이터는 상위 메모리 계층에 유지되는 원본 데이터의 사본이기 때문이다. 캐시된 사본은 변경 사항이 가장 먼저 적용되므로 원본데이터와 금방 달라지기 쉽다. 따라서 데이터의 일관성이 깨질 우려가있다. 캐시에 갱신된 데이터가 있고 원본을 미처 갱신하지 못한채 시스템이 다운되면 수저오딘 데이터를 잃는다. 그러므로 운영체제는 캐시된 데이터를 원본데이터에 빈번하게 복사한다. 이러한 과정을 캐시 플러싱이라고한다. 분산파일시스템은 서버와 클라이언트 모두에 캐시를 둘 때가 많다. 이는 캐시 데이터와 원본데이터의 일관성 유지를 더욱 복잡하게 만든다.



### 2.3.5 메인 메모리

메인 메모리는 휘발성 임의 접근 메모리이다. 임의라함은 프로세스가 어떤 순서로든 데이터에 접근할 수 있다는 의미이다. 이와 대조적으로 테이프와 같은 연속적인저장 매체는 순차적으로 읽어야한다. 메인 메모리에 접근하는데 걸리는 지연시간은 테이프나 하드디스크와 달리 어느 위치든 동일하다.

RAM의 가장 흔한 형태는 동적램이다. DRAM은 재생회로에서 일정 주기마다 데이터를 읽어야한다. 이렇게 하지 않으면 데이터를 손실하게 된다. 정적 램은  이와 달리 저장하는 데이터를 유지하려고 다시 읽을 필요가 없다. SRAM 은 주로 프로세서 캐시로 사용하며, DRAM보다 빠르고 비싸다.

DRAM제조사들의 중요한 목표는 프로세서의 속도와 메모리 전환속도의 간격을 줄이는데 있다. 메모리 모듈은 모듈안에서 데이터 접근 지연 시간을 최소화하고 초당 데이터 이동량을 늘리는 쪽으로 설계된다. 이러한 기술은 전반적인 지연시간은 줄이고 대역폭은 높인다. 


### 2.3.6 2차 저장소

컴퓨터에서 데이터 파일이나 응용 프로그램 소프트웨어등 대용량 데이터를 영구적으로 보관하려면 전원이 나간 후에도 데이터를 영구 저장할 수 있는 2차 저장소또는 보조 저장소를 사용한다. 대부분의 컴퓨터는 2차저장소로 하드디스크를 사용한다. 하드디스크 드라이브는 RAM보다 저렴한 비용으로 더 많은 양을 저장할 수 있지만, 메인메모리에 접근하는 것보다 속도가 현저히 느리기 때문에 주 메모리로 사용하기에는 실용성이 떨어진다. 

몇몇 2차 저장장치는 데이터를 용량이 작은 매체에 저장한다. 이들 매체는 컴퓨터에서 제거할 수 있고 컴퓨터간에 데이터를 백업하거나 이동할 수 있게해준다. 어떤 시스템은 2차 저장소를 넘어서는 수준의 메모리를 갖추고있다. 예를 들어, 대용량 데이터를 처리하는 시스템은 종종 로봇 팔로 접근하는 테이프 라이브러리를 갖추고 있다. 이러한 저장 시스템은흔히 3차저장소로 분류하며 2차저장소보다 대용량이고 접근 시간이 긴 것이 특징이다. 

### 2.3.7 버스

버스는 하드웨어 장치간에 정보를 나르는 트레이스의 집합 혹은 전기적 연결이다. 하드웨어 장치는 다른 장치와 통신할 때 버스를 통해 전기 신호를 보낸다. 대부분의 버스는 데이터를 나르는 데이터버스, 해당 데이터의 위치나 수신위치를 결정하는 주소버스로 구성된다. 포트는 정확히 두 장치를 연결하는 버스다. 서너 개 장치에서 입출력 기능을 수행할 때 공유하는 버스는 입출력 채널이라고 한다.

앞에서 프론트 사이드 버스가 프로세서를 메인 메모리에 연결한다는 사실을 배웠다. FSB속도가 증가하면 메인 메모리와 프로ㅔㅅ서 사이에 전송되는 데이터양이 증가해 성능이 향상된다. 버스의 속도는 MHz로 측정한다. 몇몇 칩셋은 클록 사이클 당 메모리 전송을 두번 수행해 200MHz 가 400MHz로 작동하도록 구현한다. 이런 특징은 칩셋과 램 모두에서 지원해야하며 DDR이라고한다. 

### 2.3.8 직접 메모리 접근

대부분의 입출력 연산은 메인메모리와 입출력 장치 사이에서 데이터를 전송한다. 초창기 컴퓨터는 프로그래밍된 입출력을 사용해 데이터 전송을 수행했다. 

1. 프로세서는 입출력 컨트롤러에 입출력 요청을 보내고, 입출력 컨트롤러는 해당 요청을 디스크에 보냄,. 프로세서는 계속해서 다른 명령을 실행
2. 디스크는 입출력 컨트롤러에 데이터를 보냄. 이 데이터는 DMA명령이 지정한 메모리 주소에 위치함
3. 디스크는 프로세서에 인터럽트를 보내어 입출력이 완료되었음을 알림

레거시 하드웨어와 소프트웨어

최신 버전의 운영체제는 가장 최근의 하드웨어와 소프트웨어의 기능을 지원하도록 설계된다. 그러나 거기있는 대다수의 하드웨어와 소프트웨어는 개인이나 기관이 투자를 많이한 오래된 장비나 응용 프로그램인 경우가 많고 새로운 운영체제가 설치되더라도 계속 사용되길 원할 때가많다. 이처럼 오래된 항목을 레거시 하드웨어, 레거시 소프트웨어라고 한다. 운영체제 설계자가 맞닥뜨린 커다란 도전거리는 그와 같은 레거시 시스템을 지원할 수 있도록 하는 것으로, 실게계에서 사요오딜 운영체제라면 반드시 갖추어야할 조건이다.


### 2.3.9 주변장치

주변장치란 컴퓨터가 소프트웨어 명령어를 실행하는데 필수적이지 않은 하드웨어를 말한다. 주변장치는 프린터나 스캐너, 마우스등 다양한 입출력 장치와 네트워크 인터페이스 카드, 모뎀같은 네트워크장치등을 가리킨다. 프로ㅔㅅ서나 메인보드, 메인메모리는 주변장치에 속하지않는다. 아마도 가장 보편적인 주변장치는 하드디스크일 것이다. 



## 2.4 하드웨어의 운영체제 지원

컴퓨터 아키텍처는 성능 향상을 위해 운영체제가 더 빨리 기능할 수 있도록 하드웨어적으로 지원하는 몇가지 기능을 포함한다. 또한 운영체제가 엄격한 방어체계를 갖추어 시스템의 보안과 무결성을 보장하도록 한다.

### 2.4.1 프로세서

대부분의 운영체제는 프로세서를 통해 보호 메커니즘을 구현한다. 프로세서는 프로세스가 할당받지 않은 메모리에 접근하는 일을 막는다. 프로세스가 시스템의 보호 메커니즘을 위반하려고 하면 프로세서는 이를 운영체제에 알려 적절히 반응하게한다. 또한 프로세서는 하드웨어 장치에서 보내는 신호에 반응하도록 운영체제를 호출한다.

컴퓨터 시스템은 흔히 몇가지 다른 실행 모드가 있다. 시스템의 모드를 변경함으로써 더 견고하고 장애 내구성이 있고 안전한 시스템을 만들수 있다. 흔히 시스템이 특정 모드에서 동작할 때 응용 프로그램들은 시스템 명령어의 하위 집합에만 접근할 수 있다. 사용자 응용프로그램에서는 사용자가 사용자모드로 실행할 수 있는 명령어의 부분집합에서 입출력 명령어를 직접 실행하는 일등은제외한다. 
컴퓨터 아키텍처가 진화하면서 특권 명령어 즉, 사용자 모드에서는 접근할 수 없는 명령어의 수가 증가하는 점은 주목할 만한 일이다. 이는 하드웨어에 운영체제와 협력하는 기능이 더욱 증가하는 경향을 보여준다.

대부분의 프로세서는 메모리 보호와 관리 메커니즘을 제공한다. 메모리 보호는 프로세스가 다른 사용자의 메모리나 운영체제의 메모리 등 자신이 할당받지 않은 메모리에 접근하는 것을 방지한다. 메모리 방지 기능은 특권 명령어로만 수정할 있는 프로세서 레지스터를 사용해 구현한다. 프로세서는 이러한 레지스터들의 값을 확인해 프로세스가 자신이 할당받지 않은 메모리에 접근하지 못하게 한다. 예를 들어 가상메모리를 사용하지 않는 시스템에서는 프로세스들이 메모리 주소의 연속적인 블록만 할당받는다. 시스템은 프로세스가 할당받은 메모리의 시작과 끝 위치를 명시하는 경계 레지스터를 제공해 프로세스들이 자신이 할당 받지 않은 메모리 위치에 접근하는 것을 막는다. 특정 주소가 할당된 블록 안에 있는지 확인해 메모리 보호를 강화할 수도 있다. 대부분의 하드웨어 보호는 프로그램 명령어를 실행하는 것과 병행해 수행되므로 성능 저하를 야기하지 않는다. 대부분의 프로세서는 또한 프로세스에서 참조하는 가상 메모리 주소를 대응하는 메인 메모리 주소로 해석하는 하드에어를 포함한다. 가상 메모리 시스템은 프로그램이 메인 메모리에 있는 제한된 일련의 실제 주소에 대응하지 않아도 되는 주소를 참조할 수 있게 해준다. 

> 최소 권한의 원칙

일반적으로 볼 때 최소 권한의 원칙이란 어떤 시스템이든 다양한 객체에 자기 임무를 수행하는데 필요한 능력 이상을 부여하면 안됨을 나타낸다. 정부에서도 보안 허가에 이 원칙을 적용한다. 누군가에게 내 집을 드나들도록 여분의 열쇠를 줄 때도 이런 원칙을 적용할 것이다. 운영체제는 하드웨어를 사용해 실행시 프로세스의 가상 주소를 물리 주소로 바꿔준다. 가상 메모리 시스템은 프로세스가 메인 메모리에서 사용 가능한 것보다 훨씬 많은 공간의 주소를 참조할 수 있게 해준다. 따라서 프로그래머들은 물리적 메모리 제한에 구애받지 않고 응용 프로그램을 작성할 수 있다. 가상 메모리는 또한 시분할 시스템을 위한 프로그램을 가능하게 해준다. 프로세스들이 메인 메모리에 있는 데이터의 실제 위치를 알 필요가 없기 때문이다. 

프로세서는 운영체제에 프로그램 실행중 발생하는 오류나 장치의 상태변화등 여러 이벤트를 알려준다.  프로세서는 각 장치의 상태를 반복적으로 확인하는 폴링이라는 기술을 통해 이렇게 할수 있다. 그러나 장치에 변화가 없는데도 이렇게 상태를 계속해서 확인하면 상당한 실행부하를 주게된다.


대부분의 장치는 이런 방법 대신 이벤트가 발생할 때 프로세서에 인터럽트라는 신호를 보낸다. 
그러면 운영체제는 이에 반응하여 해당 유형의 이벤트를 기다리고 있는 프로세스에 알려준다. 예외는 하드웨어 고장이나 로직오류, 보안규칙위반 같은 여러 오류에 대한 반응으로 발생하는 인터럽트다. 프로세서는 시스템이 다운되지 않게 하려고 보통은 운영체제를 호출해 반응할 방법을 결정하게 한다. 예를 들어 운영체제는 오류를 유발하는 프로세스를 종료하거나 시스템이 다시 시작하게 할 수도 있다. 만약 시스템이 다운되어야 한다면 운영체제는 작업 손실을 최소화하도록 우아하게 종료할 수 있다. 프로세스는 운영체제에 예외 처리기를 등록할 수도 있다.


> 보호

초창기 컴퓨터에있던 원시적인 운영체제는 한번에 한가지 작업만 실행할 수 있다. 하지만 지역 시스템에 병렬 처리 능력이 추가되고, 네트워크를 통해 병렬 처리가 가능한 분산 시스템이 개발되면서 급격하게 변했다. 운영체제는 다양한 유형의 보호, 특히 인터넷에 연결할 때 시스템 보호를 신중하게 고려해야한다. 운영체제와 그 데이터가 우연이든 고의든 잘못된 사용자 프로그램 때문에 손상받지 않도록 보호해야한다. 사용자 프로그램 역시 서로를 방해하지 않게 보호해야한다. 지역 시스템과 사용자 그리고 네트워크에 퍼져 있는 컴퓨터 운영체제 구성 요소 모두 이런 보호가 필요하다. 



### 2.4.2 타이머와 클록

간격 타이머는 주기적으로 인터럽트를 발생시켜 프로세서가 운영체제를 호출하게한다.  운영체제는 이 타이머를 사용해 특정 프로세스가 프로세서를  독점하는 것을 막는다. 예를 들면 운영체제에서 타이머가 인터럽트를 보내올 때 현재 프로세스를 제거하고 다른 프로세스가 프로세서를 사용할수 있게한다. 시간 클록은 컴퓨터가 수천초분의 1 또는 수만초분의 1정도의 오차안에서 정확한 실제시간을 따라잡을 수 있게한다. 몇몇 시간 클록은 배터리 충전기를 포함하고 있어서 외부 전력 공급이 없을 때도 정확하게 작동하기도한다. 이러한 클록은 시스템의 연속성을 유지하는 수단이된다. 

### 2.4.3 부트스트랩핑

운영체제에서 자원을 관리하려면 먼저 자신이 메모리에 로드되어야한다. 컴퓨터를 켜면 바이오스가 시스템 하드웨어를 초기화하고 플로피디스크나 하드디스크 cd같은 2차 저장소에 있는 부트섹터에서 명령어들을 읽어 메인 메모리에 로드한다. 이과정을 부트 스트랩핑이라고한다. 프로세서는 이러한 명령어를 실행하도록 만들어진다. 이때 실행하는 명령어는 대개 운영체제의 구성 요소를 메모리에 로드하고, 프로세서 레지스터를 초기화하며 시스템이 사용자 응용 프로그램을 실행할 준비를 하게하는 것이다. 


1. 하드웨어 정보를 수집하고 시스템을 초기화함
2. 부트섹터에서 데이터를 읽어 메인 메모리에 로드
3. 프로세서가 부트스트랩 코드를 실행함
4. 디스크에서 운영체제를 읽어 로드함

많은 시스템에서 바이오스를 통해 몇몇 장치들의 미리 정의된 위치에서 운영체제를 읽어 로드한다. 만약 해당 장치에서 부트 섹터를 찾지 못하면 시스템을 로드하지 못하고 사용자는 컴퓨터의 어떤 하드웨어에도 접근할 수 없게된다. 인텔은 부팅시에 더 많은 기능을 지원하려고 바이오스대신 확장 펌웨어 인터페이스를 개발했다. EFI는 셸을  지원해 사용자들이 컴퓨터 장치에 직접 접근할 수 있게하고 컴퓨터 전원이 들어오는 즉시 디바이스 드라이버들이 하드 드라이브와 네트워크에 접근할 수 있도록 돕는다.


### 2.4.4 플러그 앤 플레이

플러그앤 플레이 기술은 운영체제가 새로 설치한 하드웨어를 사용자와 교류없이 자동으로 인식하고 사용가능하게해준다. 
1. 운영체제에서 자신이 어떤 장치인지 유일하게 식별할수 있게한다.
2. 운영체제와 통신해 해당 장치가 올바르게 작동하는데 필요한 자원과 서비스를 요청할 수 있다.
3. 해당 장치와 대응하는 드라이버를 식별하고 운영체제가 해당 드라이버를 ㅏㅅ용해 장치를 구성할 수 있게해준다. 


분산 컴퓨팅이 확산되면서 점점 많은 시스템이 전력 공급을 충전기에 의존한다.그 결과 플러그앤 플레이 기술도 전력관리 기능을 갖추어 시스템이 전력 소비 상태에 동적으로 적응해 배터리 수명을 연장할 수 있게한다. 고급 구성 및 전원 인터페이스는 운영체제가 장치들을 구성하고 전력 소비를 관리하는 표준을 정의하고 있다. 

## 2.5 캐싱과 버퍼링

대부분의 시스템은 성능을 향상시키려고 캐싱을 수행한다. 프로세스가 참조하는 데이터를 더 빠른 저장공간에 복사하는 것이다. 그러나 빠른 저장소일수록 비싸기 때문에 캐시할 수 있는 데이터양이 제한된다. 따라서 캐시엔트리를 잘관리해 참조하는 정보가 캐시메모리에 없는 경우 의 수를 최소화해야한다. 캐시 실패가 발생하면, 시스템은 속도가 낮은 원래의 저장소에서 참조하는 정보를 얻어와야한다. 참조하는 정보가 캐시 메모리에 있는 경우를 캐시 적중이라고하며, 이 경우 시스템은 비교적 빠른 속도로 필요한 데이터에 접근할 수 있다. 

캐싱을 통해 성능을 향상시키려면 메모리 참조의 상당수가 캐시 적중되어야한다. 프로세스들이 곧 어떤 데이터를 참조할지 예측하기는 어렵다 그러므로 대부분의 캐시는 경험과 통계에 근거해 경험적 방법을 사용한다. 즉 직적의 정보를 분석해볼 때 비교적 적은 실행 부하로 좋은 결과를 얻었다면, 이를 근사치로 활용해 다음에 참조할 데이터를 예측한다.

버퍼는 장치들 사이 혹은 서로 다른 속도로 동작하는 프로세스들 사이에서 데이터를 전송할 때 일시적으로 데이터를 보관하는 저장 영역을 말한다. 버퍼는 소프트웨어와 하드웨어 장치들이 데이터를 비동기적으로 (즉 의존하지 않고 독립적으로) 전송하게 함으로써 시스템 성능을 향상시킨다. 버퍼에는 하드디스크 버퍼, 키보드 버퍼, 프린터 버퍼등이 있다. 하드디스크는 메인 메모리보다 훨씬느리게 동작하므로 운영체제는 대개 쓰기 요청된 데이터를 버퍼링한다. 버퍼는 하드디스크에 쓰기 작업을 마칠 때까지 데이터를 보관해 운영체제가 입출력 작업 중에도 다른 프로세스를 실행할 수 있게 해준다. 키보드 버퍼는 프로세스에서 인식하고 대응하는 키보드 인터럽트에 반응할 때까지 사용자가 입력한 글자를 보관한다. 

스풀링은 한 프로세스와 저속 또는 버퍼가 제한된 입출력장치 사이에 디스크와 같은 중간 매개체를 두는 기술이다. 예를 들어, 한 프로세스가 인쇄를 시도하는데 프린터가 다른 문서를 인쇄하고 있다면, 프로세스는 프린터를 사용할 수 있게 될 때까지 기다리는 대신 출력물을 디스크에 쓴다. 프린터가 앞선 작업을 마치면 디스크에 있는 데이터를 인쇄하기 시작한다. 스풀링은 주변장치들이 곧바로 서비스를 수행할 준비가 안되어있을 때도 프로세스들이 제2, 제3의 서비스를 요청할 수 있게 해준다. 

## 2.6 소프트웨어 개관

프로그래밍 언어는 기계어나 어셈블리언어 또는 고급언어로 분류할 수 있다.


### 2.6.1 기계어와 어셈블리 언어

컴퓨터는 오직 자신의 기계어만 이해할 수 있다. 특정 컴퓨터의 자연어처럼 기계어는 컴퓨터의 하드웨어 설계에 따라 정의된다. 기계어는 대체로 숫자의 연속으로 구서오디는데, 이는 궁극적으로 1과 0 두 숫자의 스트림으로, 컴퓨터가 자신의 가장 기초적인 연산을 어떻게 수행할지를 명령하는 것이다. 기계어는 머신에 종속적이다. 즉 특정기계어는 그에 상응하는 종류의 컴퓨터에서만 사용할 수 있다. 

컴퓨터 사용자가 증가하는 것과 비교할 때, 기계어 프로그래밍은 너무 느리고, 오류를 유발하기 쉬운 조약한 도구였다. 따라서 프로그래머들은 컴퓨터가 직접 이해할 수 있는 숫자 스트림 대신 영어와 비슷한 약어들을 사용해 컴퓨터의 기본 연산을 나타내기 시작했다 .그리고 이 약어들은 어셈블리 언어의 기초를 형성했다. 어셈블러라는 번역 프로그램은 어셈블리 언어 프로그램을 기계어로 변환한다. 다음은 어셈블리 언어 프로그램을 간략하게 표현한 것으로, 기본 급여에 초과 근무 수당을 더해 총 급여를 계산하고 있다.

```
LOAD BASEPAY
ADD OVERPAY
STORE GROSSPAY
```

이러한 어셈블러 언어 코드는 사람에게는 쉬워졌지만 컴퓨터가 직접 이해할 수 없다. 따라서 어셈블러 프로그램을 통해 기계어로 변환해야한다.



### 2.6.2 인터프리터와 컴파일러

어셈브릴 언어프로그래밍은 기계어 프로그래밍보다 빠르지만 아주 간단한 작업을 하는데도 여전히 많은 명령어가 필요했다. 따라서 프로그래머들이 더 효율적으로 작업할 수 있는 고급 언어를 개발하게 되었다. 고급언어는 적은 문장으로도상당한 작업을 수행할 수 있게 해준다. 하지만 고급언어를 기계어로 변환하려면 컴파일러라는 번역 프로그램이 필요하다. 프로그래머들은 고급언어를 통해 일상 영어와 유사하고 일반적인 수학 기호를 포함하는 프로그램을 작성할 수 있다. 컴파일러가 고급언어를 기계언어로 변환하는 반면, 인터프리터는 소스코드로 혹은 기계어는 아니어도 좀더 낮은 수준의 언어로 축약된 프로그램을 직접 실행하는 프로그램이다. 자바와 같은 프로그래밍 언어는 바이트코드 형태로 변환해 가상 머신의 기계어처럼 실행한다. 그러므로 바이트코드는 실행하는 물리적 시스템에 한정되지 않아 응용 프로그램의 이식성을 높여준다. 자바 인터프리터는 각 문장을 분석하고 물리적인 머신에서 바이트 코드를 실행한다. 인터프리터로 실행하는 프로그램은 실행하려면 해석을 해야하는 오버헤드가 발생해 기계어 코드로 컴파일해 실행하는 프로그램보다 느린 경향이 있다. 


### 2.6.3 고급 언어

코볼은 1950년대 후반에 컴퓨터 제조사와 정부기관, 산업계의 컴퓨터 사용자 그룹이 개발한 언어로, 대용량 데이터를 조작하는 비즈니스 응용 프로그램 개발을 목적으로 설계 되었다. 오늘날 비즈니스 소프트웨어의 상당량이 여전히 코볼로 작성되었다. C는 70년대 벨연구소의 데니스리치가 개발했고 유닉스 운여체제를 개발한 언어로 유명해졌다. 

93년에 웹이 폭발적으로 증가했을 때 썬 마이크로시스템즈는 새로운 객체지향 언어인 자바의 가능성을 즉시 간파했다. 자바는 웹에서 내려받고, 웨븝라우저로 실행할수 있는 응용프로그램을 개발하는데 적합한 언어였다. 썬은 95년 자바언어를 공개했다. 당시는 웹에 대한 관심이 커서 자바는 곧 비즈니스 분야에서 큰 관심을 얻고 소프트웨어 개발언어로 널리 사용되기에 이르렀다. 자바언어를 사용해 웹 페이지를 동적으로 생성하고 대규모 엔터프라이즈급 응용 프로그램도 개발했다. 또한 웹서버 기능을 강화하여 휴대폰이나 호출기, PDA용 응용 프로그램이나 기타 여러 목적으로 사용할 수 있다.

00년대에는 마이크로소프트에서 C#과 닷넷 전략을 발표했다. C#프로그래밍 언어는 특히 닷넷 플랫폼용 언어로 설계되었다. C#은 c, c++ 자바 언어를 근간으로한 객체지향언어로 닷넷의 강력한 라이브러리 컴포넌트들을 사용해 응용 프로그램을 빨리 개발할 수 있게 설계되었다.



### 2.6.4 구조적 프로그래밍

60년대에는 소프트웨어 개발이 촉박한 일정에 쫓기고, 예산을 초과하고 결과물은 품질이 떨어지는 것이 큰 문제로 대두되었다. 소프트웨어 개발을 위한 연구로 구조적 프로그래밍이 발전하게 되었다. 프로그래밍 언어 에이다는 70년대와 80년대 초기에 미 국방성의 후원을 받아 개발되었다. 에이다는 시인 바이런 경의 딸인 에이다 러브레이스 백작부인의 이름을 딴 것이다. 에이다는 병행 프로그래밍을 지원한 최초의 언어중 하나다.


### 2.6.5 객체지향 프로그래밍

객체 기술은 의미있는 소프트웨어 단위를 생성하기 위한 패키지 스키마다. 객체는 색상이나 크기 무게같은 속성을 갖는다. 또한 객체는 움직이기 잠자기 그리기 같은 동작을 한다. 클래스는 관련된 객체들의 타입을 말한다. 예를 들면 모든 차량은 연식이나 모델 색상 옵션등이 달라도 car클래스에 속할수 있다. 클래스는 해당 클래스 타입에 속하는 객체들의 일반적인 형태를 명시하고 각 클래스마다 필요한 프로퍼티와 동작이 결정된다. 

객체지향 언어가 나타나기 전에 포트란 파스칼 BASIC , C등의 절차적 프로그래밍 언어는 객체보다는 동작에 초점을 두었다. 이러한 프로그래밍은 약간 어색한 면들이 있다. 그러나 c++ 자바 C# 오늘날 널리 사용하는 객체지향 프로그래밍 언어를 사용해 프로그램을 작성할 수 있게 되었고 이는 사람들이 실세계사물을 인식하는 방식을 더 자연스럽게 반영할수 있게 해준다. 

객체 기술은 적절하게 설계한 클래스들을 여러 프로젝트에서 재사용 할수 있게 해준다. 클래스 라이브러리를 사용하면 새로운 시스템을 개발하는 노력을 많이 절약할 수 있다. 그러나 몇몇 기관은 객체지향 프로그래밍의 핵심 장점이 소프트웨어 재사용성보다는 이해하기 쉬운 소프트웨어 제품 자체라고 한다. 이런 소프트웨어는 잘 구조화되어있고 유지보수하기 쉽기 때문이다.

객체지향 프로그래밍은 프로그래머들이 좀더 큰그림에 집중할 수 있게해준다. 재사용 가능한 객체를 어떻게 설계할 것인가 하는 세세하고 복잡한 사항들을 걱정해주는 대신 객체들의 동작과 상호작용에 초점을 맞출수 있기 때문이다. 또한 한 객체를 수정할 때, 다른 객체들에 미칠 파장을 염려하지 않아도되었다. 집안의 통로나 나무 한그루 , 한그루를 세세하게 보여주는 지도는 가능하긴해도읽기 어려울 것이다. 이러한 세부사항을 생략하고 필수정보만 남겨두면 지도가 읽기 쉬워지고 유용해질 것이다. 

## 2.7 응용 프로그래밍 인터페이스

오늘날 응용 프로그램은 디스크에 있는 파일이나 원격 컴퓨터의 데이터등 운영체제가 관리하는 여러 자원에 접근해야한다. 운영체제는 자원을 관리하기 때문에 프로세스들이 이런 자원에 접근하기 전에 반드시 자원에대한 접근 요청을 하게한다. 


응용프로그래밍 인터페이스는 프로그래머들이 운영체제에 서비스를 요청할 수 있는 일련의 루틴을 제공한다. 소프트웨어와 운영체제의 통신은 오직 API를 통해 수행된다. API의 예로는 POSIX 표준과 MS윈도우 응용프로그램을 개발할 때 사용하는 윈도우 API등이 있다. POSIX는 초기 유닉스 시스템에 기초한 API를 제공하며, 유닉스 기반 운영체제에서널리 사용되고 있다. Win32 API는 윈도우 환경에서 실행할 응용 프로그램용 마이크로소프트 인터페이스이다.

프로세스는 API에 정의된 함수를 실행해 시스템의 하위 계층 서비스에 접근한다. 이러한 함수 호출은 운영ㅊ제의 서비스를 요구하는 시스템 호출을 발생시킬수 있다. system call은 하드웨어 장치들에 인터럽트를 거는 것과 유사하다. 시스템 콜이 발생하면 시스템은 커널 모드로 바뀌고 , 운영체제는 시스템콜에 맞게 서비스를 수행한다. 

## 2.8 컴파일링, 링킹, 로딩

고급 언어로 작성한 프로그램을 실행하려면 먼저 기계어로 컴파일해야하고, 실행에 필요한 여러 기계어 프로그램과 링크해야하며, 메모리에 로드해야한다. 


### 2.8.1 컴파일링

컴파일러는 고급언어로 작성한 코드를 입력으로 받고, 실행할수 있는 기계어 명령어를 담은 오브젝트 코드를 출력물로 내놓는다. 거의 모든 상용 프로그램이 오브젝트 코드로 배포되며, 오픈 소스 소프트웨어들은 소스코드까지 포함해 배포된다.

컴파일 과정은 몇가지 단계로 나뉜다. 먼저 소스코드를 렉서(어휘 분석기)에 보내면 렉서는 프로그램의 문자들을 토큰으로 분리한다. 토큰으로는 if else int 등의 키워드나 이름있는 변수와 상수등의 식별자 덧셈 곱세 뺄셈 나눗셈 등의 연산자 세미콜론등의 구두점이있다. 

렉서는 이러한 일련의 토큰을 파서에 보내고 파서는 토큰을 구문적으로 올바른 문장으로 그룹화한다. 중간 코드 생성기는 이 구조를 어셈블리 언어를 닮은 간단한 명령어 스트림으로 변환한다. 옵티마이저는 코드의 실행효율을 높이고 프로그램의 메모리 요구량을 줄이는 역할을 한다. 마지막 단계에서는 코드생성기가 기계어 명령어를 담고있는 오브젝트 파일을 만들어낸다.


### 2.8.2 링킹

링킹은 프로그램에서 참조하는 다양한 모듈을 실행 가능한 단위로 통합하는 과정이다. 프로그램을 컴파일해 얻은 오브젝트 모듈은 프로그램의 소스 파일에서 얻은 프로그램 데이터와 명령어들을 포함한다. 만약 프로그램이 다른 모듈로부터 함수나 데이터를 참조하면, 컴파일러는 이런 참조 사항들을 외부참조로 변환한다. 또한 프로그램이 다른 프로그램에서 사용할 수 있는 함수나 데이터를 만들면, 이런 함수나 데이터들은 각각 외부 명칭으로 제공된다. 오브젝트 모듈들은 이러한 외부 참조와 외부 명칭을 심볼 테이블이라는 자료 구조에 저장한다. 링커를 통해 생성한 통합된 모듈을 로드 모듈이라고한다. 링커의 입력 정보는 오브젝트 모듈, 로드모듈, 참조하는 라이브러리 파일의 위치등과 같은 제어 문장을 포함할 수 있다. 링커는 종종 한프로그램을 형성하는 오브젝트 파일을 몇개 제공받는다. 이 오브젝트 파일들은 일반적으로 상대 주소라는 각 파일의 상대적인 시각 주소를 사용해 데이터와명령어들의 위치를 명시한다.


프로그램이 링크되는 시점은 환경에 따라 다르다. 프로그래머가 모든 필요한 코드를 소스파일에 포함한 경우에는 외부 명칭에 대한 참조가 없기 때문에, 컴파일 시점에 링크될 수 있다. 외부에서 참조하는 심볼이 있는지 소스코드를 조사하고 이러한 심볼을 결과 오브젝트 파일에 두는 것이다. 많은 프로그램에서 공유라이브러리에 의존하므로 이러한 방식은 적절하지 않다. 공유 라이브러리는 여러 다른 프로세스에서 공유할 수 있는 함수들의 집합이다. 많으 ㄴ프로그램이 입출력 스트림을다르는 함수등 동일한 함수를 오브젝트코드에 포함하지 않은 채 참조할 수 있다.  이러한 유형의 링킹은 주로 컴파일후 로딩전에 수행된다 . 

이와 똑같은 과정이 로드 시간에도 수행될 수도 있다. 링킹과 로딩이 모두 링킹로더 라는 응용프로그램으로 수행되기도 한다. 링킹으 ㄴ또한 실행시에 수행될수도있는데 이를 동적링킹이라고 한다. 이 경우 외부 함수 참조는 프로세스가 메모리에 로드되거나 함수 호출을 발생시키기 전까지는 결정되지 않는다. 이러한 방식은 다른 쪽에서 제어하는 대규모 프로그램에 유용하다. 동적으로 링크되는 프로그램은 사용하는 라이브러리가 수정되었을 때 다시 링크할 필요가 없기 때문이다. 더 나아가 메인 메모리에 있기 전에는 링크되지 않으므로 다른 프로그램 코드로부터 공유 라이브러리 코드를 분리해 저장할 수 있다. 몇개의 프로그램에서 사용하려고 하더라도 대상 공유 라이브러리 사본을 하나만 저장하고 있기 때문에 동적 링킹은 2차저장소의 공간도 절약해준다. 


### 2.8.3 로딩

링커는 일단 로드 모듈을 생성하고 나면 로더 프로그램에 보낸다. 로더는 각명령어와 데이터 유닛을 특정 메모리 주소에 배치하는 책임이 있다. 이를 주소 바인딩이라고 한다. 프로그램을 메인 메모리에 로드하는 방법은 여러가지인데, 대부분은 가상 메모리를 지원하지 않는 시스템에서만 중요하다. 로드 모듈이 이미 메모리에서 물리 주소를 명시하는 경우 로더는 단순히 명령어와 데이터를 프로그래머나 컴파일러가 명시한 주소에 두면 된다. 이를 절대 로딩이라고한다. 재배치 가능한 로딩은로드 모듈이 실제 메모리 주소로 변환해야하는 상대 주소를 포함할 때 수행된다. 로더는 프로그램을 둘 메모리 블록을 요청하고 프로그램의 주소를 메모리에 재배치해야한다. 


동적 로딩은 프로그램 모듈을 처음 사용하는 시점에 로딩하는 기술이다. 많은 가상 메모리 시스템에서 각 프로세스는 0에서 시작하는 자신의 가상 주소 집합을 가지고 있다. 그러므로 로더는 유효한 메모리 영역에 프로그램을 로딩해야한다. 


## 2.9 펌웨어

대부분의 컴퓨터는 하드웨어와 소프트웨어 외에도 펌웨어를 포함한다. 펌웨어는 종종 읽기 전용 메모리가부착된 영구 저장소에 저정되는 실행가능한 명령어들이다. 펌웨어는 마이크로 프로그래밍으로 프로그래밍하는데 이는 컴퓨터의 기계어보다 아래에있는 프로그래밍 계층을 말한다. 마이크로 프로그램명령어인 마이크로코드는 대체로 모든 기계어 연산을 구현하는데  필요한 간단하고 기초적인 명령어를 포함한다 . 예를 들어 전형적인 시스템 명령어중 하나로 하드웨어가 덧셈 연산을 수행해야하는 것을 생각해보자. 이 명령어를 위한 마이크로코드는 하드웨어가 수행해야할 실제 기본 연산을 명시한다. 예를 들면 현재 머신 명령어를 가리키는 참조 포인터를 하나 증가시켜 다음을 가리키게하는 연산, 각 수의 비트를 증가시키는 연산, 결과값을 새로운 레지스터에 저장한후 다음 명령어를 가져오는 연산 등이다.

## 2.10 미들웨어

소프트웨어는 많은 컴퓨터가 네트워크로 연결된 분산 시스템에서 중요한 역할을 한다. 분산 시스템을 구성하는 컴퓨터는 이기종 하드웨어와 운영체제, 다양한 프로토콜을 사용하는 서로다른 네트워크 아키텍처를 갖는 이기종 시스템인 경우가 많다. 분산시스템의 특성상 네트워크에서 여러 컴퓨터에서 실행되고 있는 프로세스들이 서로 상호 작용하려면 미들웨어  역할이 필요하다. 


미들웨어는 한 컴퓨터에서 실행하는 응용 프로그램이 원격 컴퓨터에서 실행하느 다른 응용 프로그램과 통신할 수 있게 해준다. 따라서 분산 시스템 환경의 컴퓨터 상이에 통신이 가능해진다. 또한 컴퓨터가 미들웨어를 설치하고 있으면 이기종 컴퓨터 플랫폼에서 응용 프로그램들을 실행할 수 있다. ODBC는 데이터베이스 API의 한 예이다. 


