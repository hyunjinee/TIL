# 하드웨어와 소프트웨어 개념

## 2.1 소개

컴퓨터 네트워크는 1초에도 수많은 계산과 트랜잭션을 수행한다. 휴대폰은 전화번호를 저장하고 문자 메시지를 주고바등며 심지어 사진과 비디오를 캡처하기도 한다. 이러한 컴퓨터 기기는 다양한 하드웨어와 소프트웨어를 포함하는데, 이 모든것을 운영체제에서 관리한다.

운영체제는 주로 자원 관리 임무를 맡고 있으므로, 운영체제를 설계할 때는 관리할 하드웨어와 소프트웨어 자원들과 밀접하게 연계해야한다. 이러한 자원으로 프로세서, 메모리, 하드디스크와 같은 2차 저장소등을 들 수 있다. 컴퓨터가 발전함에 따라 운영체제는 새로운 하드웨어와 소프투웨어 기술에 적응하고 이미 설치된 하드웨어나 소프트웨어 기반과도 양립할 수 있어야한다.



## 2.2 하드웨어 장치의 발전

응용 프로그램들의 요구가 증가해 컴퓨팅 기술이 진화하는 것인가, 아니면 기술이 발달해 더 혁신적이고 새로운 응용프로그램이 나오는 것인가?

원래 시스템 프로그래밍은 하드웨어을 관리하고 프로그램에 서비스를 제공하도록 코딩하는 것으로, 비교적 간단하고 분명한 일이었다. 운영체제에서 소수의 프로그램과 하드웨어 자원을 관리했기 때문이다. 운영체제는 응용 프로그래밍을 가능하게 해준다. 개발자들은 장치를 다루는 코딩을 직접하지 않고 운영체제에 서비스를 요청애 문서를 편집하거나 웹페이지를 로드하는등 목표하는 일을 수행하는 응용 프로그램을 작성할 수 있게 해준다. 운영체제에서 특정 장치를 대상으로 입출력할 때에는 보통 해당 하드웨어 제조사가 제공한 디바이스 드라이버를 사용한다. 이처럼 운영체제가 새로운 장치를 지원할 때는 이에 맞는 적절한 디바이스 드라이버를 사용한다. 

> 고든 무어와 무어의 법칙

프로세서의 트랜지스터 수는 해마다 약 두배 정도로 증가한다. 트랜지스터는 전기의 흐름을 제어하는 작은 스위치이다. 스위치가 빨리 꺼졌다 켜질수록 프로세서는 그만큼 빨리 동작할 수 있다. 트랜지스터가 많아질수록 프로세서가 한번에 더 많은 작업을 처리할 수 있다. 무어는 약 10년동안 트랜지스터 수가 증가할 것이라고 예견했다. 현재는 프로세서 성능이 대략 18개월마다 배가되고, 트랜지스터 수는 24개월마다 배가되고있다. 이를 가능하게 하는 것은 프로세서에 사용하는 트랜지스터 가격이 기하급수적으로 감소한다는 점이다. 최근 나노 기술의 발달 덕분에 반도체 제조업체는 원자 몇개로 이루어진 트랜지스터를 만들게 되었다. 그러나 머지않아 연구자들은 트랜지스터를 설계할 때 원자의 크기 때문에 제한을 받게 될 것이다. 




많은 하드웨어 구성요소가 운영체제의 확장성을 지원하는 방식으로 운영체제와 상호작용하도록 설계되었다. 예를들어 플러그 앤 플래이 장치는 컴퓨터에 연결할 때 자신이 어떤장치인지 운영체제에 알리게 되어있다. 따라서 운영체제는 사용자 입력 없이도 적합한 장치를 선택해 사용할 수 있고 새로운 장치를 설치하는 과정도 간편해졌다. 
사용자 관점에서 볼 때 시스템에 추가하는 장치들은 대부분 사용 준비가 되어있다. 

## 2.3 하드웨어 구성요소

컴퓨터 하드웨어는 프로세서 메인메모리 입출력 장치 같은 물리적인 장치로 구성된다. 

### 2.3.1 메인보드

컴퓨터 시스템의 요구를 충족하기 위해 많은 하드웨어 장치와 상호작용한다. 독립된 컴퓨터는 장치들과 통신하기 위해서 여러 인쇄 회로 기판을 갖추고 있다. PCB는 보드 여기저기에 위치한 장치들을 전기적으로 연결해주는 하드웨어 구성 요소이다. (printed circuit board)

메인보드는 시스템 중심 PCB로 컴퓨터에서 중추적인 역할을 한다. 메인보드는 프로세서나 메인 메모리를 포함한 여러 하드웨어 구성요소를 꽂을 수 있는 슬롯을 내장한다. 슬롯은 다양한 하드웨어 구성 요소를 전기적으로 연결하고, 사용자가 슬롯에 장치를 추가하거나 제거해 컴퓨터 하드웨어의 구성을 필요에 따라 변경할 수 있게 해준다. 메인보드는 범용 컴퓨터에서 요청받은 명령어를 실행하는데 필요한 네가지 하드웨어 구성 요소중 하나다. 남은 세가지는 프로세서와 메인메모리, 2차저장소이다. 

전통적인 금속선은 오늘날의 시스템에서처럼 여러 구성요소를 연결하기에는 너무 크다. 따라서 메인보드를 아주 가는 실리콘층으로 구성하는 것이 보통이다. 실리콘에는 트레이스라는 아주 작은 전기적 연결선이 들어있어서 통신 채널 역할을 하고 보드에 연결된다. 이 트레이스의 집합체로 버스라는 고속 통신 채널을 만든다.

대부분의 메인보드는 저수준 기능을 담당하는 컴퓨터 칩을 몇개 포함한다. 예를 들어 메인보드는 바이오스 칩을 포함해 기본적인 하드웨어 초기화와 관리를 위한 명령어를 저장하는 것이 보통이다. 바이오스는 또한 운영체제의 초기부분을 메모리에 로드하는 역할을 하는데 이를 부트 스트랩핑이라고한다. 운영체제를 메모리에 로드하고 나면 바이오스를 사용해 시스템 하드웨어와 통신하여 저수준 입출력을 수행할 수 있다. 메인보드는 또한 컨트롤러라는 칩을 포함한다. 컨트롤러는 보드의 버스를 통해 데이터이동을 관리한다. 메인보드의 칩셋은 컨트롤러, 보조프로세서, 버스같은 하드웨어의 집합으로 메인보드에 통합되어 시스템의 하드웨어 능력을 결정한다. 

최근에는 메인보드를 설계할때 , PCB에 강력한 하드웨어 구성요소를 통합하는 경향이있다. 전통적으로는 이들 요소를 애드온 카드 형태로 슬롯에 삽입했다. 오늘날 많은 메인보드가 그래픽 프로세싱과 네트워킹, RAID기능을 수행하는 칩을 포함한다. 이러한 온보드 장치는 전체적인 시스템 비용을 줄이고 컴퓨터 가격을 큰포긍로 낮춘다. 

### 2.3.2 프로세서

프로세서는 일련의 기계어 명령어를 실행하는 하드웨어 구성요소다. 프로세서는 컴퓨터에서 중앙처리장치, 그래픽 보조 프로세서 또는 디지털 신호처리기 등 여러 형태를 띨 수 있다. CPU는 프로그램의 명령어를 실행하는 프로세서다. 그래픽이나 디지털 신호 처리기 등의 보조 프로세서는 3D변환 같은 특수 목적 명령어들을 효율적으로 실행할 목적으로 설계되었다. 임베디드 시스템에서는 DSP와 같이 프로세서가 디지털 신호를 아날로그 오디오 신호로 변환하는등의 특정한 임무를 수행하기도 한다. CPU는 시스템의 주요 프로세서로 많은 명령어를 실행할 수도 있지만, 계산 강도가 높은 특정 업무들은 해당 부분만 전문적으로 다루는 보조 프로세서에 넘겨서 효율성을 높일수 있다.

프로세서가 실행할 수 있는 명령어는 해당 명령어 집합이 어떤지에 따라 정의된다. 각 명령어의 크기는 아키텍처에 따라 다를 수 있다. 때로는 한 아키텍처의 프로세서가 다양한크기의 명령어를 지원하기도 한다. 프로세서 아키텍처는 또한 한번에 실행할 수 있는 데이터의 단위를 결정한다. 예를 들어, 32비트 프로세서는 32비트 단위로 데이터를 조작한다.

현재 사용하는 프로세서는 하드웨어에서 많은 시스템의 자원 관리 연산을 수행해 성능을 향상시킨다. 이러한 기능으로 가상메모리 하드웨어 인터럽트 지원이 있다. 

다양한 프로세서 아키텍처에도 불구하고 몇가지 구성요소는 현태의 프로세서에 공통적이다. 이러한 구성요소로는 명령어 페치기, 분기 예측기, 실행처리기, 레지스터, 캐시, 버스 인터페이스 등이 있다. 명령어 페치기능 명령어 레지스터라는 고속의 메모리에 명령어를 로드해 프로세서가 명령어를 빨리 실행할수 있게해준다. 명령어 해석기는 명령어를 해석하고 이에 해당하는 입력 정보를 실행 처리기에 전달한다. 실행처리기의 주요 부분은 산술 논리 장치다. ALU는 덧셈, 곱셈과 같은 기본적인 산술 연산과 대소비교같은 논리연산을 수행한다. 

버스 인터페이스는 프로세서가 메모리나 다른 장치들과 상호작용 할 수 있게 해준다. 프로세서는 보통 메인 메모리보다 훨씬 빠른 속도로 작동하므로, 시스템은 캐시라는 고속메모리를 포함한다. 캐시는 메인메모리에 있는 데이터의 복사본을 저장하는 메모리로, 프로세서의 데이터와 명령어에 빠르게 접근할 수 있게해서 효율을 높여주다.

고속 캐시는 메인 메모리보다 훨씬 비싸기 때문에 보통은 용량이 제한되기 마련이다. 캐시는 여러 수준으로 분류된다. 
L1캐시는 가장 빠르고 비싸며 프로세서에 위치한다. L2캐시는 L1캐시에 비해 비용이 저렴하고 용량이 크며, 흔히 메인보드에 위치한다. 하지만 성능 향상을 위해 점점 프로세서에 통합되고있다.

레지스터는 프로세서에 위치한 고속메모리로, 프로세서가 바로 사용할 수 있는 데이터를 담는다. 프로세서가 데이터를 조작하려면 해당 데이터가 레지스터에 위치해야한다. 프로세서 명령어를 다른 저속 메모리에 로드하는 일은 비효율적이다. 프로세서가 데이터에 접근하는 것을 기다리는 동안 쉬고 있어야하기 때문이다. 레지스터는 프로세서 회로에 프로그램이 아닌 물리적인 방시긍로 배선 처리가 되어있고 , 처리기 가까이에 위치해 L1 캐시에 접근하는 것보다도 빠르다. 레지스터의 크기는 프로세서가 한번에 처리할 수 있는 비트수에 따라 결정된다. 예를 들어 32비트 프로세서는 각 레지스터에 32비트 데이터를 로드한다. 오늘날 개인용 컴퓨터는 대부분 32비트 프로세서를 사용한다. 64비트 프로세서도 점점 많아지고 있다.

각 프로세서 아키텍처마다 제공하는 레지스터수가 다르고 각 레지스터는 특정 목적을 위해서 서비스를 제공한다. 예를 들어 인텔 펜티엄 4프로세서는 16개의 프로그램을 실행하는 레지스터를 제공한다.  이 레지스터의 절반은 응용 프로그램이 데이터 값이나 실행중 포인터 값을 빠르게 읽어야할 때 사용하려고 별도로 예비해두는 경우가 많다. 이런 레지스터를 범용 레지스터라고한다. 애플의 G5컴퓨터에 사용된 IBM의 PowerPC970 프로세서는 범용 레지스터 32개를 포함한다. 다른 레지스터는 보통 컨트롤 레지스터라고 하며, 다음 실행할 명령어가 무엇인지 알려주는 프로그램 카운터등 시스템에 관한 정보를 저장한다.

### 2.3.3 클록

컴퓨터 시간은 흔히 사이클을 통해 측정한다. 사이클은 시스템 클록 생성기가 보낸 전기 신호의 한 진폭을 말한다. 클록 생성기는 마치 오케스트라의 지휘자와 같이 컴퓨터 시스템의 리듬을 형성한다. 특히 클록 생성기는 버스가 데이터를 나루는 주기를 결정한다. 이는 대체로 초당 사이클수 , 즉 헤르츠로 측정한다. 예를 들어 프론트사이드버스는 프로세서들을 메모리 모듈에 연결하는데, 흔히 몇백 메가헤르츠 정도로 작동한다.
프로세서와 다른 장치는 프론트사이드버스의 속도를 나누거나 곱해 도출속도를 생선한다. 예를 들어 200MHz프론트사이드 버스를 사용하는 2GHz프로세서는 사이클을 생성하기위해 10배수를 곱하고 66MHz사운드 카드인 경우 사이클을 생성을 위해 2.5로 나눈다.

### 2.3.4 메모리 계층

메모리의 속도나 크기는 물리적, 경제적 여건 때문에 제한된다. 대부분의 전자장치는 PCB 의 트레이스를 통해 전자를 보내는 방식으로 데이터를 이동한다. 전자가 이동할 수 있는 속도에도 제한이있다. 두 단말 사이으이 선이 길수로 데이터 이동시간이 길다. 게다가 프로세서에 근접한 속도로 데이터 요청에 응할 만큼 빠른 메모리를 넉넉하게 구비하는 것은 비용이 너무 많이 들어 거의 불가능한 일이다. 

비용과 성능의 상충성 때문에 메모리 계층이 생긴다.  가장 빠르고 비싼 메모리는 최상위 계층에있고, 대개 용량이 작다. 최하위에있는 것은 가장 저렴하고 속도가 느린 메모리로, 대체로 크 ㄴ용량을 갖는다. 아래쪽에 있는 느린 메모리 계층으로 갈수록 블록의 크기가 점점 증가한다. 그러나 일정한 규모가 아닌 피라미드 형태로 증가한다.

레지스터는 시스템에서 가장빠르고 비싼 메모리이다. 레지스터는 프로세서와 같은 속도로 작동한다. 캐시메모리의 속도는 지연시간, 즉 데이터를 이동하는데 소요되는 시간으로 측정한다. 지연시간은 대체로 나노초또는 프로세스 사이클로 측정한다. 

계층에서 다음단계는 메인메모리로 실제메모리라고도한다. 레지스터 캐시, 메인메모리는 대체로 휘발성 매체로 전원을 끄면 데이터가 사라진다.

하드 디스크와 cd, dvd,테이프 같은 다른 저장장치들은 가장 느리고 값이 저렴한 데이터 저장 매체다. 디스크 저장장치의 지연시간은 대개 밀리초단위며, 보통 프로세서 캐시지연시간보다 백만배 저도 느리다. 운영체제는 프로세스가 2차 저장소로 부터 데이터가 오기를 기다리는 동안 쉬게하기 보다는 대개 다른 프로세서를 실행하게해서 프로세서 활용도를 높인다. 하드 디스크와 같은 2차 저장소의 주요 장점은 용량이 크다는 점이다. 

또한 2차 저장소는 데이터를 영구적으로 저장할 수 있다. 따라서 전원이 나가도 2차 저장소의 데이터는 사라지지 않는다. 시스템 설계자는 사용자의 요구를 충족하도록 다양한 저장장치의 비용과 성능 사이의 균형을 맞춰야한다.

> 캐싱 Caching

캐싱은 일상생활에서 늘 사용하는 것이다. 일반적으로 말하면 캐리란 재빨리 접근할 수 있는 예비 물품 저장소이다. 다람쥐가 겨우살이를 준비하려고 도토리를 저장하는 것도 일종의 캐싱이다. 운영체제는 프로그램이 실행할 때 빠르게 접근할 수 있게 프로세서의 데이터와 명령어를 고속 캐시 메모리에 캐시하거나, 디스크에 있는 데이터를 메인 메모리에 캐시하는 등 다양한 캐싱 기술을 이용한다.

운영체제 설계자들은 캐싱 기술을 사용할 때 주의해야한다. 컴퓨터 시스템에서 캐시된 데이터는 상위 메모리 계층에 유지되는 원본 데이터의 사본이기 때문이다. 캐시된 사본은 변경 사항이 가장 먼저 적용되므로 원본데이터와 금방 달라지기 쉽다. 따라서 데이터의 일관성이 깨질 우려가있다. 캐시에 갱신된 데이터가 있고 원본을 미처 갱신하지 못한채 시스템이 다운되면 수저오딘 데이터를 잃는다. 그러므로 운영체제는 캐시된 데이터를 원본데이터에 빈번하게 복사한다. 이러한 과정을 캐시 플러싱이라고한다. 분산파일시스템은 서버와 클라이언트 모두에 캐시를 둘 때가 많다. 이는 캐시 데이터와 원본데이터의 일관성 유지를 더욱 복잡하게 만든다.



### 2.3.5 메인 메모리

메인 메모리는 휘발성 임의 접근 메모리이다. 임의라함은 프로세스가 어떤 순서로든 데이터에 접근할 수 있다는 의미이다. 이와 대조적으로 테이프와 같은 연속적인저장 매체는 순차적으로 읽어야한다. 메인 메모리에 접근하는데 걸리는 지연시간은 테이프나 하드디스크와 달리 어느 위치든 동일하다.

RAM의 가장 흔한 형태는 동적램이다. DRAM은 재생회로에서 일정 주기마다 데이터를 읽어야한다. 이렇게 하지 않으면 데이터를 손실하게 된다. 정적 램은  이와 달리 저장하는 데이터를 유지하려고 다시 읽을 필요가 없다. SRAM 은 주로 프로세서 캐시로 사용하며, DRAM보다 빠르고 비싸다.

DRAM제조사들의 중요한 목표는 프로세서의 속도와 메모리 전환속도의 간격을 줄이는데 있다. 메모리 모듈은 모듈안에서 데이터 접근 지연 시간을 최소화하고 초당 데이터 이동량을 늘리는 쪽으로 설계된다. 이러한 기술은 전반적인 지연시간은 줄이고 대역폭은 높인다. 


### 2.3.6 2차 저장소

컴퓨터에서 데이터 파일이나 응용 프로그램 소프트웨어등 대용량 데이터를 영구적으로 보관하려면 전원이 나간 후에도 데이터를 영구 저장할 수 있는 2차 저장소또는 보조 저장소를 사용한다. 대부분의 컴퓨터는 2차저장소로 하드디스크를 사용한다. 하드디스크 드라이브는 RAM보다 저렴한 비용으로 더 많은 양을 저장할 수 있지만, 메인메모리에 접근하는 것보다 속도가 현저히 느리기 때문에 주 메모리로 사용하기에는 실용성이 떨어진다. 

몇몇 2차 저장장치는 데이터를 용량이 작은 매체에 저장한다. 이들 매체는 컴퓨터에서 제거할 수 있고 컴퓨터간에 데이터를 백업하거나 이동할 수 있게해준다. 어떤 시스템은 2차 저장소를 넘어서는 수준의 메모리를 갖추고있다. 예를 들어, 대용량 데이터를 처리하는 시스템은 종종 로봇 팔로 접근하는 테이프 라이브러리를 갖추고 있다. 이러한 저장 시스템은흔히 3차저장소로 분류하며 2차저장소보다 대용량이고 접근 시간이 긴 것이 특징이다. 

### 2.3.7 버스

버스는 하드웨어 장치간에 정보를 나르는 트레이스의 집합 혹은 전기적 연결이다. 하드웨어 장치는 다른 장치와 통신할 때 버스를 통해 전기 신호를 보낸다. 대부분의 버스는 데이터를 나르는 데이터버스, 해당 데이터의 위치나 수신위치를 결정하는 주소버스로 구성된다. 포트는 정확히 두 장치를 연결하는 버스다. 서너 개 장치에서 입출력 기능을 수행할 때 공유하는 버스는 입출력 채널이라고 한다.

앞에서 프론트 사이드 버스가 프로세서를 메인 메모리에 연결한다는 사실을 배웠다. FSB속도가 증가하면 메인 메모리와 프로ㅔㅅ서 사이에 전송되는 데이터양이 증가해 성능이 향상된다. 버스의 속도는 MHz로 측정한다. 몇몇 칩셋은 클록 사이클 당 메모리 전송을 두번 수행해 200MHz 가 400MHz로 작동하도록 구현한다. 이런 특징은 칩셋과 램 모두에서 지원해야하며 DDR이라고한다. 

### 2.3.8 직접 메모리 접근

대부분의 입출력 연산은 메인메모리와 입출력 장치 사이에서 데이터를 전송한다. 초창기 컴퓨터는 프로그래밍된 입출력을 사용해 데이터 전송을 수행했다. 

1. 프로세서는 입출력 컨트롤러에 입출력 요청을 보내고, 입출력 컨트롤러는 해당 요청을 디스크에 보냄,. 프로세서는 계속해서 다른 명령을 실행
2. 디스크는 입출력 컨트롤러에 데이터를 보냄. 이 데이터는 DMA명령이 지정한 메모리 주소에 위치함
3. 디스크는 프로세서에 인터럽트를 보내어 입출력이 완료되었음을 알림

레거시 하드웨어와 소프트웨어

최신 버전의 운영체제는 가장 최근의 하드웨어와 소프트웨어의 기능을 지원하도록 설계된다. 그러나 거기있는 대다수의 하드웨어와 소프트웨어는 개인이나 기관이 투자를 많이한 오래된 장비나 응용 프로그램인 경우가 많고 새로운 운영체제가 설치되더라도 계속 사용되길 원할 때가많다. 이처럼 오래된 항목을 레거시 하드웨어, 레거시 소프트웨어라고 한다. 운영체제 설계자가 맞닥뜨린 커다란 도전거리는 그와 같은 레거시 시스템을 지원할 수 있도록 하는 것으로, 실게계에서 사요오딜 운영체제라면 반드시 갖추어야할 조건이다.


### 2.3.9 주변장치

주변장치란 컴퓨터가 소프트웨어 명령어를 실행하는데 필수적이지 않은 하드웨어를 말한다. 주변장치는 프린터나 스캐너, 마우스등 다양한 입출력 장치와 네트워크 인터페이스 카드, 모뎀같은 네트워크장치등을 가리킨다. 프로ㅔㅅ서나 메인보드, 메인메모리는 주변장치에 속하지않는다. 아마도 가장 보편적인 주변장치는 하드디스크일 것이다. 



## 2.4 하드웨어의 운영체제 지원

컴퓨터 아키텍처는 성능 향상을 위해 운영체제가 더 빨리 기능할 수 있도록 하드웨어적으로 지원하는 몇가지 기능을 포함한다. 또한 운영체제가 엄격한 방어체계를 갖추어 시스템의 보안과 무결성을 보장하도록 한다.

### 2.4.1 프로세서

대부분의 운영체제는 프로세서를 통해 보호 메커니즘을 구현한다. 프로세서는 프로세스가 할당받지 않은 메모리에 접근하는 일을 막는다. 프로세스가 시스템의 보호 메커니즘을 위반하려고 하면 프로세서는 이를 운영체제에 알려 적절히 반응하게한다. 또한 프로세서는 하드웨어 장치에서 보내는 신호에 반응하도록 운영체제를 호출한다.

컴퓨터 시스템은 흔히 몇가지 다른 실행 모드가 있다. 시스템의 모드를 변경함으로써 더 견고하고 장애 내구성이 있고 안전한 시스템을 만들수 있다. 흔히 시스템이 특정 모드에서 동작할 때 응용 프로그램들은 시스템 명령어의 하위 집합에만 접근할 수 있다. 사용자 응용프로그램에서는 사용자가 사용자모드로 실행할 수 있는 명령어의 부분집합에서 입출력 명령어를 직접 실행하는 일등은제외한다. 
컴퓨터 아키텍처가 진화하면서 특권 명령어 즉, 사용자 모드에서는 접근할 수 없는 명령어의 수가 증가하는 점은 주목할 만한 일이다. 이는 하드웨어에 운영체제와 협력하는 기능이 더욱 증가하는 경향을 보여준다.

대부분의 프로세서는 메모리 보호와 관리 메커니즘을 제공한다. 메모리 보호는 프로세스가 다른 사용자의 메모리나 운영체제의 메모리 등 자신이 할당받지 않은 메모리에 접근하는 것을 방지한다. 메모리 방지 기능은 특권 명령어로만 수정할 있는 프로세서 레지스터를 사용해 구현한다. 프로세서는 이러한 레지스터들의 값을 확인해 프로세스가 자신이 할당받지 않은 메모리에 접근하지 못하게 한다. 예를 들어 가상메모리를 사용하지 않는 시스템에서는 프로세스들이 메모리 주소의 연속적인 블록만 할당받는다. 시스템은 프로세스가 할당받은 메모리의 시작과 끝 위치를 명시하는 경계 레지스터를 제공해 프로세스들이 자신이 할당 받지 않은 메모리 위치에 접근하는 것을 막는다. 특정 주소가 할당된 블록 안에 있는지 확인해 메모리 보호를 강화할 수도 있다. 대부분의 하드웨어 보호는 프로그램 명령어를 실행하는 것과 병행해 수행되므로 성능 저하를 야기하지 않는다. 대부분의 프로세서는 또한 프로세스에서 참조하는 가상 메모리 주소를 대응하는 메인 메모리 주소로 해석하는 하드에어를 포함한다. 가상 메모리 시스템은 프로그램이 메인 메모리에 있는 제한된 일련의 실제 주소에 대응하지 않아도 되는 주소를 참조할 수 있게 해준다. 

> 최소 권한의 원칙

일반적으로 볼 때 최소 권한의 원칙이란 어떤 시스템이든 다양한 객체에 자기 임무를 수행하는데 필요한 능력 이상을 부여하면 안됨을 나타낸다. 정부에서도 보안 허가에 이 원칙을 적용한다. 누군가에게 내 집을 드나들도록 여분의 열쇠를 줄 때도 이런 원칙을 적용할 것이다. 운영체제는 하드웨어를 사용해 실행시 프로세스의 가상 주소를 물리 주소로 바꿔준다. 가상 메모리 시스템은 프로세스가 메인 메모리에서 사용 가능한 것보다 훨씬 많은 공간의 주소를 참조할 수 있게 해준다. 따라서 프로그래머들은 물리적 메모리 제한에 구애받지 않고 응용 프로그램을 작성할 수 있다. 가상 메모리는 또한 시분할 시스템을 위한 프로그램을 가능하게 해준다. 프로세스들이 메인 메모리에 있는 데이터의 실제 위치를 알 필요가 없기 때문이다. 

프로세서는 운영체제에 프로그램 실행중 발생하는 오류나 장치의 상태변화등 여러 이벤트를 알려준다.  프로세서는 각 장치의 상태를 반복적으로 확인하는 폴링이라는 기술을 통해 이렇게 할수 있다. 그러나 장치에 변화가 없는데도 이렇게 상태를 계속해서 확인하면 상당한 실행부하를 주게된다.


대부분의 장치는 이런 방법 대신 이벤트가 발생할 때 프로세서에 인터럽트라는 신호를 보낸다. 
그러면 운영체제는 이에 반응하여 해당 유형의 이벤트를 기다리고 있는 프로세스에 알려준다. 예외는 하드웨어 고장이나 로직오류, 보안규칙위반 같은 여러 오류에 대한 반응으로 발생하는 인터럽트다. 프로세서는 시스템이 다운되지 않게 하려고 보통은 운영체제를 호출해 반응할 방법을 결정하게 한다. 예를 들어 운영체제는 오류를 유발하는 프로세스를 종료하거나 시스템이 다시 시작하게 할 수도 있다. 만약 시스템이 다운되어야 한다면 운영체제는 작업 손실을 최소화하도록 우아하게 종료할 수 있다. 프로세스는 운영체제에 예외 처리기를 등록할 수도 있다.


> 보호

초창기 컴퓨터에있던 원시적인 운영체제는 한번에 한가지 작업만 실행할 수 있다. 하지만 지역 시스템에 병렬 처리 능력이 추가되고, 네트워크를 통해 병렬 처리가 가능한 분산 시스템이 개발되면서 급격하게 변했다. 운영체제는 다양한 유형의 보호, 특히 인터넷에 연결할 때 시스템 보호를 신중하게 고려해야한다. 운영체제와 그 데이터가 우연이든 고의든 잘못된 사용자 프로그램 때문에 손상받지 않도록 보호해야한다. 사용자 프로그램 역시 서로를 방해하지 않게 보호해야한다. 지역 시스템과 사용자 그리고 네트워크에 퍼져 있는 컴퓨터 운영체제 구성 요소 모두 이런 보호가 필요하다. 



### 2.4.2 타이머와 클록

간격 타이머는 주기적으로 인터럽트를 발생시켜 프로세서가 운영체제를 호출하게한다.  운영체제는 이 타이머를 사용해 특정 프로세스가 프로세서를  독점하는 것을 막는다. 예를 들면 운영체제에서 타이머가 인터럽트를 보내올 때 현재 프로세스를 제거하고 다른 프로세스가 프로세서를 사용할수 있게한다. 시간 클록은 컴퓨터가 수천초분의 1 또는 수만초분의 1정도의 오차안에서 정확한 실제시간을 따라잡을 수 있게한다. 몇몇 시간 클록은 배터리 충전기를 포함하고 있어서 외부 전력 공급이 없을 때도 정확하게 작동하기도한다. 이러한 클록은 시스템의 연속성을 유지하는 수단이된다. 

### 2.4.3 부트스트랩핑

운영체제에서 자원을 관리하려면 먼저 자신이 메모리에 로드되어야한다. 컴퓨터를 켜면 바이오스가 시스템 하드웨어를 초기화하고 플로피디스크나 하드디스크 cd같은 2차 저장소에 있는 부트섹터에서 명령어들을 읽어 메인 메모리에 로드한다. 이과정을 부트 스트랩핑이라고한다. 프로세서는 이러한 명령어를 실행하도록 만들어진다. 이때 실행하는 명령어는 대개 운영체제의 구성 요소를 메모리에 로드하고, 프로세서 레지스터를 초기화하며 시스템이 사용자 응용 프로그램을 실행할 준비를 하게하는 것이다. 


1. 하드웨어 정보를 수집하고 시스템을 초기화함
2. 부트섹터에서 데이터를 읽어 메인 메모리에 로드
3. 프로세서가 부트스트랩 코드를 실행함
4. 디스크에서 운영체제를 읽어 로드함

많은 시스템에서 바이오스를 통해 몇몇 장치들의 미리 정의된 위치에서 운영체제를 읽어 로드한다. 만약 해당 장치에서 부트 섹터를 찾지 못하면 시스템을 로드하지 못하고 사용자는 컴퓨터의 어떤 하드웨어에도 접근할 수 없게된다. 인텔은 부팅시에 더 많은 기능을 지원하려고 바이오스대신 확장 펌웨어 인터페이스를 개발했다. EFI는 셸을  지원해 사용자들이 컴퓨터 장치에 직접 접근할 수 있게하고 컴퓨터 전원이 들어오는 즉시 디바이스 드라이버들이 하드 드라이브와 네트워크에 접근할 수 있도록 돕는다.


### 2.4.4 플러그 앤 플레이

플러그앤 플레이 기술은 운영체제가 새로 설치한 하드웨어를 사용자와 교류없이 자동으로 인식하고 사용가능하게해준다. 
1. 운영체제에서 자신이 어떤 장치인지 유일하게 식별할수 있게한다.
2. 운영체제와 통신해 해당 장치가 올바르게 작동하는데 필요한 자원과 서비스를 요청할 수 있다.
3. 해당 장치와 대응하는 드라이버를 식별하고 운영체제가 해당 드라이버를 ㅏㅅ용해 장치를 구성할 수 있게해준다. 


분산 컴퓨팅이 확산되면서 점점 많은 시스템이 전력 공급을 충전기에 의존한다.그 결과 플러그앤 플레이 기술도 전력관리 기능을 갖추어 시스템이 전력 소비 상태에 동적으로 적응해 배터리 수명을 연장할 수 있게한다. 고급 구성 및 전원 인터페이스는 운영체제가 장치들을 구성하고 전력 소비를 관리하는 표준을 정의하고 있다. 

## 2.5 캐싱과 버퍼링

대부분의 시스템은 성능을 향상시키려고 캐싱을 수행한다. 프로세스가 참조하는 데이터를 더 빠른 저장공간에 복사하는 것이다. 그러나 빠른 저장소일수록 비싸기 때문에 캐시할 수 있는 데이터양이 제한된다. 따라서 캐시엔트리를 잘관리해 참조하는 정보가 캐시메모리에 없는 경우 의 수를 최소화해야한다. 캐시 실패가 발생하면, 시스템은 속도가 낮은 원래의 저장소에서 참조하는 정보를 얻어와야한다. 참조하는 정보가 캐시 메모리에 있는 경우를 캐시 적중이라고하며, 이 경우 시스템은 비교적 빠른 속도로 필요한 데이터에 접근할 수 있다. 

캐싱을 통해 성능을 향상시키려면 메모리 참조의 상당수가 캐시 적중되어야한다. 프로세스들이 곧 어떤 데이터를 참조할지 예측하기는 어렵다 그러므로 대부분의 캐시는 경험과 통계에 근거해 경험적 방법을 사용한다. 즉 직적의 정보를 분석해볼 때 비교적 적은 실행 부하로 좋은 결과를 얻었다면, 이를 근사치로 활용해 다음에 참조할 데이터를 예측한다.

버퍼는 장치들 사이 혹은 서로 다른 속도로 동작하는 프로세스들 사이에서 데이터를 전송할 때 일시적으로 데이터를 보관하는 저장 영역을 말한다. 버퍼는 소프트웨어와 하드웨어 장치들이 데이터를 비동기적으로 (즉 의존하지 않고 독립적으로) 전송하게 함으로써 시스템 성능을 향상시킨다. 버퍼에는 하드디스크 버퍼, 키보드 버퍼, 프린터 버퍼등이 있다. 하드디스크는 메인 메모리보다 훨씬느리게 동작하므로 운영체제는 대개 쓰기 요청된 데이터를 버퍼링한다. 버퍼는 하드디스크에 쓰기 작업을 마칠 때까지 데이터를 보관해 운영체제가 입출력 작업 중에도 다른 프로세스를 실행할 수 있게 해준다. 키보드 버퍼는 프로세스에서 인식하고 대응하는 키보드 인터럽트에 반응할 때까지 사용자가 입력한 글자를 보관한다. 

스풀링은 한 프로세스와 저속 또는 버퍼가 제한된 입출력장치 사이에 디스크와 같은 중간 매개체를 두는 기술이다. 예를 들어, 한 프로세스가 인쇄를 시도하는데 프린터가 다른 문서를 인쇄하고 있다면, 프로세스는 프린터를 사용할 수 있게 될 때까지 기다리는 대신 출력물을 디스크에 쓴다. 프린터가 앞선 작업을 마치면 디스크에 있는 데이터를 인쇄하기 시작한다. 스풀링은 주변장치들이 곧바로 서비스를 수행할 준비가 안되어있을 때도 프로세스들이 제2, 제3의 서비스를 요청할 수 있게 해준다. 

## 2.6 소프트웨어 개관

프로그래밍 언어는 기계어나 어셈블리언어 또는 고급언어로 분류할 수 있다.


### 2.6.1 기계어와 어셈블리 언어

컴퓨터는 오직 자신의 기계어만 이해할 수 있다. 특정 컴퓨터 