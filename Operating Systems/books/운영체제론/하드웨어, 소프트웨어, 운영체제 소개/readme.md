# Introduction to Hardware, Software and Operating Systems


운영체제라는 용어에대한 정의를 내리고 하드웨어와 소프트웨어의 개념에 대한 기초를 제공하고 운영체제의 역사를 설명한다. 운영체제의 역사를 학습하면서 성능향상이라는 논제와 이를 위해 자원을 어떻게 관리해야 하는지 강조.
또한 하드웨어의 성능이 크게 향상됨에 따라 그 비용 또한 현격히 줄어드는 것을 볼 것이다.

운영체제가 하드웨어를 어떻게 관리하는지 하드웨어가 운영체제의 기능을 어떻게 지원하는지도 학습한다. 그리고 첫 번째 성능 향상 기술인 프로세스에 대해 살펴본다.

## 1.1 소개

오늘날 사용자는 초당 수십억개의 명령어를 실행하느 데스크톱 워크스테이션을 보유하고있고, 이미 초당 조 단위가 넘는 명령어를 수행하는 슈퍼컴퓨터가 만들어졌다. 이는 몇년전만해도 상상조차 못한 수치이다.

프로세서가 강력해지고 가격이 많이 낮아지면서 일상생활에서 거의 모든 영역에서 컴퓨터를 사용할 수 있게 되었다.
유무선 네트워크 아키텍처 덕분에 상호 연결성이 증가해서, 사용자가 아주 먼 거리에서도 즉시 통신할 수 있게 되었다. 인터넷과 월드 와이드 웹은 초당 엄청난 수의 트랜잭션을 서비스하는 거대하고 강력한 컴퓨터들의 네트워크에 대한 요구를 불러일으키며 비즈니스에 혁명을 가져왔다. 컴퓨터 네트워크는 지구의 기후 변화 모델이나 인공지능, 생생한 3D애니메이션과 같은 복잡한 연구와 시뮬레이션 프로젝트를 수행할 만큼 강력해졌다. 

## 1.2 운영체제란 무엇인가?

1960년대에는 운영체제의 개념이 하드웨어를 제어하는 소프트웨어 정도였다. 그러나 컴퓨터 시스템에 대한 견해가 많이 달라져 더 정확하고 풍부한 정의가 필요하게 되었다. 오늘날의 하드웨어는 수많은 응용 소프트웨어를 실행한다. 하드웨어 사용 효율을 높이려면 응용프로그램들을 동시에 실행하도록 설계해야한다. 결과적으로 운영체제라는 또 다른 계층의 소프트웨어에서 응용프로그램들을 하드웨어에서 분리하여 각 응용프로그램이 안전하고 효율적으로 돌아가도록 서비스를 제공한다.

운영체제의 핵심 구성요소를 담은 소프트웨어를 커널이라고한다. 거의 모든 컴퓨터 시스템에서 사용자가 문서를 출력하거나 프로그램을 실행하는 등의 동작을 요청하면 운영체제는 주어진 입력에 맞는 결과를 보장하도록 소프트웨어와 하드웨어를 조작한다.

운영체제는 기본적으로 자원관리자로, 프로세서, 메모리, 입출력장치, 통신 장치 같은 하드웨어 자원을 관리한다. 또한 하드웨어 처럼 물리적으로 만질수 없는 객체인 응용프로그램들과 기타 추상적인 소프트웨어 객체들도 관리해야한다.

## 1.3 초기역사: 1940 , 1950년대

운영체제는 지난 60여년동안 몇버느이 뚜렷한 변화를 보이며 발전해왔다.대체로 10년 단위로 컴퓨터 분야의 세대교체와 변혁이 이루어졌다고 볼수 있다. 40년초에는 초기 디지털 컴퓨터들이 운영체제를 포함하고 있지 않았다. 당시 기계들은 매우 원시적인 수준이어서 프로그래머들이 쭉 나열된 기계스위치를 조작해 기계어 프로그램을 한번에 한비트씩 입력해야했다. 그러다가 프로그래머들은 마침내 기계어 프로그램을 천공카드에 입력해 넣었다. (punched card)  이후 어셈블리 언어가 개발되어 영어와 비슷한 약어들을 사용해 컴퓨터의 기본 연산들을 나타냈고, 프로그래밍 절차가 많이 빨라졌다.

50년대 초에는 제너럴 모터스의 연구실에서 IBM701 컴퓨터용으로 최초의 운영체제를 개발했다. 50년대 컴퓨터는 대체로 한번에 한가지 작업만 수행했지만, 컴퓨터의 사용 효율을 극대화하려고 작업간 이동을 원활하게 하는 기술을 사용했다. 작업은 급여 대장이나 재고 목록과 같이 특정 계싼 작업에 대응하는 일련의 명령어로 이루어져있었고, 주로 사용자의 입력없이 몇분 몇시간 혹은 며칠에 걸쳐 수행되었다. 이러한 초기 컴퓨터를 단일 스트림 배치 처리 시스템이라고한다. single-stream batch-processing system . 프로그램과 데이터를 순서대로 테이프나 디스크에 로드해서 그룹 혹은 일괄로 처리하기 때문이다. 작업 스트림 프로세서는 작업을 제어하는 명령문들을 읽고 다음 작업을 위한 환경을 마련한다. 현재 작업이 종료하면 작업 스트림 리더가 다음 작업을 위한 제어문들을 읽어들이고 해당 작업으로 쉽게 전환할 수 있게 자질구레한 일들을 적절히 처리해준다. 1950년대의 운영체제들은 한 작업에서 다른작업으로 전환하는 시간을 줄여주긴 했지만 프로그래머들은 종종 메모리나 입출력 장치같은 시스템 자원을 직접 제어해야했다. 프로그래머들은 작은 용량을 고려해 제한된 작업을 수행하는 작은 프로그램을 만들 수 밖에 없었다.

## 1.4 60년대

60년대 역시 배치 처리 시스템이지만 여러 작업을 한번에 실행하면서 컴퓨터 자원을 더 효율적으로 사용했다. 시스템은 카드 리더기나 카드 펀치, 프린터, 테이프 드라이브, 디스크 드라이브 등 많은 주변 장치를 포함했다. 한 작업으로 시스템 자원을 효율적으로 사용하기는 어렵다. 대게는 프로세서를 잠시 사용한 후 시스템 주변 장치를 사용해 입출력 작업을 수행한다. 이때 프로세서는 입출력 작업이 끝날때 까지 쉬고 있을 수 밖에 없다. 

60년대 시스템은 특정 작업이 주변장치를 사용하고 있을 때 다른 작업에서 프로세서를 사용할 수 있게 해서 자원 활용도를 높였다. 여러 작업을 뒤섞어 실행하면 자원활용도를 최적화하는 것처럼 보인다. 주로 프로세서를 사용하는 작업을 프로세서 중심작업, 혹은 계산 중심 작업이라고 부른다. 한편 주로 주변장치를 사용해 입출력하는 시간이 많이 드는 작업을 입출력 중심 작업이라고부른다. 운영체제 설계자들은 이를 염두해두고한번에 여러 작업을 처리하는 멀티 프로그래밍시스템을 만들었다. 멀티프로그래밍 환경에서는 운영체제는 각작업 사이의 프로세서를 재빠르게 전환하며 주변 장치들을 사용하는 동안 여러 작업이 각자 맡은 일을 진행하게 한다. 시스템의 멀티 프로그래밍 정도란 동시에 몇가지 작업을 관리할 수 있는지 나타내는 척도다.

멀티프로그래밍 컴퓨팅 시스템에서는 자원 공유가 주요 목표중 하나다. 프로세서들이 자원을 공유할 때 각 프로세서가 특정 자원을 독점하기도하고 ,몇몇 프로세서는 결코 자기 차례를 만나지 못한채 대기만 할 수 있다. 이런 경우 해당 프로세서는 작업을 수행할 수 없게 되고 사용자는  그때까지 작업한 내용을 모두 날리고 처음부터 다시해야할 수 있다.

60년대에는 사용자가 자신의 작업을 지켜보며 직접 처리하지 않는 것이 보통이었다. 처리할 작업을 구멍을 뚫은 천공카드나 컴퓨터 테이프에 담아 제출하고, 시스템 운영자는 작업을 로드할 때까지 입력테이블에서  기다렸다. 

점점 발전하다가 이후에 더 발전된 운영체제가 개발되어 여러 대화식 사용자를 동시에 서비스하게 되었다. 대화식 사용자란 작업을 실행하는 동안 시스템과 상호 작용하는 사용자를 말한다. 60년대에는 사용자들이 단순단말기를 통해 컴퓨터와 통신할 수 있었는데, 활성 연결을 통해 컴퓨터에 직접 붙는 온라인 형태였다. 사용자가 현장에 자리해 컴퓨터와 상호 작용하므로, 시스템은 사용자의 요청에 신속하게 응답해야만 했다. 시분할 시스템은 여러 사용자가 동시에 컴퓨터와 상호 작용하게 할 목적으로 개발되었다.

시분할 시스템중 다수가 멀티모드 시스템, 즉 배치 처리와 함계 산업 공정제어 시스템등과 같은 실시간 응용 프로그램을 동시에 지원하는 시스템이었다. 실시간 시스템은 특정한 제한시간 안에 반응해야한다. 

배치 처리 작업에는 적절한 범위안에서 시간 지연을 허용하고, 사용자와 상호작용하는 응용프로그램에는 더 높은 수준의 서비스를 제공하며, 중대한 실시간 응용 프로그램에는 가장 높은 수준의 서비스를 제공하는등 차별을 둬야한다. 

이시기에 중대한 시분할 시스템이 개발되었는데, 바로 MIT ㅡ이  CTSS (compatible time-sharing system) , IMB의 (TSS timesharing system), 벨연구소가 개발한 멀틱스 시스템이다. 멀틱스 시스템 설계자들은 운영체제 환경에서 실행되는 프로그램에 처음으로 프로세스라는 용어를 사용했다. 사용자들은 동시에실행할 수 있는 여러 프로세스를 담은 작업을 제출할 때가 많았다. 

병행 프로세스들은 대체로 독립적으로 실행하지만, 멀티프로그래밍 시스템은 여러 프로세스가 협력해 공통 임무를 수행하게된다. 프로세스가 작업을 동기화하는 방법과 운영체제에서 이를지원하는 방법은 뒤에 나온다. 

처리시간이란 작업을 전송한후 결과를 돌려받기까지 걸린 시간을 의미한다. 이 처리시간은 이제 몇분에서 몇초로 줄어서 프로그래머들이 작은 오류를 고치느라 몇시간 혹은 며칠씩 기다리지 않아도된다.

시분할 시스템이 프로그램 개발에 기여한 가치는 MIT,GE,벨 연구소에서 CTSS 시스템을 이용하여 후속버전인 멀틱스를 개발할 때 잘 드러났다. 유닉스의 설계자들은 이 개발 경험을 통해 지식을 얻고 유닉스 시스템을 개발하기 위한 고급언어인 C언어를 만들어냈다 유닉스 기반운영체제로는 리눅스 BSD유닉스 등이있다. 가상 메모리를 갖춘 시스템에서는 프로그램이 메인 메모리에서 할당받은 실제메모리보다 많은 메모리 주소를 사용할 수 있다. 가상메모리 시스템은 프로그래머들이 메모리 관리라는 무거운 부담을 덜고 응용 프로그램 개발에만 집중할 수 있게 해준다.



## 1.5 70년대

멀티 프로그래밍 시스템으로 배치 처리와 시분할, 실시간 응용 프로그램을 지원했다. 또한 마이크로 프로세서 기술에 힘입어 개인 컴퓨팅이 태동하기 시작했다. 시분할 시스템은  60년대에 실험적으로 사용된 이후 70년대와서 견고해져 상용 제품으로 발전했다. 미국에서 컴퓨터간 통신이 점차 증가해 국방부의 TCP/IP통신표준이 널리 사용되게 되었고, 특히 국방 분야와 대학교 컴퓨팅 환경을 중심으로 널리 확대되었다.
그리고 제록스의 팔로알토 연구소에서 개발한 이더넷 표준 덕분에 근거리 환경 통신이 더 실제적이고 경제적으로 발전했다.

취약한 통신 매체를 통해 오가는 정보의 양이 점차 증가하면서 보안 문제가 대두되었고, 암호작성/해독기술이 크게 주목받기 시작했다. 지적 재산권을 보호받아야 하거나 사적인 데이터를 암호화해서 의도한 수신자 외에는 손상된 데이터조차 볼수 없게 정보를 감춰야 하기 때문이다.

70년대는 운영체제가 네트워킹과 보안을 아우르는 수준으로 발전했고 상업적인 요구를 충족할 만큼 성능이 개선되었다.

## 1.6 80년대

80년대는 개인용 컴퓨터와 워크 스테이션의 시대였다. 소형 컴퓨터의 중앙 처리 장치인 마이크로 프로세서 기술이 발전하여, 워크스테이션이라는 고성능 데스크톱 컴퓨터가 십여년 전의 메인 프레임만큼이나 강력해진 것이다. 81년에 IBM개인용 컴퓨터 출시, 84년에 애플의 매킨토시 개인용 컴퓨터가 출시. 시스템들이 통신 설비를 갖추면 서로 데이터를 빠르고 경제적으로 전송할 수 있다. 데이터를 중앙에 위치한 대형 컴퓨터로 가져오는 대신 필요한 위치마다 컴퓨터를 놓을 수 있게 되었다. 개인용 컴퓨터는 익히고 사용하기가 더 수월했다. 이는 부분적으로 윈도우, 아이콘, 메뉴 같은 가시적인 심볼을 사용한 그래픽 사용자 인터페이스 덕분에 사용자가 프로그램과 쉽게 상호 작용 할 수 있기 때문이다. 기술 비용이 감소해 네트워크에서 컴퓨터간 정보 이동이 더 경제적이고 현실적인 수준이 되었다. 이메일, 파일전송과 원격 데이터베이스 접속 프로그램이 늘어났다.

분산 컴퓨팅, 즉 독립적인 컴퓨터 여러대로 공동 작업을 수행하는 일은 클라이언트/서버 모델에서 보편적인 형태가 되었다. 서버는 종종 그래픽을 보여주거나 데이터베이스를 관리하거나 웹 서비스를 하는 등 특정한 임무를 할당받는 것이 일반적이었다.
소프트웨어 공학 분야에서 발전을 거듭하여, 미국 정부는 국방부의 소프트웨어 프로젝트를 더 면밀하게 통제할 필요를 느낄 정도가 되었다. 


## 1.7 인터넷과 월드 와이드 웹의 역사

60년대 후반, 미 국방부의 ARPA (Advanced Research Projects Agency)는 십여 군데의 TRPA지원 대학교와 연구 기관의 메인 컴퓨터들을 네트워크로 연결하는 청사진을 내놓았는데 당시에는 놀라운 속도인 초당 56 KB 통신 회선에 각 컴퓨터를 연결한다는 내용이었다. ARPA는 ARPAnet을 구현했는데 이는 오늘날 사용하는 인터넷의 시조가 되었다.

연구자들이 자신의 컴퓨터를 네트워크에 연결할 수 있게 해줬지만, 가장 유용한 점은 이후 이메일로 알려진 기술을 통한 빠르고 쉬운 통신능력이다. ARPAnet을 이용해 통신하기 위한 통신규약, 즉 프로토콜은 TCP/IP다. Transmission Control Protocol / Internet Protocol

TCP/IP 는 응용 프로그램 사이의 통신을 관리하는데 사용되었다. 이 프로토콜은 메시지가 송신자로부터 수신자에게 올바르고 손실없이 전달되는 것을 보장했다. TCP/IP가 등장하면서 전세계 컴퓨팅 산업은 더욱 빠르게 발전했다. 기업인들은 인터넷을 활용해 업무를 관리하고 고객에게 더 나은 서비스를 제공할 수 있음을 재빨리 알아차렸고, 마침내 여러 회사에서 막대한 자금을 투자해 인터넷에 뛰어들어 통신사들과 증가하는 통신 인프라의 요구 조건을 충족하는 하드웨어와 소프트웨어 공급자들 간 경쟁이 치열해졌다. 그 결과 인터넷의 대역폭이 엄청나게 증가했고, 하드웨어와 통신 비용 급격하게 떨어졌다. 월드 와이드 웹 덕분에 컴퓨터 사용자들은 거의 모든 주제에 대해 멀티미디어 기반 문서를 검색하고 조회할 수 있게 되었다. 1989년에 CERN의 팀 버너스 리는 하이퍼링크 문서를 통해 정보를 공유하는 방법을 개발하기 시작했다. 버너스 리는 이 신기술을 구현하려고 HTML을 만들었다. 이어 더해 HTTP를 사용해 월드 와이드 웹이라는 하이퍼 텍스트 정보 시스템의 통신 근간을 만들고자 했다.

인터넷과 월드 와이드 웹은 컴퓨팅 통신 기술을 접목해 일상업무를 간편하게 해줬고, 결과적으로 많은 사람이 정보를 편리하게 찾을 수 있게 되었다. 

팀버너스니는 90년에 월드 와이드 웹을 개발했다. 80년대에 대규모 프로젝트에서 수많은 문서를 빨리 찾을 수 있게 하이퍼텍스트 링크를 사용하는 Enquire라는 프로그램을 만들었고, 84년에 CERN 의 멤버가 되어 실시가 ㄴ네트워크 시스템의 통신 소프트웨어들을 경험했다.


## 1.8 90년대

90년대에 하드워드 성능은 급속히 발전했다. 90년대 말에는 전형적인 개인용 컴퓨터의 성능이 초당 수억개명령어를 실행하고, 하드 디스크에 기가바이트가 넘는 정보를 저장할 수 있게되었다. 몇몇 슈퍼 컴퓨터는 초당 1조개가 넘는 명령어를 실행할 수 있었다. 처리 성능이 향상되고 저장 매체들이 저렴해지면서, 개인 사용자들이 크고 복잡한 프로그램을 개인용 컴퓨터에서 실행하게 되었다. 90년대 월드와이드 웹의 탄생으로 분산 컴퓨팅이 폭발적으로 증가한다. 애초에는 운영체제가 한 컴퓨터에서 독립된 자원을 관리하면 그만이었지만, 월드 와이드 웹의 탄생과 점차 가속화되는 인터넷 연결 때문에 개인용 컴퓨터 사이 분산 컴퓨팅이 일반적인 일이 되었다. 한편 큰 조직에서는 분산 멀티 프로세서, 즉 프로세서가 여러개 있는 컴퓨터들의 네트워크를 이용하여 자원을 확대하고 효율을 높일 수 있게 되었다. 사용자들은 원격 컴퓨터에 저장된 데이터를 요청하거나, 원격 프로세서에서 프로그램을 실행하기도했다. 한편 큰 조직에서는 분산 멀티프로세서, 즉 프로세서가 여러개 있는 컴퓨터들의 네트워크를 이용하여 자원을 확대하고 효율을 높일 수 있게 되었다. 그러나 분산 응용 프로그램에는 여전히 한계가 있었는데, 네트워크를 통해 통신하는 속도가 개인 컴퓨터에서 내부적으로 처리하는 속도를 따라가지 못한 것이다.

인터넷 연결 수요가 늘어나면서 운영체제에서 네트워크 지원이 표준이 되었다. 가정과 기관의 사용자들은 네트워크에 있는 컴퓨터 자원에 접근해 생산성을 늘렸다. 윈도우 운영체제는 1993년 윈도우 3.1 출시 이후 엄청난 인기를 끌었다. 
윈도우 3.1 후속으로 95와 98을 출시했으며 90년대 후반에 데스크톱 운영체제 시장을 사실상 잠식했다. NT는 매우 빠른 속도로 기업용 워크스테이션 운영 체제로 자리 잡았다. 윈도우 XP는 윈도우 NT에 기반을 둔 운영체제이다. 

> 객체 기술

객체지향 프로그래밍 언어인 C++이나 자바로 작성한 응용 프로그램수가 꾸준히 증가하면서, 객체 기술은 컴퓨터 분야의 여러영역에서 유행하기 시작했다. 객체라는 개념은 컴퓨팅에서 새로운 접근 방법을 제공한다. 각 소프트웨어어 객체는 속성과 동작을 캡슐화환다. 이는 다른 응용 프로그램에서 사용한 컴포넌트를 재사용해서 프로그램을 개발함으로써 개발 시간을 단축할 수 있게해준다. 객체지향 운영체제 에서는 운영체제의 구성 요소와 시스템 자원을 객체로 표현한다. 상속, 인터페이스 같은 객체지향의 개념은 이전 기술로 만든 운영체제보다 유지보수와 확장이 쉬운 모듈화된 운영체제를 개발하는데 공헌했다. 모듈화를 통해 운영체제가 새롭고 다양한 아키텍처를 지원할 수 있게되었다. 다양한 플랫폼과 언어를 아우르는 객체들을 통합할 목적으로 썬의 자바나 마이크로소프트의 닷넷등 다양한 프로그래밍 언어에서 객체 개념을 지원하게 되었다. 

> 오픈 소스 운동

90년대 컴퓨팅 커뮤니티, 특히 운영체제 분야에서 또다른 발전은 오픈 소스 소프트웨어를 지향하는 운동이다. 대부분의 소프트웨어는 고급 프로그래밍 언어로 소스 코드를 작성해 만든다. 그러나 상용 소프트웨어는 보통 오브젝트 코드 형태로 배포한다. 오브젝트 코드는 컴퓨터가 이해할 수 있는 컴파일된 소스코드로, 머신 코드 혹은 바이너리 코드라고도 한다. 소스코드나 프로그래밍 기술은 공개되지 않고, 제작사의 독점적인 지적 소유물이 된다. 그러나 90년대에는 무료 및 오픈 소스 소프트웨어가 점차 보편화되었다. 오픈 소스 소프트웨어는 소스 코드와 함께 배포하기 때문에 개인이 살펴보고 수정한 후 컴파일하고 실행할 수 있다. 예를 들어 리눅스 운영체제와 아파치 웹 서버는 모두 오픈소스이다. 

80년대에 MIT의 소프트웨어 개발자 리처드 스톨만은 AT&T의 유닉스 운영체제에 있는 대부분의 도구를 수정및 개선해서 무상으로 코드를 제공하는 프로젝트를 시작했다. 스톨만은 자유 소프트웨어 재단을 설립하고 GNU프로젝트를 시작했는데, 그 이유는 소프트웨어를 사용할 수 있는 권한을 판매한다는 생각에 반대했기 때문이다. 스톨만은 사용자에게 소프트웨어를 수정하고 배포할 자유를 허용하면 특정 개인이나 기업의 이윤을 목적으로 개발하는 것보다 많은 사용자의 요구를 반영해 더 나은 소프트웨어가 탄생할 것이라고 믿었다. GPL라이선스는 소프트웨어는 누구든지 자유롭게 수정하고 재배포할 수 있다고 명시하고 있다. 다만 수정 사실을 분명하게 표시하고 수정해서 나온 제품 역시 GPL라이선스에 따라 배포하는 것을 전제로 한다. 대부분 GPL라이선스는 무료로 사용가능하지만, GPL은 사용자가 해당 소프트웨어를 수정, 재배포 할수 있게한다는 의미에서 무료다. 


> 리눅스 토발즈
91년 기본적인 리눅스 커널의 최초 버전을 완성했다. 94년에는 리눅스가 세상에 나와 사용할 만한 운영체제로 완성되어 1.0버전을 발표한다. 


90년대 후반에는 OSI 가 조직되어 오픈 소스 소프트웨어를 보호하고 오픈 소스 프로그램의 이익증진을 도모했다.

오픈 소스 소프트웨어는 개발자 커뮤니티에서 누구든지 응용 프로그램을 테스트하고 디버깅해 개선할 수 있게 함으로써 소프트웨어 제품을 더욱 개선할 수 있는 길을 만들었다. 덕분에 발견되지 않을 경우 보안 허첨이 되거나 논리적 오류가 될 만한 미묘한 버그들을 발견하고 수정할 수 있게 되고, 각 개인과 회사에서 소프트웨어를 자신들의 목적과 환경에 맞게 커스터마이즈할 수 있게 되었다.

> 리처드 스톨만

공유 소프트웨어란 다른 사람의 실행 프로그램을 받을 때 해당 소스코드도 함께 받는다는 개념이다. 92년 스톨만은 자신의 시스템을 완성하는데 리눅스 커널을 사용했다. 거누/리눅스라고 부르는 이 시스템은 다양한 프로그램들을 포함하고 기능을 온전히 갖춘 운영체제이다.

오픈 소스 운영체제들은 앞으로 제품 개선과 산업계 표준화, 상호 운용성, 제품의 커스터마이징, 비용 절감등을 통해 독점 제품들을 대체해 나갈 것이 분명하다.운영체제에 플러그 앤 플래이 기능도 생겨서 사용자들이 운영체제를 수동으로 재구성하지 않아도 하드웨어 구성요소를 추가, 삭제할 수 있게 되었다. 

## 1.9 2000년 이후

2000년 이후 들어 현재까지 네트워크등을 통해 두 독립적인 응용프로그램을 서로 연결하는 소프트웨어인 미들웨어의 역할이 아주중요해졌다. 미들웨어는 웹 애플리케이션에서 보편적으로 사용된다. 사용자의 웹브라우저에 데이터를 보내는 웹 서버는 데이터베이스의 도움을 받아 사용자의 요처에 따른 내용을 생성해야한다. 미들웨어는 웹 서버와 데이터 베이스 사이에서 메시지를 전달하는 가이드 역할을 한다. 웹서비스는 네트워크를 통해 통신하며, 다른 응용프로그램들이 호출할 수 있는 연산들을 지원한다. HTTP 같은 표준 프로토콜을 이용해 데이터를 주고받으며 일반적인 웹 페이지를 보내는데 같은 프로토콜을 사용한다. 웹 서비스는 개방된 텍스트 기반 표준을 사용해 서로다른 언어와 플랫폼에서 만든 컴포턴트들이 서로 통신할 수 있게 해준다.멀티 프로세서와 네트워크 아키텍처는 새로운 하드웨어와 소프트웨어 설계 기술을 개발할 수 있는 수많은 기회를 제공한다. 한번에 한가지 계싼을 지정하는 순차적 프로그래밍 언어가 이제 자바와 같은 평행프로그래밍 언어로 보완되었다. 자바는 스레드를 사용해 병렬 계산을 정의할 수 있는 메커니즘을 제공한다. 점차 많은 시스템에서 고도 병렬성을 보이고 있다. 고도 병렬성이란 프로세서를 다수 보유해 여러 독립된 연산을 병렬로 수행하는 것으로 지난 60여년 동안 사용해온 순차적 컴퓨팅 방식과는 근본적으로 다른 개념이다. 운영체제는 다양한 프로그램을 지원하고 사용을 용이하게 하려고 사용자와 응용프로그램의 인터페이스를 표준화한다. 마이크로소프트는 윈도우 운영체제의 소비자와 전문가 집단을 윈도우 XP로 흡수했다. MS의 차세대 운영체제에서는 다른 유형의 파일 포맷을 통합하려는 계획을 두고있다. 이는 사용자들이 특정 키워드를 사용해서 스프레드시트, 이메일등 시스템에 있는 모든 문서를 검색할 수 있게 할 것이다. 롱혼은 또한 더 강화된 3D사용자 인터페이스와 보안 기능을 제공하고, 기록가능한 DVD를 지원할 계획이다. 리눅스를 비롯한 오픈 소스 운영체제는 사용 영역이 더욱 확대되고, POSIX같은 표준 API를 도입해 다른 유닉스 기반 운영체제와 호환성을 높이려고 노력할 것이다. 


## 1.10 응용 프로그램 기반 

운영체제는 개발자들이 일련의 응용 프로그래밍 인터페이스를 호출할 수 있게하여, 하드웨어 조작등을 간단히 해결하게 해준다.

API는 시스템 호출을 제공하는데, 사용자 프로그램은 이를 통해 운영체제가 필요한 작업을 하게된다. 응용 프로그램 개발자는 특정 작업을 위해 어떤 루틴을 호출해야하는지 알면된다. 응용프로그램이 시스템 자원을 잘못 사용하려 하거나, 허용받지 않은 시스템 자원에 접근하려고 하면, 운영체제는 해당 응용프로그램을 막아 시스템을 손상시키거나 다른 응용 프로그램을 방해하는 일이 없게 해야한다. 

## 1.11 운영체제 환경 

범용 컴퓨터에 해당하는 다양한 개념을 고성능 하드웨어를 갖춘 고사양 웹 서버와 데이터베이스 서버에도 적용할 수 있다. 고성능 환경에서 사용하는 운영체제는 대용량 메모리와 특수목적 하드웨어, 여러 프로세스등을 지원하도록 설계해야한다. 

실시간 시스템은 정해진 시간 안에 특정 작업을 완료해야한다. 예를 들어 비행기의 자동 제어 시스템은 속도고도, 방향등을 끊임없이 조절해야한다. 대기업에서는 직원들이 정보를 효율적으로 공유하고 전력이 나가거나 디스크 오류가 발생해도 중요한 정보를 손실하지 않아야한다. 한편 미션 크리티컬 시스템과 다른점은 비즈니스 크리티컬 시스템이 제대로 작동하지 않는다고 해서 해당 비즈니스가 모두 실패하지는 않는다는 점이다. 가상머신은 하부 운영체제를 통해 시스템에있는 하드웨어들과 인터페이스한다.가상머신은 프로세서 메모리, 통신채널, 디스크, 클록등 물리적인 시스템을 대표하는 소프트웨어 구성 요소를 만들어 낼 수 있다. 자바 가상 머신은 가장 널리 사용하는 가상머신중하나다. JVM은 자바 플랫폼의 기초를 이루며, JVM이 설치된 시스템이면 어떤 플랫폼이든 자바프로그램이 동작할 수 있다. 

## 1.12 운영체제의 구성 요소와 목표

컴퓨터 시스템은 운영체제가 없던 초기 시스템에서부터 멀티프로그래밍, 시분할 시스템, 개인용 컴퓨터 등으로 발전했다. 최종적으로는 진정한 의미에서 분산 시스템으로 발전했다. 새로운 기능과 효율 개선에 대한 요구가 증가하고 하드웨어가 변하면서, 운영체제는 새로운 역할을 맡게되었다. 

### 1.12.1 운영체제의 핵심 구성요소

사용자는 한개 이상의 응용프로그램이나 셸(명령어 해석기) 이라는 특별한 응용 프로그램을 통해 운영체제와 상호작용한다.

운영체제의 핵심요소를 담은 소프트웨어를 커널이라고한다. 운영체제들이 공통으로 포함하는 핵심 요소를 살펴보면 다음과 같다. 
- 프로세스 스케줄러는 프로세서에서 프로세스를 실행할 시점과 기간을 결정한다.
- 메모리 관리자는 프로세스에 메모리를 할당할 시점과 방식, 메인 메모리가 가득 찼을 때 처리방법을 결정한다. 
- 입출력 관리자는 하드웨어 장치들과 연동해 입출력 요청을 처리한다.
- 프로세스간 통신관리자는 프로세스들이 서로 통신할 수 있게한다.
- 파일 시스템관리자는 저장 장치에 있는 이름있는 데이터 모음을 조직화하고, 해당 데이터에 접근할 수 있는 인터페이스를 제공한다.

운영체제의 가장 기본적인 역할 중 하나는 특정 프로세서가 프로세스를 얼마동안 실행하게 할 것인지 결정하는 것이다.

한 프로그램에 데이터를 공유하고 동시에 실행할 수 있는 여러 요소가 있을 수 있다. 예를 들어 웹 브라우저는 웹페이지의 HTMl을 읽어들이고, 페이지에서 이미지나 텍스트 비디오등의 미디어를 추출하고, 브라우저 창에 페이지의 내용을 배치해서 보여주는 구성 요소를 별도로 포함할 수 있다. 이처럼 독립적으로 실행하지만 공통 메모리 공간에서 작업하는 프로그램 구성 요소를 스레드라고 한다.

대개는 여러 프로세스가 프로세서를 사용하려고 경쟁한다. 프로세스 스케줄러는 프로세스의 중요도나 예상 실행 시간 또는 프로세서를 얻으려고 대기한 시간등 몇가지 기준에 따라 프로세서를 선정한다. 

메모리 관리자는 운영체제와프로세스에 메모리를 할당한다. 또한 프로세스가 운영체제나 다른 프로세스들을 방해하지 않도록 해당 프로세스에서 할당 받지 않은 메모리에 접근하는 일을 방지한다. 

메인 메모리는 비교적 소용량이고, 전완이 나가면 데이터를 잃기 때문에 영구적인 보조 저장 장치로 주로 하드디스크를 사용한다. 디스크 입출력은 입출력중에서도 가장 빈번하게 일어나는 형태로, 프로세스가 디스크 장치에 있는 정보에 접근할 때 발생한다. 그런데 보조저장장치는 프로세서나 메인 메모리보다 훨씬느리다. 운영체제의 디스크 스케줄러 구성요소는 디스크 입출력 요청을 재정렬해서 성능을 최적화하고, 프로세스가 디스크 입출력 때문에 대기하는 시간을 최소화하는 역할을 한다. 

### 1.12.2 운영체제의 목표 
