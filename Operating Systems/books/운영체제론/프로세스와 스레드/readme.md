# 프로세스 개념

## 3.1 소개


이장에서는 프로세스의 개념을 정식으로 살펴본다. 프로세스는 오늘날 컴퓨터 시스템의 동작 원리와 동시에 수행되는 많은 활동을 관리하는 방법을 이해하는데 필요한 핵심 개념이다. 먼저 더 일반적인 프로세스 개념을 소개하고 자세한 프로세스 상태와 이 프로세스들이 상태 변화를 일으키는 방법과 그 이유에 대해 살펴본다. 또한 프로세스를 생성에서부터 종료 일시정지 재시작 깨우기 등 운영체제가 프로세스를 서비스할 때 수행하는 다양한 연산을 논의한다.

### 3.1.1 프로세스 정의

운영체제 문맥에서 프로세스는 60년대 멀틱스 설계자들이 처음 사용하기 시작했다. 그 이후로 프로세스를 어느 정도 작업과 바꿔 쓸 수 있는 용어처럼 여기게되고, 이외에도 여러 정의가 생겼다. 예를 들면 실행중인 프로그램, 비동기 활동, 프로시저에 생명을 불어 넣는것, 실행중이 ㄴ프로시저의 통제소재라고도한다. 한편 운영체제에 있는 프로세스 기술자 또는 프로세스 제어블록이라는 자료구조로 정의되는 것이라고도 한다. 

또한 프로세서가 할당되는 개체, 디스패치 가능한 단위로 지칭하기도 한다. 프로그램이 낱장 악보들이라면, 프로세스는 음악을 연주하는 심포니 오케스트라에 비유할 수 있다. 

프로세스는 개체라는 것이다. 각 프로세스는 자신의 주소 공간을 가지고있다. 주소공간은 대개 텍스트영역, 데이터영역, 스택영역으로구분된다. 텍스트 영역은 프로세서가 실행하는 코드를 저장하는 영역이다. 데이터영역은 변수들을 저장하는 영역과 프로세스가 실행중에 사용하려고 동적으로 할당받은 메모리 공간이다. 스택영역은 호출된 프로시저용으로 지역변수와 명령어들을 저장하는 공간이다. 스택의 내용은 프로세스가 중첩되게 프로시저 호출을 할 수록 증가하고, 호출된 프로시저가 수행을 마치고 반환할 때마다 줄어든다. 두번째로, 프로세스는 실행중인 프로그램이다. 프로그램은 살아있는 개체가 아니다. 프로세서가 프로그램에 생명을 불어넣을 때야 비로소 프로세스라는 활성 개체가 된다.

## 3.2 프로세스 상태 프로세스 생명 주기

운영체제는 각 프로세스가 충분한 프로세서 시간을 할당받을 수 있게 해야한다. 어떤 시스템이든 동시에 실행되는 프로그램이 프로세서 수만큼 존재할 수 있다. 하지만 보통 시스템이는 프로세서 수보다 훨씬 많은 프로세스가 있다. 그러므로 임의의 특정 시간을 두고 볼 때 몇몇 프로세스는 실행되고 몇몇은 실해오디지 못한다. 

프로세스 생명 주기 동안 구분된 프로세스 상태들을 거친다. 다양한 이벤트를 만날 때, 프로세스의 상태가 바뀐다. 프로세스가 프로세서에서 실행되고 있으면 실행중이라고한다. 프로ㅔㅅ스가 프로세서에서 실행 가능하면 준비되었다고 한다. 또한 프로세스가 작업을 진행하기에 앞서 입출력 완료 이벤트등의 특정 이벤트 발생을 대기하고 있다면 블록되었다고 한다.


## 3.3 프로세스 관리

운영체제는 프로세스들의 실행 사이에 끼어들면서 프로세스들이 인터럽트 되고 재시작하거나 프로세스 실행완료를 알리는 등 단순한 일을 위해서도 운영체제와 통신할 수 있어야한다. 


### 3.3.1 프로세스 상태와 상태전이

준비리스트에 있는 첫 번째 프로세스에서 프로세서를 할당하는 것을 디스패칭이라고 한다. 디스패처라는 시스템 개체가 이일을 수행한다. 준비상태 또는 실행상태에 있는 프로세스를 깨어있다라고 한다. 프로세서를 차지하려고 활발히 경쟁하는 상태기 때문이다. 운영체제는 시스템에있는 프로세스들을 가장 잘 서비스 할 수 있게 프로세스들의 상태전이르 ㄹ관리한다. 운영체제는 한 프로세스가 우연이든 고의든 시스템의 프로ㅔㅅ서를 독점하는 일을 방지하려고 하드웨어 인터럽팅 클록을 두어, 프로세스가 특정시간 간격 또는 퀀텀 동안 일을 수행할 수 있게한다. 프로세스가 시간이 만료되기 전에 프로세서를 자발적으로 반납하지 않으면, 인터럽팅 클록이 인터럽트를 발생시키며 프로세서에 대한 제어를 운영체제가 갖는다. 그리고 운영체제는 이전에 실행하던 프로세스의 상태를 준비 상태로 바꾸고 , 준비리스트에 있는 맨 처음 프로세스의 상태를 준비상태에서 실행 상태로 바꾼다. 실행 상태에 있는 프로세스가 자신에 주어진 만료 시간 전에 출력 작업을 시작하고, 프로세서를 다시 사용하기 전에 입출력이 완료되기를 대기해야한다면, 자발적으로 프로세서를 반납한다. 

프로세스가 프로세서를 할당받으면 프로세스의 상태가 준비상태에서 실행상태로 변한다. 프로세스가 할당받은 시간이 만료되면 실행상태에서 준비상태로 변한다. 프로세스가 블록되면 실행상태에서 블록상태로 변한다. 마지막으로 대기하던 이벤트가 완료되면 프로세스가 깨어나고 블록상태에서 준비상태로 변한다. 사용자 프로세스가 스스로 일으키는 상태 전이는 블록 상태 뿐이다. 다른 세가지 상태 전이는 운영체제가 일으킨다.

### 3.3.2 프로세스 제어 블록 프로세스 기술자

운영체제는 프로세스를 생성할 때 몇가지 연산을 수행한다 .먼저 운영체제가 각 프로세스를 식별할수 있어야하므로 PID를 부여한다. 그런다음 프로세스 제어블록을 생성해 프로세스를 관리하는데 필요한 정보를 보관한다. PCB는 대체로 다음과 같은 정보를 포함한다.

- PID
- 프로세스 상태
- 프로그램 카운터
- 스케줄링 우선순위
- 퀀한
- 프로세스의 부모 프로세스
- 프로세스의 자식 프로세스 
- 프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터
- 프로세스에 할당된 자원들을 가리키는 포인터

PCB는 또한 실행 프로세스가 실행상태에서 빠져나올 때 마지막으로 실행한 프로세서의 레지스터 내용을 저장하기도 한다. 프로세스의 실행 문맥은 아케턱처에 종속적이지만 프로세스의 주소 공간에 대한 포인터를 저장하는 프로세스 관리 레지스터 외에도 범용 레지스터의 내용을 포함하는 것이 보통이다. 

운영체제는 프로세스가 상태 전이를 할 때 해당 프로세스의 PCB안에 있는 상태정보도 갱신해야한다. 운영체제는 각 프로세스의 PCB를 가리키는 포인터를 시스템 전체 혹은 사용자별 프로세스 테이블에 유지해 PCB에 빠르게 접근할 수 있다. 프로세스테이블은 이 책에서 다루는 운영체제의 여러 자료구ㅈ중하나다. 프로세스가 자발적으로든 운영체제에 의해서든 종료하면 운영체제는 프로세스의 메모리와 기타 자원을 해제해 다른프로세스가 사용할 수 있게하고 , 프로세스 테이블에서 해당 프로세스를 제거한다. 다른 프로세스 조작 기능에 관해서도 잠깐 살펴볼 것이다. 

### 3.3.3 프로세스 연산 

운영체제는 다음을 포함하는 프로세스 연산을 수행할 수 있어야한다.

- 프로세스 생성
- 프로세스 소멸
- 프로세스 일시정지
- 프로세스 재시작
- 프로세스의 우선순위 변경
- 프로세스 블록킹 
- 프로세스 깨우기
- 프로세스 디스패치
- 프로세스가 다른 프로세스와 통신할 수 있게하는 일
  

프로세스는 새로운 프로세스를 생성할 수 있다. 이때 프로세스를 생성하는 프로세스를 부모 프로세스라고하고 생성된 프로세스를 자식 프로세스라고한다. 각 자식 프로세스는 정확히 한 부모 프로세스를 통해 생성된다. 이러한 프로세스 생성은 계층적 프로세스 구조를 형성한다. 리눅스와 같은 유닉스 기반 시스템에서는 커널이 메모리에 로드될 때 생성되는 init 프로세스에서 많은 프로세스를 생성한다. 프로세스의 우선순위를 변경하려면  PCB에 있는 우선순위 값을 변경해야한다. 운영체제가 프로세스 스케줄링을 구현한 방법에 따라 PCB를 가리키는 포인터를 놓는 우선순위 큐가 달라진다. 


### 3.3.4 일시정지와 재시작

일시정지는 해당 프로세스 혹은 다른 프로세스에 의해 발생할 수 있다. 단일 프로세서 시스템에서는 실행중인 프로세스가 자신을 일시 정지한다. 일시정지를 발생시킬 다른 프로세스가 동시에 실행될 수 없기 때문이다. 


### 3.3.5 문맥교환

운영체제는 실행중인 프로세스를 멈추고 준비 상태에 있던 다른 프로세스를 실행할 때, 문맥교환을 수행한다. 문맥 교환을 위해서 커널은 먼저 실행중인 프로세스의 실행 문맥을 해당 프로세스의 PCB에 저장한 후 , 이후 실행할 준비 상태 프로세스의 이전 실행 문맥을 PCB에서 읽어 로드한다.  문맥교환은 멀티프로그램 환경에서는 필수적인 것으로 운영체제에 몇가지 도전거리를 준다. 먼저 문맥 교환은 기본적으로 프로세스에 투명해야한다. 즉 프로세스가 자신이 프로세서에서 제거되는 상황을 인식하지 못해야한다. 문맥 교환이 일어나는 동안 프로세서는 의미있는 작업을 전혀 수행할 수 없다. 즉 문맥 교환을 위해 운영체제에 필수적인 작업은 하지만 어떤 프로세스의 명령어도 실행하며 안된다. 문맥교환은 순전히 오버헤드며 매우 빈번하게 발생하므로 운영체제는 문맥교환에 드는 시간을 최소화해야한다. 

운영체제는 PCB에 자주 접근한다. 따라서 효율적으로 문맥 교환을 하기 위해 많은 프로세서에서 현재 실행중인 프로세스의 PCB를 가리키는 하드웨어 레지스터를 포함한다. 



## 3.4 인터럽트 


