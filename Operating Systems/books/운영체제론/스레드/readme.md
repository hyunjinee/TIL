# thread

## 4.1 소개

초기의 운영체제들도 컴퓨터가 여러 프로그램을 동시에 실행할 수 있게 했다. 그러나 당시 프로그래밍 언어들은 프로그래머가 동시에 수행할 행동을 명시할 방법을 지원하지 않았다. 이 언어들은 대개 간단한 제어구조만 제공해 프로그래머들이 단일한 프로그램 흐름만 제어할 수 있었다. 병행 작업의 유형은 대체로 경험이 많은 시스템 프로그래머들만 가능한 운영체제 프리미티브를 사용해 구현되었다. 

프로그래머들은 응용프로그램이 스레드 실행을 포함하도록 프로그램을 작성하며, 이때 각 스레드는 프로그램의 한부분을 이루는 병행으로 실행될 작업들을 지정한다. 이러한 기술을 멀티 스레딩이라고 하며, c와 c++ 같은 언어에서는 직접 지원하지 않던 강력한 기능을 제공한다. 


> 병행성

입출력 기능은 프로그램 실행과 동시에 진행될 수 있다. 몇몇 프로세서를 병행으로 실행할 수도 있고, 여러 사용자가 시스템을 병행으로 사용할 수 있다. 몇몇 프로세스가 공유 데이터에 병행으로 접근할 수도 있다. 또한 네트워크에서 여러 컴퓨터가 병행으로 작동하고 있을 수도 있다. 자바와 c#의 기초가 된 c나 c++은 단이 ㄹ스레드 언어라고한다. 멀티스레딩을 지원하는 프로그래밍 언어를 뒷받침하려면 반드시 운영체제에서 스레드를 지원해야한다. 

멀티스레드 프로그램 작성은 고도의 기술이 필요한 힘든 작업이다. 사람의 머리는 동시에 여러 기능을 수행할 수 있지만, 병렬로 진해오디는 사고의 맥락을 넘나드는 것은 힘든 일이다. 멀티스레드 응용 프로그램 작서잉 어려운 이유를 이해하기 위해 다음과 같은 실험을 해보자. 책 세권을 펴서 1페이지부터 동시에 읽어보자 첫번째 책 몇단어를 읽고 두번째 책 또 세번째 책을 몇단어씩읽는다. 다시 첫번째 책으로 돌아와서 몇단어를 읽는 식으로 반복한다. 실제로 실험해보면 멀티스레딩에서 도전거리가 되는 몇가지문제점을 이해할 수 있을 것이다. 즉 이책을 펴서 저책으로 바꾸고 짧게읽고 각책에서 어디까지 읽었고 어디부터 이어서 읽어야할지 기억하고 시야에 들어오게 각책을 가까이 가져오고 다음 책으로 바꾸면서 방금 읽은 책을 옆으로 치우고, 이 모든 와중에 책의 내용을 생각하고 있어야한다. 

## 4.2 스레드 정의

많은 프로그래밍 언어에서 멀티스레딩을 지원하므로 사실상 최근의 모든 운영체제는 어느정도 스레드를 지원한다고 할수있다. 스레드는 종종 경량 프로세스라고도 하며, 많은 프로세스 속성을 공유한다. 프로세서에서 스케줄링되면 각 스레드는 다른 프로세스나 스레드와 독립적으로 일련의 명령어를 수행한다. 그러나 스레드가 홀로 존재한다는 의미는 아니다. 스레드는 일반적으로 전통적인 프로세스에 속한다. 한 프로세스에 속한 스레드들은 프로세스의 여러 자원을 공유한다. 특히 프로세스의 주소공간과 열린 파일들을 공유해 업무 수행 효율을 높인다. 스레드라는 명칭은 명령어들의 한줄기 , 프로그램 제어 흐름 한가닥을 나타낸다. 프로세스에 있는 스레드들은 병행으로 실행되면서 공통의 목표를 이루려고 협력할 수 있다. 멀티프로세서 시스템에서는 여러 스레드를 동시에 실행할 수 있다. 

스레드들은 한 프로세스에 포함된 자원의 일부를 소유한다. 프로세서나 레지스터나 스택 신호 마스크처럼 스레드마다 있는 데이터들은 각 스레드에 국한되어 있지만, 프로세스에 속한 주소 공간은 해당 프로세스에 속한 모든 스레드에 공통적이다. 


## 4.3 스레드 사용 동기

프로세스는 60년대 멀틱스에서 소개했다. 멀틱스는 단일 프로세서를 갖추고 비교적 작은 응용 프로그램을 가진 컴퓨터다. 당시의프로세스들은 단일 프로세서로 한번에 한 스레드를 실행하도록 설계되었다. 그런데 컴퓨터 소프트웨어와 하드웨어 설계 경향이 한 프로세스당 여러 스레드를 실행하는 시스템이 이롭다는 쪽으로 바뀌었다. 멀티스레딩을 선호하게 된 요인은 다음과 같다.

- 소프트웨어 설계 : 모듈화와 컴파일러 설계에 따라 오늘날 많은 응용프로그램이 응용 프로그램의 나머지 부분과는 독립적인 코드 세그먼트를 포함하고 있다. 독립적인 코드 부분을 개별 스레드로 분리해 응용 프로그램의 성능을 향상시키고 병렬 작업 처리를 더 간단하게 표현할 수 있게 되었다. 
- 성능: 단일 스레드 응용 프로그램의 문제는 멀티 프로세서 시스템에서 독립된 작업을 수행하도록 스케줄링 할수 없다는 점이다. 멀티스레드 응용 프로그램에서는 스레드가 프로세서 하나 또는 여러개를 공유해 여러 작업을 병렬로 수행할 수 있다. 동시에 병렬로 실행하면, 한프로세서에서 순차적으로 작업을 수행하는 단일 스레드 프로그램과 비교할 때 멀티스레드 응용 프로그램이 작업을 완료하는데 필요한 시간이 크게 줄어든다. 특히 프로세서가 여러개 있는 시스템에서 더그러다 또한, 멀티스레드 프로세스에서느 ㄴ다른 스레드가 입출력 완료를 기다리느다 블록되어있는 동안 준비 상태 스레드가 실행할 수 있다. 
- 협력: 많은 응용 프로그램은 통신하고 동기화하는 활동을 독립적인 구성 요소에 의존한다. 스레드가 등장하기 전에는 커널을 통해 프로세스간 통신 채널을 구축하는 여러 중량프로세스로 이들 구성 요소를 실행했다. 그런데 이보다는 여러 경량 스레드를 사용하는 방법이 훨씬 좋다. 한 프로세스에 속한 스레드들은 주소 공간을 공유하기 때문에 이르 ㄹ이용해 서로 통신 할 수 있기 때문이다.

현재 사용하는 커뮾터 시스템에서는 멀티 스레드 응용 프로그램을 어디서나 볼 수 있다. 웹서버는 스레드를 사용해 성능과 상호 작용성을 한층향상시킬 수 있는 환경이다. 웹 서버는 보통 원격에 있는 응용 프로그램으로부터 웹 페이지나 이미지, 파일등을 요청받는다. 흔히 웹 서버는 각 요청마다 스레드를 하나씩 할당해 서비스한다. 요청ㅇ을 받는 프로세스는 인터넷을 통해 들어오는 요청을 감지하는 스레드를 하나 포함할 것이다. 그리고 요청이 들어올 때마다 새로운 스레드를 생성해 요청을 해석하고 특정 웹 페이지를 조회하고 웹페이지를 클라이언트에 전송한다. 새로운 스레드를 생성한 후 그 부모 스레드는 계속해서 새로운 요청을 받을 수 있다. 많은 웹서버가 멀티프로세서 시스템이기 때문에 한번에 여러 요청을 받고 서로다른 스레드들이 동시에작업함으로써 처리량과 반응 속도를 모두 향상시킬수 있다. 각 서비스의 요청에 따라 스레드를 생성하고 소멸한다면 오버헤드가 많이 들 것이다. 따라서 오늘날 대부분의 웹서버는 스레드 풀을 유지하고, 서비스 요청이 도착할 때마다 스레드를 하나씩 할당한다. 이러한 스레드는 서비스를 수행한 후에도 소멸되지 않고 풀에있다가 새로운 서비스 요청이 들어오면 할당되어 재사용된다. 

> 병령 처리

병렬 처리를 구현하기 위해 지역 시스템에서 멀티프로그래밍이나 멀티스레딩 멀티프로세싱 고도 병렬 처리등의 기술을 사용할 수도 있다. 컴퓨터 하드웨어는 입출력 작업을 병렬로 수행할 수 있게 만들어졌다. 멀티프로세서는 여러 프로세서를 사용해 병렬로 작업하게 만들어졌다. 특히 고도 병렬 처리에서는 프로세스를 많게는 수백 또는 수천 개 이상 사용해 병렬로 처리한다. 

워드 프로세서는 사용자의 생산성과 상호 작용성을 향상시키려고 스레드를 사용한다. 사용자가 키보드의 한글자를 타이핑할 때마다 운영체제는 키보드 인터럽트를 받고 워드프로세서에 신호를 보낸다. 그러면 워드 프로세서는 해당 글자를 메모리에 저장하고 화면에 보여준다. 

## 4.4 스레드 상태: 스레드 생명주기

프로세스는 일련의 구분된 프로ㅔㅅ스 상태를 가지며, 이 상태 변화를 통해 프로세스의 생명 주기를 알 수 있다. 이 모델에서 각 프로세스는 프로그램 제어 흐름 하나, 즉 단일 스레드를 가졌다. 따라서 한 제어 흐름에 여러 구분된 상태가 있다고 볼 수 있다. 프로세스에서 프로그램 제어 흐름이 여러개 있으면, 각 스레드가 다양한 스레드 상태로 변함을 볼 수 있다 . 예를 들어 자바로 구현한 다음 스레드를 기초로 스레드 상태를 생각해보자. 자바에서 새로운 스레드는 탄생 상태에서부터 출발한다. 프로그램이 스레드를 시작할 때까지 탄생 상태로 있다가, 시작되면 스레드가 준비 상태가 된다. 다른 운영체제에서는 스레드가 생성되면서 바로 시작되어 탄생 상태가 없는 경우도 있다. 우선순위가 높은 준비 상태 스레드는 프로세서를 할당받을 때 실행 상태가 되어 실행하기 시작한다. 실행 상태 스레드가 작업을 완료하거나 ㄷ른 방식으로 종료하면 데드 상태가 된다. 몇몇 스레딩 라이브러리는 한 스레드가 다른 스레드를 종료할 수 있게 한다. 이런 경우 종료한 스레드는 데드 상태가 된다. 스레드가 한번 데드상태에 들어가면 자원을 해제하고 시스템에서 제거된다. 

스레드는 입출력 요청이 완료되기를 대기해야할 때 블록 상태에 들어간다 블록 상태 스레드는 입출력 요청이 완료될 때까지 프로세서를 할당받지 못한다. 입출력이 완료되면 스레드는 준비상태로 돌아가고 프로세서를 사용할 수 있을 때 다시 실행할 수 있다. 스레드가 특정이벤트가 발생을 대기해야할 때 대기 상태에 들어간다 대기 상태에 들어가면 다른스레드가 통지할 때 준비 상태가 된다. 즉 대기 상태 스레드가 통지 이벤트를 받으면 대기상태에서 준비상태로 바뀐다. 실행 스레드는 휴면 간격이라는 일정 시간동안 휴면 상태에 들어갈 수 있다. 휴면 스레드는 휴면 간격 시간이 지나면 준비 상태로 돌아올 수 있다. 휴면 스레드는 프로세서가 비어있을 때도 이를 사용할 수 없다. 스레드는 일시적으로 실행할 일이 없을 때에 휴면할 수도 있다. 예를 들면 워드프로세서에는 복구를 위해 현재 문서의 사본을 주기적으로 디스크에 저장하는 스레들르 갖는 경우가 있다. 이 스레드가 여러번 백업하는 동안 중간에 휴면하지않는다면 문서의 사본을 디스크에 저장해야할지 여부를 계속확인하면서 루프를 돌아야할 것이다. 그러는 동안 프로세서 시간을소비해 생산성과 성능을 떨어뜨린다. 이경우스레드에 휴면간격을 줘서 백업을 수행하고 다음 백업까지 휴면 상태로 있게하는 것이 효율적이다. 휴면 스레드는 휴면 간격이 만료되면 준비상태가 되고, 이 시점에 문서의 사본을 디스크에 저장한후 다음 백업시간까지 다시 휴면 상태에 들어간다. 

## 4.5 스레드 연산 

스레드와 프로세스는 다음과 같은 공통적인 연산을 갖는다.

- 생성
- 종료
- 일시정지
- 재시작
- 휴면
- 깨어남

이런 측면에서 스레드 생성은 프로세스 생성과 유사하다. 프로세스가 스레드를 생성할 때 스레딩 라이브러리는 스레드마다 별도로 자료구조를 할당해 레지스터 내용이나 프로그램 카우넡 , 스레드 ID등의 정보를 저장한다. 프로세스 보다는 스레드 생성과 종료를 통해 오버헤드를 줄일 수 있기 때문에 소프트웨어 개발자들은 멀티프로세스보다는 가능하면 멀티 스레드를 사용해 병렬 작업을 구현한다. 

- 취소 : 스레드나 프로세스는 취소를 통해 프로세스나 스레드를 실행하는 중간에 종료할 수 있다. 그러나 프로세스 종료와 달리 스레드 취소는 스레드가 종료함을 보장하지 않는다. 스레드가 비활성화되어있거나 비활성화 마스크로 가려있을 수도 있기 때문이다. 스레드가 취소 신호를 마스크로 가린경우, 이 신호 유형을 다시 활성화할때까지는 취소 신호를 받지 않는다.하지만 스레드가 중단 신호를 마스킹할 수는 없다. 
- 결합: 윈도우 XP와 같은 스레드 구현에서는프로세스가 초기화될 때 주 스레드를 생성하기도 한다. 주스레드는 다른 스레드와 같은 방식으로 동작하지만 반환시 프로세스가 종료된다. 프로세스가 자신의 모든 스레드에서 작업을 완료하기 전에 종료하는 것을 방지하려고 주스레드는 각 스레드가 작업을 완료할 때까지 휴면하는 것이 보통이다. 이 경우 주 스레드가 자신이 생성한 스레드를 결합한다고 표현한다. 한 스레드가 다른 스레드를 결합하면 이전 스레드는 후자의 스레드가 종료할 때까지 실행되지 않는다. 


## 4.6 스레딩 모델

스레드 구현은 운영체제에 따라 다양하다. 그러나 대부분의 운영체제는 세가지중 한가지의 스레딩 모델을 구현한다. 이절에서는 가장 잘알려진 스레딩 모델인 사용자 수준 스레드, 커널 수준스레드, 그리고 이 두가지의 조합 방식을 살펴본다. 

### 4.6.1 사용자 수준 스레드

초기 운영체제들은 단일 실행 문맥을 가진 프로세스들만 지원했다. 그 결과 각 멀티스레드 프로세스가 스레드의 상태정보, 스레드 스케줄링, 스레드 동기화 프리미티브들을 책임지고 구현해야했다. 이러한 사용자 수준 스레드는 사용자 영역에서 스레드 연산을 수행한다. 즉, 특권 명령을 실행할 수 없거나 커널 프리미티브에 직접 접근할 수 없는 런타임 라이브러리 스레드를 생성한다. 사용자 수준 스레드는 운영체제에 투명하다. 다시말해 운영체제는 각각의 멀티스레드 프로세스를 단일 실행문맥으로 인식하고 실행한다. 운영체제가 가 ㄱ스레드가 아닌 멀티스레드 프로세스 한 단위를 대상으로 프로세서를 할당한다. 이때문에 사용자 수준 스레드 구현을 다대일 스레드맵핑이라고 한다. 운영체제가 멀티스레드 프로세스 하나에 있는 모든 스레드에 실행  문맥을 맵핑하기 때문이다. 프로세스가 사용자 수준 스레드를 사용할 때는 사용자 수준 라이브러리로 프로세스의 스레드를 스케줄링하고 디스패치한다. 운영체제 입장에서는 프로세스가 여러 스레드를 포함하고 있다는 사실을 인식하지 못하기 때문이다. 멀티스레드 프로세스는 자신에 할당된 퀀텀이 만료되거나 다른 이유 때문에 커널에 프로세서를선점 당할 때까지 계속 실행한다. 

커널 영역대신 사용자 영역에서 스레드를 구현하면 여러가지 장점이있다. 우선 사용자 수준 스레드는 운영체제에서 스레드를 지원할 필요가 없다. 따라서 특정 운영체제의 스레딩 API에 의존하지 않고 이식성이 높아진다. 또 다른 장점은 운영체제가 아닌 스레딩 라이브러리에서 스레드 스케줄링을 제어하기 때문에 응용 프로그램 개발자들이 자신의 응용 프로그램 요구에 맞게 스레딩 라이브러리의 스케줄링 알고리즘을 수정할 수 있다.

또한 사용자 수준 스레드는 스케줄링 결정이나 프로시저 동기화를 위해 커널을 호출하지 않는다 . 시스템 호출과 같은 인터럽트가 발생했을 때, 시스템은 프로세서 사이클을 몇개 사용해야 하는 오버헤드가 발생한다. 따라서 빈번하게 스레딩 연산을 수행하는 사용자 수준 멀티스레드 프로세스들은 이러한 연산을 커널에 의존해야하는 스레드보다 오버헤드가 적다. 사용자 수준 스레드의 성능은 시스템과 프로세스 동작에 따라 다르다. 사용자 수준 스레드의 단점은 커널이 멀티스레드 프로세스를 한 스레드로 간주한다는데 있다. 커널은 사용자 수준 스레드가 블록되면 다른 프로세스를 실행한다. 그런데 해당 프로세스가 블록된 프로세스에 있는 준비 상태 스레드보다 우선순위가 낮을 수 있다. 따라서 사용자 수준 스레드는 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다. 이는 특히 실시가 ㄴ멀티스레드 프로세스의 경우 매우 위험한 결과를 가져올 수 있다. 이런 문제를 해결하기 위해 몇몇 스레딩 라이브러리에서는 블록킹 시스템 호출을 넌블록킹 시스템 호출로 변환하기도 한다. 


### 4.6.2 커널 수준 스레드


커널 수준 스레드는 각 스레드마다 고유한 실행 문맥을 맵핑하는 방법으로 사용자 수준 스레드이 한계를 해결하려고 한다. 따라서 커널 수준 스레드를 종종 일대일 스레드 맵핑이라고 표현한다. 스레드를 일대일 맵핑하려면 운영체제에서 디스패치 할 수 있는 커널 스레드를 각 사용자 스레드에 제공해야한다. 커널 스레드는 프로세스의 주소 공간을 고융하기 때문에 중량 프로세스들과는 차이가 있다. 각 커널 스레드는 또한 레지스터 내용이나 스레드 식별자 처럼 개별 스레드에 국한되는 내용도 저장한다. 사용자 프로세스가 운영체제 api 로 정의된 시스템 호출을 통해 커널 수준 스레드를 요청할 때 운영체제는 사용자 스레드의 명령어를 실행하는 커널 스레드를 생성한다. 일대일 맵핑에는 몇가지 이점이있다. 커널은 프로세스의 스레드들을 몇몇 프로세서에 한꺼번에 디스패치 할수 있기 때문에 병렬 실행하도록 설계된 응용 프로그램의 성능을 높여준다. 또한 커널이 각 스레드를 개별적으로 관리할 수 있다. 즉 프로세스에 있는 스레드중 어느 하나가 블록된 상태일 때도 운영체제는 다른 준비 상태 스레드들을 실행할 수 있다. 그러므로 응용 프로그램은 입출력 작업이 끝날때까지 다른 스레드를 사용해 다른 작업을 진행할 수 있다. 이러한 방식은 사용자 입력에 빨리 반응할 수 있게 해서 응용 프로그램의 상호 작용성을 높여준다. 또한 병렬 실행의 이점을 이용해 성능도 높일 수 있다. 

운영체제의 디스패처는 커널수준스레드를 통해 사용자 스레드를 개별적으로 인식할 수 있다. 

커널 수준 스레드가 멀티 스레드 응용 프로그램에서 항상 최적의 해결책은 아니다. 커널 수준 스레드의 구현은 사용자 수준 스레드보다는 덜 효율적일 때가 있다 .스케줄링과 동기화를 위해 커널을 호출해야하는데, 이는 오버헤드를 증가시키기 때문이다. 또한 커널 수준 스레드를 사용하는 소프트웨어는 사용자 수준 스레드를 사용할 때보다 이식성이 떨어진다. 커널 수준 스레드를 사용하는 응용프로그램 프로그래머는 실행될 시스템이 달라지면 해당 운영체제에서 제공하는 스레드 API를 사용해 프로그램을 수정해야한다. POSIX 같은 표준 인터페이스를 준수하는 운영체제는 이런 문제를 없애준다. 커널 수준 스레드를 사용할 때 다른 단점은 사용자 수준 스레드보다 자원을 더 많이 소비하는 경향이 있다는 점이다. 결국 커널 수준 스레드를 사용하려면 운영체제가 시스템에 있는 모든 스레드를 관리해야한다. 사용자 수준 라이브러리가 수십 수백개 스레드를 관리해야 한다면, 운영체제는 수천개 스레드를 관리해야하는 것이다. 그 결과 응용프로그램 개발자는 운영체제의 메모리 관리나 스케줄링 서브시스템이 막대한 수의 스레드를 커버할 수 있는지 확인해야한다. 

### 4.6.3 사용자 수준 스레드와 커널 수준 스레드의 조합

솔라리스나 윈도우 XP를 비롯한 몇몇 운영체제는 다대일 맵핑과 일대일 맵핑을 조합한 스레드를 구현해 각 솔루션의 한계를 극복하려고 한다. 사용자 수준 스레드와 커널 수준스레드를 조합한 구현을 다대다 스레드 맵핑이라고 한다. 이름에서 알수 있듯이 이 방식은 많은 사용자 수준 스레드를 한그룹의 커널스레드에 맵핑한다. 어떤사람은 이러한 기술을 m대  n 스레드 맵핑 이라고 한다 . m to n thread mapping .

사용자 스레드 수와 커널 스레드 수가 다를 수 있기 때문이다.


일대일 스레드 맵핑을 하려면 운영체제가커널 스레드를 나타내는 자료구조를 할당해야한다. 결과적으로 시스템의 스레드가 증가함에 따라 커널 스레드에서 소비하는 자료구조의 용량이 크게 늘어난다. 다대다 스레드 맵핑은 스레드 풀링을 통해 이 오버헤드 문제를 해결한다. 이 기술을 사용하려면 응용 프로그램에서 필요한 커널 수준 스레드의 수를 명시해야한다. 스레드 풀링은 비용이많이 소모되는 스레드 생성및 소멸 횟수를 많이 줄일 수 있다. 예를 들어, 웹과 데이터베이스 시스템은 서비스 요청이 들어올 때마다 새로운 스레드를 생성한다. 스레드 풀링은 사용자 스레드가 종료한 후에도 커널 스레드가 시스템에 남아있게 해준다. 이러한 커널 스레드를 이후 새로 생성되는 사용자 스레드에 할당할 수 있다 . 각 요청이 이미 풀에 있는 스레드를 할당받기 때문에 웹 서버와 같은 환경에서 시스템의 반응 속도를 높여줄 수 있다. 이렇게 풀에서 지속되는 커널 스레드는 할당된 스레드에 따라 몇가지 다른 기능을 수행하기 때문에 작업자 스레드라고 한다. 

다대일 스레드 맵핑의 장점은 응용 프로그램들이 스레딩 라이브러리의 스케줄링 알고리즘을 필요에 맞게 커스터마이즈해 성능을 향상시킬 수 있다는 것이다. 스케줄러 활성화는 사용자 수준 스레드 라이브러리에 이벤트 발생을 알리는 커널 스레드다. 이런 형태의 커널 스레드를 스케줄러 활성화라고 하는데 이벤트 통지를 통해 활성화 되었을 때 사용자 수준 스레드 라이브러리가 스레드 스케줄링을 수행할 수 있기 때문이다. 

운영체제는 멀티스레드 프로세스가 생성될 때 프로세스의 사용자 수준 라이브러리의 초기화 코드를 수행하는 스케줄러 활성화를 생성한다. 이는 스레드를 생성하고 필요하면 스레드에 필요한 추가적인 프로세서를 요청한다. 운영체제는 프로세스에 할당된 프로세서마다 추가적인 스케줄러 활성화를 생성해서 사용자 수준 라이브러리가 멀티프로세서에 여러 스레드를 할당해 동시 실행할 수 있게 해준다.

운영체제는 사용자 수준 스레드가 블록되면 스레드의 상태를 해당 스케줄러 활성화에 저장하고 , 새로운 스케줄러 활성화를 생성해 사용자 수준 라이브러리에 자신의 스레드중 하나가 블록되었음을 알려준다. 이러한 메커니즘으로 한 스레드만 블록되어도 멀티스레드 프로세스 전체가 블록되는 현상을 방지할 수 있다.

## 4.7 스레드 구현시 고려 사항

### 4.7.1 스레드 신호 전달

신호는 하드웨어 인터럽트와 같이 프로세스 실행을 중단한다. 그러나 신호는 운영체제나 사용자 프로세스 같은 소프트웨어에서 발생시킨다. 신호는 유닉스 운영체제에서 도입한 이후 표준적인 프로세스 간 통신 메커니즘이 되었다. 원래 유닉스 운영체제는 스레드를 지원하지 않아서 신호를 프로세스 사이에서 사용하도록 설계했다.

운영체제가 프로세스에 신호를 전달할 때 프로세스는 실행을 중단하고 신호에 반응할 신호 처리기를 호출한다. 신호처리기가 처리를 마치면 프로세스는 실행을 재개한다. 신호에는 동기 신호와 비동기 신호라는 두가지 유형이 있다. 동기 신호는 프로세스나 스레드가 실행한 명령어의 직접적인 결과로 발생한다. 예를 들어 프로세스나 스레드가 불법적인 메모리 조작을 수행하려고 하면 운영체제는 프로세스에 동기 신호를 보내 예외를 알린다. 비동기 신호는 현재 실행하는 명령어와 무관한 다른 이벤트에서 발생한다.

이러한 신호는 신호를 받을 프로세스 ID를 명시해야한다. 비동기 신호는 프로세스에 입출력 완료 프로세스 일시정지, 프로세스 계속 실행을 통지하거나 프로세스를 종료해야함을 알리는등 다양한 목적으로 사용한다.

시스템에 있는 모든 프로세스가 프로그램 제어 흐름을 단 하나만 포함한다면, 신호 전달은 매우 분명할 것이다. 신호가 동기적인 경우 신호를 발생시킨 프로세서가 지금 실행하고 있는 프로세스에 신호를 전달하거나, 수신할 프로세스가 실행 상태가 될 때까지 기다렸다가 전달하도록 보류신호 큐에 저장할 수도 있다.

이제 멀티스레드 프로세스인 경우를 생각해보자 동기신호면 인터럽트를 생성해 신호를 발생시킨 프로세서에서 현재 실행되는 스레드에 해당 신호를 보내야할 것이다. 반면, 비동기 신호면 운영체제에서 신호의 수신자를 식별할 수 있어야한다. 한가지 방법은 송신자가 스레드 ID를 명시하도록 요청하는 것이다. 그러나 프로세스가 사용자 수준 스레드 라이브러리를 사용하면 운영체제는 신호를 받을 스레드를 결정할 수 없다. 

이에 대한 대안으로, 운영체제가 신호의 송신자가 프로세스ID를 명시하도록 신호를 구현할 수도 있다. 이경우 운영체제는 신호를 모든 스레드에 보낼지 몇몇 스레드 혹은 한스레드에 보낼지 결정해야한다. 이상하게 보일수도 있지만 실제로 이방식이 유닉스 시스템과 POSIX명세에서 채택한 신호 전달 모델이다. 이는 유닉스 운영체제용으로 작성한 원래의 응용프로그램들과 호환성을 유지하려는 것이다.

POSIX 명세에 따르며 ㄴ프로세스들은 스레드 ID가 아닌 프로ㅔㅅ스 식별자를 명시해 신호를 전달한다. POSIX 는 스레드 신호전달 문제를 해결하려고 신호 마스킹을 사용한다. 스레드는 신호 마스크를 사용해 특정 유형의 신호를 비활성화하고, 해당 유형의 신호들을 받지 않을 수 있다. 이렇게해서 스레드는 자신이 받고 싶은 신호를 제외하고 다른신호를 모두 마스킹할 수 있다 .이러한 접근법을 사용하면, 운영체제가 한 프로세스를 위한 신호를 받을 때 해당 프로세스에 속한 스레드중 해당 유형의 신호를 마스킹하지 않은 모든 스레드에 신호를 보낸다. 신호 유형과 기본동작 신호들은 자신에 대한 마스크가 풀릴 때까지 큐에 대기할 수도 있고 단순히 버려질 수도 있다. 

POSIX 신호 전다 ㄹ메커니즘을 구현할 때 운영체제는각 사용자 스레드를 위한 신호 마스크의 위치를 찾을 수 있어야한다. 일대일 스레드 맵핑은 이 문제를 간단하게 해준다. 운영체제가 각 커널 스레드에 신호 마스크를 붙일 수 있고, 이는 사용자 스레드 하나와 정확히 대응하기 떄문이다. 그러나 시스템이 다대다 모델을 사용하는 경우, 신호 마스킹이 복잡한 문제가 될 수 있다. 한 프로세스를 위한 비동기 신호가 생성되고 해당 신호를 마스킹 하지 않은 유일한 스레드가 현재 실행 상태가 아닐 경우를 생각해보자. 이경우 운영체제는 신호를 보류 신호리스트에 추가할수도 있고 그냥 잃는 경우도있다 .일반적으로는 프로세스나 스레드들에 중요한 이벤트를 알리는데 신호를 사용하므로 운영체제가 신호를 버리면 안된다. 다대다 스레딩 모델에서 신호들을 보류하는 방식을 구현하는 한가지 방법은 각 멀티스레드 프로세스마다 커널 스레드 한개를 생성하는 것이다. 이러한 커널 스레드는 비동기 신호들을 모니터링하고 전달한다. 솔라리스 7 운영체제는 비동기 신호 경량 프로세스라는 스레드를 따로 만들어 신호 발생시 스레드가 실행 상태가 아닌경우에도 신호를 모니터링하고 보류 신호들을 관리해 적절한 스레드에 전달되게 해준다.

멀티스레드 프로세스가 사용자 수준 라이브러리를 ㅏㅅ용하면 각스레드를 구별할 수 없으므로 운영체제는 단순히 모든 시놓를 프로세스에 전달한다. 사용자 수준 라이브러리는 운영체제에 신호 처리기를 등록해 신호를 받을 때 실행되게 한다. 그러면 프로세스의 사용자 수준 스레드 라이브러리는 자신의 스레드들 중 해당 신호를 마스킹하지 않은 모든 스레드에 해당 신호를 보낸다.

### 4.7.2 스레드 종료

스레드가 실행을 완료하고 정상적으로 종료할 때, 운영체제는 시스템에서 스레드를 제거한다. 스레드는 공유 데이터를 수정하거나 해서 협력하기 떄문에 응용 프로그램은 자신의 스레드중 어느 하나가 예상치 못하게 종료할 때 미묘한오류를 일으킬 수도 있다. 결과적으로 스레딩 라이브러리들은 언제 어떻게 시스템에서 스레드를 제거해야할지 신중하게 결정해야한다. 스레드는 취소 신호를 마싕해 취소 신호를 비활성화 할수도 있다. 대개는 공유 데이터의 값을 수정하는 등 종료 전에 꼭 완료해야 할 작업을 수행할 때만 취소 마스킹을 사용한다. 



## 4.8 POSIX 와 Pthread

Portable Operating System Interface for computing environment 는 IEEE 의 PASC portable application standards commitee 에서 발표한 운영체제 인터페이스의 표준 집합으로 대체로 유닉스 시스템에 기초한다. POSIX 명세는 스레드와자신의 스레딩 라이브러리 사이에 표준 인터페이스를 정의한다. POSIX 스레딩 API 를 사용하는 스레드를 Pthread 라고 하며, 떄로는 POSIX 스레드 혹은 POSIX 스레드 라고도 한다. 


