# GraphQL 소개

발명은 필요에서부터 시작된다.

페이스북이 그래프QL을 만들기로 한 이유는 모바일 애플리케이션 개발 시 발생하는 여러 기술적인 문제를 해결하기 위해서였습니다. 하지만 현재 그래프QL이 인기를 얻고 있는 이유는 기술적 문제보다는 커뮤니케이션 문제를 해결하기 때문이다.

커뮤니케이션은 아주 어려운 기술이다.

커뮤니케이션 능력을 키우면 다양한 방면에서 삶이 윤택해진다. 마찬가지로 소프트웨어의 각기 다른 부품 간에 발생하는 커뮤니케이션의 품질을 향상시키면 해당 소프트웨어를 이해하기 쉬워질 뿐만 아니라, 개발, 유지관리, 확장도 쉬워진다.

그래프QL이 판도를 바꿀 수 있다고 생각하는 것도 이 때문이다. 서로 다른 소프트웨어 (프론트엔드와 백엔드)가 커뮤니케이션하는 방법을 바꿔버리는 게임 체인저이다. 프론트엔드와 백엔드에 동등한 힘을 실어주면서, 서로 독립할 수 있게 해준다. 또한, 둘 사이의 커뮤니케이션 프로세스를 기술적 전송 채널에서 분리해주며, 말로는 한정된 단어밖에 사용할 수 없는 일반 커뮤니케이션 언어를 대체하도록 표현력이 풍부한 언어를 제공한다.

## GrapQL이란?

그래프QL의 그래프는 현실 세계의 데이터를 표현하는 가장 적합한 방법이 그래프라는 사실에 착안했다. 크든 작든 데이터 모델을 분석하게 되면 객체 간의 관계를 그래프로 표현한 것을 보게된다.

그래프로 생각하면 더 쉬운 것을 왜 굳이 URL에 포함된 리소스나 테이블로 생각하는 것일까? 그렇다고 그래프 QL을 그래프 데이터베이스에서만 사용할 수 있는 것은 아니다. 문서형 데이터베이스(MongoDB)나 관계형 데이터베이스는 물론이고 API 데이터를 그래프 형태로 표현할 때도 사용할 수 있다.

GraphQL의 QL은 Query Language를 의미해 오해를 불러일으킬 수 있다. API를 사용하는 프론트엔드 입장에서만 보면 그래프QL은 데이터 API용 쿼리 언어가 맞지만, 한편으로 백엔드에서 구현돼야 하는 런타임 계층의 역할도 한다. 프런트엔드는 이 런타임 계층이 제공하는 새로운 언어를 사용해서 데이터를 받는다.

그래프 QL언어는 선언적이며 유연하고 효율적으로 설계되었다. 데이터 API를 사용하는 클라이언트 (모바일이나 웹 애플리케이션)개발자는 서버에 저장된 데이터 구조나 데이터 관계를 이해할 필요가 없다. 머리 속에 떠오른 그대로 유사한 언어를 사용해서 원하는 데이터를 요청하면 된다.

백엔드에는 GraphQL 기반 런타임이 필요하다. 이 런타임은 API를 통해 제공될 데이터의 구조를 관리한다. 이 구조를 그래프QL에서는 스키마라고 부른다. API 사용자는 그래프 QL 언어를 사용해서 필요한 데이터를 정확하게 요구하기 위한 텍스트를 구성하고 클라이언트는 이 텍스트 요청을 전송 채널(예:HTTPS)를 통해 API 서비스에 전달한다. 그러면 그래프QL의 런타임 계층이 이 텍스트 요청을 받아서 백엔드에 있는 다른 서비스들과 커뮤니케이션하고 그 결과들을 모아서 적합한 데이터를 만든다. 그렇게 만들어진 데이터를 JSON과 같은 형식으로 API 사용자에게 반환하는 것이다.

그래프QL은 백엔드나 프런트엔드 프레임워크, 기술 스택, 데이터베이스 등 어떤 것에도 종속되지 않는다. 즉 아무 프론트엔드, 백엔드 환경에서든 어떤 데이터베이스를 사용해도 된다는 의미이다. 전송 채널이나 데이터 형식에도 제한이 없다.

그래프QL을 사용하기 위해 리액트나 아폴로, 릴레이가 필요한 것은 아니지만, 이런 라이브러리들과 함께 사용하면 복잡한 데이터 관리 작업을 알아서 해주므로 그래프QL의 활용도를 높여준다.

일반적으로 API란 애플리케이션 상에 있는 다수의 컴포넌트 간의 커뮤니케이션을 원활하게 만드는 인터페이스를 의미한다. 예를 들어, 어떤 API는 웹 클라이언트와 데이터베이스 서버 간 커뮤니케이션을 가능하게 해준다. 클라이언트는 필요한 데이터를 서버에 요청하고 서버는 클라이언트가 요구한 데이터를 객체로 반환한다.

API에는 여러 종류가 있으며 규모가 큰 애플리케이션은 모두 API를 가지고 있다. 그래프QL에서 말하는 API는 데이터를 읽고 수정하기 위한 API로 이것을 데이터 API라고 한다.
그래프QL은 프로그래밍 가능한 많은 인터페이스중 하나로 애플리케이션이 필요로 하는 데이터를 읽고 수정할 수 있게 해준다. 그래프QL 이외에도 REST, SOAP, XML등의 인터페이스가 있으며 SQL도 여기에 포함된다.

SQL(Structured Query Language)는 QL이라는 이름 때문에 그래프 QL과 비교 대상이 되기도 한다. SQL과 그래프QL모두 데이터 스키마를 요청할 수 있는 언어이며, 양쪽 모두 데이터를 읽고 수정할 수 있다.

> SQL은 데이터 교환을 위해 모바일이나 웹 애플리케이션에서 사용하기에 적합하지 않다. SQL은 강력하면서도 유연성이 높으므로 오히려 문제를 초래할 수 있다. 예를 들면 데이터베이스 구조를 노출시켜서 심각한 보안 문제를 불러오기도 한다. 이런 문제를 보안하기 위해 SQL을 다른 서비스 계층에 둘 수 있지만, 사용자의 SQL 쿼리를 서버에 보내기 전에 처리할 수 있는 파서(parser)나 분석기(analyzer)를 만ㄷ르어야한다. 이 파서와 분석기의 역할을 대체하는 것이 그래프QL 서버이다.

**특정 데이터베이스에서 그래프QL언어로 만들어진 쿼리를 실행하려면 런타임이 있어야한다. 즉 그래프QL을 지원하는 서비스 계층을 설정하거나 직접 해당 기능을 구현해야한다.**

JSON은 데이터 교환을 위해 사용되는 언어이다. JSON은 API 서버에서 클라이언트로 데이터를 전송할 때 자주 사용되는 언어이다. 대부분의 최신 API 서버는 JSON을 사용해서 클라이언트 애플리케이션이 요구하는 데이터를 전달한다. 그래프QL 서버도 예외는 아니다.JSON은 GrahpQL의 데이터 요구사항을 만족시켜주는 일반적인 옵션중 하나이다.

그래프QL 쿼리를 한번 보자.

```
{
  employee(id: 42) {
    name
    email
    birthDate
    hireDate
  }
}
```

그래프QL 서버는 이 구문을 해석해서 데이터 저장 엔진이 이해하는 언어로 변환한다. (예: 쿼리를 해석해서 관계형 데이터베이스에 SQL로 전달한다.) 그리고 저장 엔진이 반환한 응답을 JSON이나 XML로 변환해서 클라이언트에게 전달한다.

이런 방식은 어떤 저장 엔진을 사용하든 유용하다. 저장 엔진의 종류와 상관없이 API 서버와 클라이언트 애플리케이션이 공용 언어로 된 요청과 응답을 처리할 수 있다. 간단히 말하자면 그래프QL은 클라이언트와 서버간 데이터 교환을 최적화하기 위한 툴이다. 구체적으로 살펴보면 클라이언트는 필요한 데이터를 서버에 요청하기 위한 커뮤니케이션을 수행하고, 서버는 이 요청에 응답하기 위한 데이터를 준비해서 클라이언트에게 반환합니다. 그래프QL은 클라이언트가 필요한 데이터를 정확하게 요청할 수 있게 도와주며, 서버가 다수의 데이터 저장소로부터 필요한 데이터를 쉽게 추출할 수 있게 해준다.

그래프QL의 핵심은 데이터를 정의하고 API를 관리할 때 사용하는 강력한 타입시스템이다. 이 타입시스템은 여러 면에서 서버와 클라이언트 양쪽에 유용하게 활용된다. 클라이언트는 요청할 수 있는 데이터 타입을 명확하게 제시하고 잘못된 경우에는 자세하고 유용한 오류 메시지를 제공한다. 또한 클라이언트는 타입을 사용해서 데이터 요소를 전달하기 위한 수작업을 최소화한다. 그래프QL의 타입 시스템은 내향성 API같은 고급 기능이나 클라이언트와 서버용 툴을 구축할 수 있게 해준다. 대표적인 툴 중 하나가 바로 그래피컬로 그래프QL 요청을 확인하거나 테스트하는 브라우저 기반의 편집기이다.

그래프QL의 이름에는 질의를 뜻하는 Query의 Q가 있지만 질의란 읽는 행위에만 국한된 단어이다. 그래프QL은 데이터 읽기뿐만 아니라 수정도 할 수 있다. 그래프QL을 사용해서 데이터를 읽을 때는 쿼리를 사용하고 수정할 때는 변경(mutation)을 사용한다.

그래프QL은 쿼리와 변경 외에 구독(subscription)이라고 하는 요청 타입도 지원한다. 실시간으로 데이터를 모니터링하는 요청 타입이다. 구독 요청은 보통 변경이 시발점이 되어 발생한다. 또한, 구독은 지속적으로 데이터를 전달할 수 있는 데이터 전송 채널을 필요로 하며, 웹 애플리케이션에선 보통 웹소켓이 이 역할을 한다.

과거에는 컴퓨터가 명령한 것만 이해할 수 있었으므로 명령형 패러다임(imperative paradigm)을 사용해서 프로그램을 만들었다. 하지만 현재 컴퓨터는 선언적 패러다임(declarative paradigm)을 이해하기 시작했으며, 우리가 원하는 것을 이해하는 프로그램을 만들 수 있게 되었다.

선언적 프로그래밍은 여러 장단점을 가지고 있지만, 무엇보다 의미가 있는 것은 사람이 어떤 문제의 원인을 생각할 때 선언적으로 접근하는 것이다. 사람은 선언적으로 사고하는데 익숙하다.

클라이언트 애플리케이션에게 그래프QL 언어를 가르칠 수 있다면, 그래프QL 언어를 이해하는 백엔드 서비스와 데이터 요건에 관한 대화를 나눌 수 있을 것이다. 데이터 서비스가 그래프QL 언어를 이해하게하려면 런타임 계층을 만들어서 클라이언트를 향해 노출하면 된다. 서버에 있는 이 계층을 그래프QL 언어의 통역기 또는 그래프QL 언어를 이해하는 데이터 서비스의 중개인이라고 생각하면 쉽다.

그래프QL 서비스는 원하는 프로그래밍 언어를 사용해 구현할 수 있으며, 개념적으로는 구조와 행동으로 나뉜다.

- 구조: 강력한 타입의 스키마를 사용해서 정의한다. 그래프QL의 스키마는 그래프QL API가 처리할 수 있는 모든 작업을 정리해 둔 것이다. 간단히 말해서 API가 무엇을 할 수 있는지 기술한 것이다. 그래프QL 클라이언트는 이 스키마를 통해 어떤 질문을 서비스에 할 수 있는지 알 수 있다. 스키마의 타입은 그래프QL의 핵심 개념이다. 스키마는 기본적으로 타입을 가진 필드들을 그래프로 나타낸 것이며 이 그래프는 데이터 서비스를 통해 읽고 수정할 수 있는 모든 데이터 객체를 보여준다.
- 행동: 함수를 통해 구현하며 그래프QL 세계에서는 이 함수를 리졸버 함수라고 한다. 리졸버 함수는 그래프QL의 뒤에서 움직이는 대부분의 처리 로직으로 강력한 기능성과 유연성을 가지고 있다. 또한 그래프QL 스키마의 각 필드는 리졸버 함수와 연동되며, 리졸버 함수에는 각 필드가 어떤 값을 가져와야하는지 정의한다.

리졸버 함수는 어디서 어떻게 데이터를 가져올지를 지시한다. 예를들면 관계형 데이터베이스에 SQL문을 던지거나, 운영체제에 있는 파일로부터 데이터를 바로 읽을 수도 있으며, 문서형 데이터베이스에 있는 캐시 데이터를 변경할 수도 있다. 하나의 리졸버 함수는 그래프QL 요청 안에 포함된 하나의 필드와 직접 연동되며, 단일 초기값이나 객체, 값 또는 객체의 리스트를 표현할 수도 있다.

그래프QL 커뮤니티에선 서버측 언어를 클라이언트측 쿼리 언어처럼 그래프QL 스키마 객체 생성용으로 표준화하고 있다. 이 서버측 언어를 스키마 언어라고 하며 줄여서 SDL(Schema Definition Language) 또는 IDL(Interface Definition Language)이라 부르기도 한다.

그래프QL은 특정 데이터 직렬화방식을 요구하지는 않지만 JSON이 대중적으로 사용된다.

## 왜 그래프QL인가?

표준

그래프QL은 관리와 확장이 용이한 API 기능을 광범위한 표준과 구조를 사용해서 구현할 수 있다. 그래프QL에선 데이터 API의 기능 범위를 반드시 문서(스키마)를 통해 공개할 것을 규칙으로 정하고 있다. 클라이언트는 이 스키마를 통해 서버에서 할 수 있는 모든 것을 파악할 수 있다.

그래프QL 표준 스키마는 모든 그래프QL API가 따라야 하며, 클라이언트는 이 스키마 정보를 그래프QL 언어를 사용해서 서비스에 요청할 수 있다.

그래프QL는 문서화가 API 서비스를 만드는 과정의 일부이다. 이렇게 만들어진 문서는 항상 최신 정보를 담으며, 특정 사용 용도에 대한 정보를 항상 기록하게 된다. 또한 표준이 정해져 있으므로 문서에서 실제 API와 다른 사용법을 안내할 수 없다. 무엇보다 문서와 API를 별도로 관리하지 않아도 된다. 그래프QL의 문서는 내장형이며 품질 수준도 높다.

필수 그래프QL 스키마는 그래프QL 서비스가 할 수 있는 작업과 제한사항을 알려준다. 또한 스키마가 노드 구조의 그래프로 구성돼 있어서 다양한 경로를 만들 수 있으며, 이는 스키마에게 유연성을 부여한다. 이 유연성은 그래프QL의 가장 큰 장점으로 백엔드와 프런트엔드 개발자가 서로 별도의 논의 없이도 각자 개발을 진행할 수 있도록 만든다.

**클라이언트와 서버를 분리시켜서 각자 독립적으로 발전, 확장할 수 있게 해줘서 결과적으로는 양쪽 제품의 개발 주기가 단축된다.**

클라이언트 서버 구조에서 그래프QL을 선택하는 가장 중요한 기술적 이유는 효율성이다. API 클라이언트는 종종 서버에게 여러 리소스를 요청해야 하지만 API 서버는 보통 하나의 리소스만 응답하는 방법을 안다. 결과적으로 필요한 모든 데이터를 얻기 위해선 클라이언트가 서버에게 여러번 요청하게 된다.

그래프QL은 이런 다중 요청의 복잡성을 백엔드에 부담시켜서 그래프QL 런타임이 처리하도록 만든다. 클라이언트가 그래프QL 서비스로 하나의 질문을 던지면 서비스는 필요한 정보를 정확하게 하나의 응답에 담아서 반환한다.

그래프QL의 또 다른 기술적 이점은 여러 서비스와 커뮤니케이션 할 수 있다는 것이다. 클라이언트가 여러 데이터 저장소(mongodb, postgresql, redis, cache)로부터 데이터를 요청할 때, 중간에 있는 그래프QL 계층이 커뮤니케이션을 단순화 및 표준화한다. 클라이언트는 여러 서비스에 직접 접속하는 것이 아니라 그래프QL과 커뮤니케이션 하며, 요청을 받은 그래프QL 서비스는 여러 데이터 서비스와 커뮤니케이션한다. 이를 통해 클라이언트는 단일 언어만 사용해서 다양한 서비스와 데이터를 교환할 수 있다.

클라이언트는 여러 서비스에 직접 접속하는 것이 아니라 그래프QL과 커뮤니케이션 하며, 요청을 받은 그래프QL 서비스는 여러 데이터 서비스와 커뮤니케이션한다. 이를 통해 클라이언트는 단일 언어만 사용해서 다양한 서비스와 데이터를 교환할 수 있다. 그래프QL은 클라이언트 요청 하나를 다른 언어를 사용하는 서비스 요청 여러개로 변환한다.

그래프QL은 프런트엔드 개발자의 작업 효율을 높여준다는 장점이 있지만 이는 가끔 과소평가 받기도 한다. 그래프QL 스키마를 사용하면 프런트엔드 개발자가 백엔드 개발자에 의존하지 않고서도 데이터 관련 처리를 생성하거나 확인하고 검증, 테스트 할 수 있는 힘과 제어권을 가지게 된다. 이를 통해 서버에서는 데이터의 형식이나 크기를 하드코딩하지 않아도 되며, 클라이언트와 서버 처리를 분리할 수도 있다. 결과적으로 클라이언트와 서버를 독립적으로 개발 및 관리할 수 있게 되며, 이 자체만으로 상당한 이익을 보는 셈이다.

### REST API와의 차이점

그래프QL API는 종종 REST API와 비교된다. REST API가 웹 및 모바일 애플리케이션용 데이터 API에서 가장 대중적인 기술이었기 때문이다. 그래프QL이 REST API를 대체할 수 있는 기술이라고하는데, 대체 기술이 필요한 이유는 뭘까? REST API에 어떤 문제가 있는 것일까?

REST API가 가진 가장 큰 문제점은 클라이언트가 여러개의 데이터 API 엔드포인트와 커뮤니케이션 한다는 것이다. REST API는 클라이언트가 데이터를 받기 위해서 네트워크를 여러번 반복해야한다. REST API는 리소스별로 엔드포인트를 가지므로 엔드포인트의 집합이라고 볼 수 있다. 따라서 여러 리소스에서 데이터를 가져와야한다면 REST API에 여러개의 네트워크 요청을 던져야 하며, 응답 역시 여러개의 응답을 받아 결합해야한다.

또한 REST API에는 클라이언트용 요청 언어가 없다. 클라이언트가 서버에 무엇을 원하는지 정확하게 알릴 수 있는 언어가 없으므로 서버가 반환하는 데이터를 제어할 수 없다. 정확하게 말하면 있긴 있지만 매우 제한된 언어만 사용할 수 있다. 예를 들면, REST API에서 데이터를 읽으려면 GET /ResourceName 형식으로 리소스의 전체 데이터를 읽어 들이거나, GET /ResourceName/ResourceID 형식으로 지정한 ID의 단일 데이터만 읽어야한다.

순수 REST API를 사용하면 클라이언트가 리소스에서 레코드를 추출할 때 특정 필드를 지정할 수 없다. 클라이언트가 필요로 하는 데이터와 상관없이 REST API 서비스는 항상 모든 필드를 반환한다. 그래프 QL에선 이런 문제를 정ㅂ의 과다 충출(overfetching)이라고 부르며 발생해서는 안되는 문제로 간주한다. 클라이언트와 서버 양쪽의 네트워크 및 메모리 리소스를 낭비하는 것이다.

REST API의 또 다른 문제는 버전 관리이다. 여러 버전을 제공해야한다면, 엔드포인트도 여러개 준비해야 한다. 이것은 엔드포인트를 사용하고 관리할 때 더 문제가 되며 서버상의 코드 중복 문제도 초래할 수 있다.

REST API는 결국 여러개의 REST 엔드 포인트가 얽혀 있는 상태가되며, 성능상의 문제로 임시 엔드포인트까지 추가되기도 한다. 이런 지점에서 더 나은 대체 기술로 그래프QL을 제시할 수 있다.

한편 REST API가 그래프QL보다 우수한점도 있다는 것을 간과해서는 안된다. 예를들어 REST API의 응답을 캐싱하는 편이 그래프QL API의 응답을 캐싱하기보다 수비다. 또한 여러 REST 엔드포인트의 코드를 최적화하는 것이 그래프QL의 단일 엔드포인트를 최적화하는 것보다 쉽다. 동일 시스템에서 둘을 같이 사용해도 전혀 문제가 없다.

### 그래프QL의 방식

그래프QL이 REST API가 지닌 문제점을 해결하는 방식을 파악하기 위해서는 그래프QL의 배경이 되는 컨셉과 설계 이념을 이해해야한다.

그래프QL API를 만들려면 타입이 정해진 스키마가 필요하다. 그래프QL 스키마는 타입을 가진 필드로 구성된다. 이 타입은 기본 타입일 수도 있고 개조된 타입일 수도 있다. 그래프QL 스키마 내에 있는 모든 것이 타입을 지니며 이런 타입 구조가 그래프QL 서비스를 예측하고 검색할 수 있게 해준다.
그래프QL 데이터 요건을 표현하기 위해 선언적 방식을 사용한다. 클라이언트는 데이터를 표현하기위해 선언적 언어(declarative language)를 사용한다. 이런 선언적 방식은 특정 모델을 그래프QL 언어로 생각할 수 있게 해주며, 다른 대체 기술보다 그래프QL API를 훨씬 사용하기 쉽게 만든다.

여러번 왕복해서 통신하는 문제를 해결하기 위해서 그래프QL은 응답하는 서버를 단일 엔드포인트로 만든다. 기본적으로 엔드포인트 수정 원리를 최대한 활용해서 전체 서버를 한 개의 똑똑한 엔드포인트로 만들어 모든 요청에 응답하게 한다.

똑똑한 단일 엔드 포인트와 함께 중요한 역할을 하는 것이 풍부한 클라이언트 요청 언어이다. 클라이언트 요청 언어가 없으면 단일 엔드포인트는 무용지물이다. 즉 언어를 사용해서 변경된 요청을 처리할 수 있어야하며, 해당 요청이 필요한 데이터를 반환할 수 있어야한다.

클라이언트 요청 언어는 클라이언트가 제어권을 갖도록 해준다. 클라이언트는 필요한 것을 정확하게 요청할 수 있으며, 서버 또한 요청받은 데이터를 정확하게 응답할 수 있다. 이것은 overfetching을 해결한다.
또한 클라이언트가 필요한 것을 정확히 요청할 수 있다면 백엔드 개발자 측면에서 어떤 데이터가 사용되고 데이터의 어떤 부분이 자주 요구되는지를 분석할 수 있게 된다. 이런 분석 정보는 사용 패턴을 기반으로 데이터 서비스를 확장하거나 최적화할 수 있게 해주므로 매우 유용하다. 뿐만 아니라 사용자의 이상 행동 패턴이나 클라이언트의 버전 변경등도 감지할 수 있다.

그래프QL은 버전 관리 측면에서 흥미로운 구조를 지닌다. 따로 버전 관리를 할 필요가 없다.

그래프 구조를 가지고 있기 때문에 기존 필드를 삭제할 필요 없이 새 필드를 새로운 노드로 추가하면 되는 것이다. 새 엔드포인트를 추가할 필요 없이 API만 확장한다. 클라이언트는 이전 기능을 그대로 쓸 수 있으며 새 기능을 사용하려면 기존 코드에 변경된 부분만 추가하면 된다. 하나의 버전이 계속 확장 및 진화해 나가므로 클라이언트는 기존 및 새 기능들을 지속적으로 사용할 수 있으며, 서버는 간결하고 관리하기 쉬운 코드를 유지할 수 있다.

순수 REST API의 경우 백엔드 개발자에게 요청해서 우리가 만들 뷰를 위한 엔드포인트를 별도로 만들어 달라고 요청해야한다. 이것이 REST API가 지닌 확장성의 한계이다. 클라이언트의 늘어나는 요청을 만족시키려면 별도의 엔드포인트를 추가해야하며 이런 엔드포인트들을 일일이 관리하기는 매우 힘들다.

한번의 네트워크 왕복만으로 필요한 데이터를 얻으려면 복잡한 데이터 요건을 서버에게 전달할 방법이 필요하다. 이때 필요한 것이 그래프QL 쿼리이다.

```
GET or POST - /graphql?query={...}
```

그래프QL 쿼리는 단순한 문자열로 필요한 모든 데이터의 요건을 지정해야한다. 이 부분이 바로 선언적 방식의 힘이 유감없이 발휘되는 부분이다.

```
{
  person(ID: 1) {
    name
    birthYear
    planet {
      name
    }
    films {
      title
    }
  }
}
```

필요한 데이터를 정확하게 요청해서 받을 수 있을 정도로 자세하다.

뷰와 데이터간의 명확한 연계는 그래프QL이 가진 아주 강력한 기능 중 하나이다. UI 뷰는 필요한 데이터를 정확하게 찾을 수 있으며 뷰 코드에서 데이터 요건을 추출하는 것도 쉽다. 단순히 뷰에서 어떤 변수를 사용하는지만 찾으면 된다.

그래프QL 쿼리가 응답과 동일한 구조를 가지므로 쿼리만 보고서도 UI와 데이터를 어떻게 연결시켜야 하는지 알 수 있다. 즉, 데이터를 사용하기 위해서 응답을 볼 필요가 없으며 API 문서를 참고할 필요도 없는 것이다. 모든 정보가 이미 쿼리에 들어있기 때문이다.

그래프QL은 필요한 데이터 요건을 일반 언어와 비슷한 방식으로 표현했고, 한 번의 네트워크 통신으로 필요한 모든 데이터를 얻어냈다.

## 그래프QL의 문제점

완벽한 솔루션이란 없다. 그래프QL이 가진 유연성이 떄론 문제의 원인이 되기도 한다.

그래프QL API에 있어 큰 위협이 되는 것은 DDos(Distributed Denial-Of-Service attack) 분산 서비스 거부 공격이라고 알려진 자원 잠식 공격(resource-exhaustion attack)이다. 그래프QL 서버는 아주 복잡한 쿼리에 의해 공격받을 수 있으며, 이 경우 서버의 모든 자원을 잡아먹는다. 다중 중첩된 쿼리 (사용자 -> 친구 -> 친구 -> 친구,,,)를 쉽게 요청할 수 있으며, 필드 별칭을 사용해서 동일 필드에 대한 정보를 여러번 요청할 수도 있다. 자원 잠식 공격은 그래프QL만이 지닌 문제는 아니지만 그래프QL을 사용할 때 유의해야할 사항이다.

이를 방지하기 위한 몇가지 방법이있다. 첫번째는 쿼리의 효율성을 미리 분석해서 사용되는 데이터의 양을 제한하는 방법이다. 두번째는 타임아웃을 설정해서 처리 시간이 오래걸리는 요청을 정지시키는 것이다.
세번째는 그래프QL 서비스가 애플리케이션 스택의 한 계층이란 점을 사용해 그래프QL 보다 낮은 계층에서 강제적으로 처리량을 제어하는 것이다.

그래프QL API의 엔드포인트가 외부에 공개되어있지않고 클라이언트에서 내부적으로 사용한다면 허용 리스트를 만들어서 사전에 서버가 실행할 수 있는 쿼리를 지정해두는 방법이 있다. 이렇게 하면 클라이언트는 고유의 쿼리 식별자를 사용해서 서버에게 허용 목록에 있는 쿼리만 요청할 수 있다. 이 방법은 서버와 클라이언트간의 의존성을 요구하지만, 자동화를 통해 해결할 수 있다.

그래프QL을 다룰 때 인증과 권한 관리 또한 해야하며, 필드를 리졸브 하기 전후나 리졸브 중에 할 수 있다. 어느 시점에 하는 것이 적절할까?
이 질문에 답하려면 그래프QL을 백엔드의 데이터 추출 로직과 함께 도메인 특화 언어(domain specific language)로 생각해야한다. 그래프QL은 단순히 클라이언트와 서버 사이에 둘 수 있는 하나의 층이다. 인증과 권한 관리는 다른 계층으로 생각해야한다. 그리프QL은 인증이나 권한 관리 로직에 관여하지 않는다.

인증과 권한 관리 계층을 그래프QL 뒤에 두고 싶다면 그래프QL이 클라이언트와 인증 로직 사이에 있는 엑세스 토큰에 접근하도록 하면 된다.이 방식은 REST API에서 사용하는 인증 및 권한 관리 방법과 비슷하다.

그래프QL에서 어려운 것 중 하나가 데이터의 캐싱이다. REST API의 응답은 딕셔너리 구조이기 때문에 훨씬 캐시가 쉽다. 특정 URL이 정해진 데이터를 반환하므로 URL 자체를 캐시키로 사용할 수 있기 때문이다.

그래프QL에서도 비슷한 방식을 사용할 수 있다. 쿼리 텍스트를 키로 사용해서 응답을 캐싱하는 것이다. 하지만 이 방법은 비효율적이며 데이터 일관성 문제를 초래할 수도 있다. 여러개의 그래프QL 쿼리 결과는 쉽게 중복될 수 있으며, 이 기본 캐시 방법으로는 중복 데이터를 가려 낼 수 없다.

이 문제를 해결하기 위한 훌륭한 방법은 바로 그래프캐시를 사용하는 것이다. 그래프QL의 응답을 평면 구조의 레코드 집합으로 일반화한 후 각 레코드에 전역 고유 ID를 부여하면 전체 응답이 아닌 개별 레코드를 캐싱할 수 있다.
하지만 이 처리는 쉽지 않다. 다른 레코드를 참조하는 레코드가 있으면 순환 그래프를 관리해야한다. 또한 캐시를 생성하고 읽으려면 쿼리 구조를 구성해서 읽어야하며 이를 위해선 별도의 계층을 만들어서 처리해야할 수도 있다.
하지만 이 방법이 응답기반 캐시보다 훨씬 효율적이다.

그래프QL을 사용하면서 겪게 될 또 다른 문제는 N+1 SQL 쿼리이다. 그래프QL 쿼리 필드는 독립형 함수로 설계돼 있으며 이 필드들을 데이터베이스의 데이터와 연결하기 위해서 새로운 데이터베이스 요청을 만들어야할 수도 있다.
단순한 REST API 엔드포인트 로직은 SQL 쿼리를 개선하므로 쉽게 N+1 문제를 분석하고 해결할 수 있다.

다행히 페이스북에서 데이터 로딩 최적화 문제를 위한 해결책으로 데이터로더라는 툴을 제시했다. 이름에서도 알 수 있듯 데이터 로더는 데이터베이스에서 데이터를 읽어 그래프QL의 리졸버 함수가 사용할 수 있게 준비해주는 유틸리티이다. 데이터베이스에 SQL쿼리를 사용해서 데이터를 직접 요청하는 대신 데이터 로더를 통해 읽는 것이다. 데이터로더는 중개인으로서 데이터베이스로 보내는 SQL 쿼리를 줄여준다.

데이터 로더는 일괄 처리와 캐시를 조합해서 문제를 처리한다. 데이터베이스에 여러가지를 요구할 때는 데이터로더가 요청 내용을 하나로 통합해 한번의 클라이언트 요청으로 데이터베이스의 데이터를 일괄적으로 불러온다. 또한 데이터베이스의 응답을 캐시해두었다가 동일 리소스에 대한 요청이 들어오면 사용한다.

## 정리

- 그래프 데이터 구조는 실세계의 데이터를 표현하는 최고의 방법이다. 그래프QL은 데이터 모델이 연관된 객체를 그래프로 표현하는데 중점을 두고 있다.
- 그래프QL 시스템은 크게 두가지 요소로 구성된다. 첫 번째는 쿼리언어로, 데이터 API 사용자가 필요한 데이터를 정확하게 표현할 수 있게 해준다. 두 번째는 백엔드에 있는 런타임 계층으로 쿼리 언어와 API의 기능과 데이터 모델 요건을 기술한 스키마를 소개한다. 이 런타임 계층은 단일 엔드포인트를 사용하여 그래프QL 쿼리 언어로 작성된 요청을 받는다. 런타임은 이에 비슷한 형태로 데이터를 응답한다.
- 그래프QL은 클라이언트와 서버 간 데이터 통신을 최적화하는 기술이다. 클라이언트는 필요한 데이터를 선언적 방식으로 정확하게 요청할 수 있으며 서버는 표준 방식을 사용해 여러 데이터 소스로부터 데이터를 불러와서 하나로 결합한다.
- 그래프QL은 공식 사양서를 제공하며 런타임 구현시에 따라야할 모든 표준 규칙과 방법을 기술한다.
- 어떤 프로그래밍 언어를 사용하든 그래프QL 서비스를 만들수 있으며, 이 서비스는 개념상 두가지 부분으로 나뉜다. 첫번쨰는 API의 기능을 나타내는 강한 타입의 스키마 구조이고 두번째는 리졸버라고 하는 함수를 사용해서 자연스럽게 구현되는 동작이다. 그래프QL 스키마 타입을 가진 필드 그래프로, 그래프QL 서비스를 통해 읽고 변경할 수 있는 모든 객체를 나타낸다. 그래프QL 스키마에서 각 필드는 리졸버 함수와 연동된다.
- 그래프QL은 기존 기술들과 달리 표준과 구조를 제공해 API의 기능을 관리 및 확장하기 쉽게 만든다. 또한 불필요한 네트워크 통신이나 다수의 데이터 응답 처리 같은 다양한 기술적 문제들을 해결해준다.
- 그래프QL은 보안과 최적화 관점에서 몇가지 문제를 가진다. 그래프QL의 유연성 때문에 API의 보안 취약성을 고려해야한다. 그래프QL API의 캐시도 (REST API같은) 고정된 API 엔드포인트를 캐싱하는 것보다 훨씬 어렵다. 따라서 그래프QL을 배우는 데에는 다른 기술보다 많은 노력과 시간을 요한다.
