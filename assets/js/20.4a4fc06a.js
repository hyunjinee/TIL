(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{426:function(t,a,s){"use strict";s.r(a);var n=s(56),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"이터레이터와-제너레이터"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#이터레이터와-제너레이터"}},[t._v("#")]),t._v(" 이터레이터와 제너레이터")]),t._v(" "),s("p",[t._v("ES6에서는 매우 중요한 개념인 이터레이터와 제너레이더, 제너레이터는 이터레이터에 의존하는 개념이므로 이터레이터부터 알아보자.")]),t._v(" "),s("p",[t._v("이터레이터는 '지금 어디 있는지' 파악할 수 있도록 돕는다는 면에서 일종의 책갈피와 비슷한 개념이다. 배열은 이터러블 객체의 좋은 예이다. 책에 여러페이지가 있는 것처럼 배열에는 여러 요소가 들어있으므로, 책에 책갈피를 끼울 수 있듯 배열에는 이터레이터를 사용 할 수 있다. 책과 책갈피의 비유를 계속 사용해보자. book이란 배열이 있고, 이 배열의 각 요소는 책의 한페이지를 나타내는 문자열 이라고 하자. 한페이지에 문장 하니씩 들어있는 어린이용 동화책이다.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" book "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Twinkle, twinke, little bat!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"How I wonder what you\'re at!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Up above the world you fly"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Like a tea tray in the sky"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("이제 book배열에 values 메서드를 써서 이터레이터를 만들수 있다.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" it "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" book"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("이터레이터(보통 it 이라고 줄인다.) 는 책갈피지만, 이책에만 사용할 수 있다. 그리고 아직은 책갈피를 꽂을 수 없다. 읽지 않았기 때문이다. 읽기 시작하려면 이터레이터의 next 메서드를 호출한다. 이 메서드가 만환하는 객체에는 value 프로퍼티와 done 프로퍼티 가있다.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("it"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {value: "Twinkle, twinkle, little bat! , done:false}')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 쭉 진행해서")]),t._v("\nit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {value: "Like a tea tray in the sky", done: false }')]),t._v("\nit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// {value: undefined, done:true}")]),t._v("\n")])])]),s("p",[t._v("책의 마지막 페이지를 읽으면 다 읽은 거지만, 이터레이터는 마지막 페이지를 반환했다해서 끝난게 아니고 한번더 해야 끝이다.\n더 진행할 것이 없으면 value 는 undefined 가 되고 next는 계속 호출 할 수 있다. 물론 그렇다고 결과가 바뀌는 것은 아니다. 일단 이터레이터가 끝까지 진행하면 뒤로 돌아가서 다른 데이터를 제공 할 수 없다.\nit.next()를 호출하는 중간에 다른 일도 가능하다.\n이 배열의 요소를 나열하는 것이 목적이라면 for 루프나 for of 루프를 쓸 수 있다.\nfor of 루프는 이터레이터를 사용해서 루프를 실행한다. 이터레이터만 제공 할 수 있다면 무엇이든 for ..of 루프와 함께 쓸 수 있다.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" it "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" book"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" current "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" it"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("current"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("done"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("current"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  current "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" it"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("이터레이터는 모두 독립적이다. 즉, 새 이터레이터를 만들 때마다 처음부터 시작한다. 그리고 각각 다른 요소를 가르키는 이터레이터 여러개를 동시에 사용할 수 있다.\n객체마다 이터레이션 메커니즘을 따로 정할수 있으므로 역행하는 이터레이터를 만드는 것도 가능하긴하다. 하지만 특별한 경우가 아니라면 권장하지 않는다.")]),t._v(" "),s("h2",{attrs:{id:"_12-1-이터레이션-프로토콜"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-이터레이션-프로토콜"}},[t._v("#")]),t._v(" 12.1 이터레이션 프로토콜")]),t._v(" "),s("p",[t._v("이터레이터는 그 자체로 쓸모가 있다기보다는, 더 쓸모있는 동작이 가능해지도록 한다는 의미가 있다. 이터레이터 프로토콜은 모든 객체를 이터러블 객체로 바꿀수 있다.\n이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator 가 있고 이 메서드가 이터레이터처럼 동작하는 객체, 즉 value 와 done 프로퍼티가 있는 객체를 반환하는 next 메서드를 가진 객체를 반환한다면 그 클래스의 인스턴스는 이터러블 객체라는 뜻이다.")]),t._v(" "),s("h2",{attrs:{id:"_12-2-제너레이터"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-제너레이터"}},[t._v("#")]),t._v(" 12.2 제너레이터")]),t._v(" "),s("p",[t._v("제너레이터란 이터레이터를 사용해 자신의 실행을 제어하는 함수이다. 일반적인 함수는 매개변수를 받고 값을 반환하지만, 호출자는 매개변수 외에는 함수의 실행을 제어할 방법이 없다. 함수를 호출하면 그 함수가 종료될 때까지 제어권을 완전히 넘기게 된다.하지만 제너레이터에서는 그렇지 않다.\n제너레이터는 두가지 새로운 개념을 도입한다. 하나는 함수의 실행을 개별적 단계로 나눔으로써 함수의 실행을 제어한다는 것이다. 다른 하나는 실행중인 함수와 통신한다는 것이다.")]),t._v(" "),s("ul",[s("li",[t._v("제너레이터는 언제든 호출자에게 제어권을 넘길 수 있다(yield)")]),t._v(" "),s("li",[t._v("제너레이터는 호출한 즉시 실행되지는 않는다. 대신 이터레이터를 바노한하고 이터레이터의 next메서드를 호출함에 따라 실행된다.\n제너레이터를 만들 때는 function 키워드 뒤에 애스터리스크(*)를 붙인다. 이것을 제외하면 문법은 일반적인 함수와 같다. 제너레이터에서는 return 외에 yield 키워드를 쓸 수 있다. 제너레이터를 호출하면 이터레이터를 얻는다.")])]),t._v(" "),s("h3",{attrs:{id:"_12-2-1-yield-표현식과-양방향-통신"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-1-yield-표현식과-양방향-통신"}},[t._v("#")]),t._v(" 12.2.1 yield 표현식과 양방향 통신")]),t._v(" "),s("p",[t._v("제너레이터와 호출자 사이에는 양방향 통신이 가능하다. 통신은 yield 표현식을 통해서 이루어진다. 표현식은 값으로 평가되고 yield는 표현식이므로 반드시 어떤 값으로 평가된다. yield 표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수이다.\n대화를 이어가는 제너레이터를 만들어보자.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("interrogate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"what is your name?"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" color "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"What is your favorite color?"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'s favorite color is ")]),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("color"),s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("이 제너레이터를 호출하면 이터레이터를 얻는다. 그리고 제너레이터의 어떤 부분도 아직 실행하지 않은 상태이다. next를 호출하면 제너레이터는 첫 번째 행을 실행하려고 한다. 하지만 그 행에는 yield 표현식이 들어있으므로 제너레이터는 반드시 제어권을 호출자에게 넘겨야 한다. 제너레이터의 첫번쨰 행이 완료되려면 호출자가 next를 호출해야 한다. 그러면 name은 next에서 전달하는 값을 받는다. 다음은 제너레이터를 끝까지 실행한후의 모습이다.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" it "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("interrogate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {value: "What is your name?", done:false}')]),t._v("\nit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Ethan"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {value: "What is your favorite color?",done:false}')]),t._v("\nit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"orange"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {value: "Ethan\'s favorite color is oragne.", done:true}')]),t._v("\n")])])]),s("ol",[s("li",[t._v("제너레이터는 이터레이터를 반환하고 일시 정지한 상태로 시작한다.")]),t._v(" "),s("li",[t._v('undefined 를 제너레이터에 넘긴다.(이값은 사용되지 않는다.) 제너레이터는 "What is your name?" 을 넘기고(yield) 일시정지한다.')]),t._v(" "),s("li",[t._v('"Ethan"을 제너레이터에 넘긴다. 제너레이터는 "What is your favorite color?" 를 넘기고 일시정지한다.')]),t._v(" "),s("li",[t._v('"orange"를 제너레이터에 넘긴다. 제너레이터는 풀 문장을 반환하고 멈춘다.')])]),t._v(" "),s("p",[t._v("이 예제를 보면 제너레이터를 활용하면 호출자가 함수의 실행을 제어 할 수 있어서 아주 유용하게 쓸 수 있다는 것을 알 수 있다. 호출자가 제너레이터에 정보를 전달하므로, 제너레이터는 그 정보에 따라 자신의 동작 자체를 바꿀 수 있다. 추가로 제너레이터는 화살표기법으로 만들수 없으며, 반드시 function* 를 사용해서 만들어야한다.")]),t._v(" "),s("h3",{attrs:{id:"_12-2-2-제너레이터와-return"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-2-제너레이터와-return"}},[t._v("#")]),t._v(" 12.2.2 제너레이터와 return")]),t._v(" "),s("p",[t._v("yield문은 설령 제너레이터의 마지막 문이더라도 제너레이터를 끝내지 않는다. 제너레이터에서 return 문을 사용하면 그 위치와 관계없이 done 은 true 가 되고, value 프로퍼티는 return 이 반환하는 값이 된다.\n제너레이터에서 중요한 값을 return 으로 반환하려 하면안된다. 제너레이터가 반환하는 값을 사용하려 할때는 yield를 써야하고 return 은 제너레이터를 중간에 종료하는 목적으로만 사용해야 한다. 따라서 제너레이터에 return 을 쓸 때는 반환값을 쓰지 않는 습관을 들여야한다.")]),t._v(" "),s("h2",{attrs:{id:"_12-3-요약"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-요약"}},[t._v("#")]),t._v(" 12.3 요약")]),t._v(" "),s("p",[t._v("이터레이터는 배열이나 객체처럼 여러가지 값을 제공할 수 있는 컬렉션의 동작 방식을 표준화했다. 이터레이터로 할 수 있는 일은 ES6이전에도 모두 할 수 있었으므로, 어떤 기능이 추가된 것은 아니다. 중요하면서도 자주 사용하는 패턴을 표준화 했다는데 의미가 있다.\n제너레이터를 사용하면 함수를 훨씬 더 유연하고 효율적으로 사용할 수 있다. 이제 함수를 호출하는 부분에서 데이터를 제공하고, 함수가 완료되길 기다렸다가 반환값을 받는다는 사고방식에 얽매일 필요가 없다. 제너레이터는 모든 연산을 지연시켰다가 필요할 때만 수행하게 만들 수 있다. 이건 기능 진짜 좋은듯!!")])])}),[],!1,null,null,null);a.default=e.exports}}]);